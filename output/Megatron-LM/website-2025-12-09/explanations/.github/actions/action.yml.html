<h1>.github/actions/action.yml</h1>
<p>这个文件 (<code>action.yml</code>) 是一个 <strong>GitHub Actions 的“复合操作” (Composite Action)</strong>。</p>
<p>你可以把它想象成一个<strong>“测试任务外包说明书”</strong>。当其他的 GitHub 流程（Workflow）想要跑测试时，不需要每次都把所有步骤重写一遍，而是直接引用这个模板，告诉它：“嘿，按照这个说明书，帮我跑一下测试”。</p>
<p>为了让你更容易理解，我把它拆解成一个 <strong>“打工人的 To-Do List”</strong>，假设你就是那个负责跑测试的机器人，你的任务清单如下：</p>
<hr />
<h3>📋 任务清单：NeMo 测试执行流程</h3>
<h4>第一阶段：准备工作 (环境搭建)</h4>
<ol>
<li><strong>📥 签收代码 (Checkout repository)</strong><ul>
<li>把 GitHub 仓库里的最新代码下载到当前的工作目录。</li>
</ul>
</li>
<li><strong>🔧 调整权限 (Change ownership)</strong><ul>
<li>把 <code>/home/runner/</code> 目录的所有权改成当前用户，防止后面出现“权限不足”的报错。</li>
</ul>
</li>
<li><strong>🐍 安装 Python (Setup python)</strong><ul>
<li>在机器上安装 Python 3.12 版本。</li>
</ul>
</li>
<li><strong>🛠 安装工具 (Install uuidgen &amp; GH CLI)</strong><ul>
<li>安装 <code>uuidgen</code> (用来生成唯一ID) 和 <code>gh</code> (GitHub 命令行工具，用来查 Pull Request 的信息)。</li>
</ul>
</li>
</ol>
<h4>第二阶段：制定作战计划 (生成运行脚本)</h4>
<p>这里的逻辑分成了两条路，看你是跑“单元测试”还是“端到端(E2E)测试”：</p>
<ol>
<li><strong>📝 撰写运行脚本 (Create run-script)</strong><ul>
<li><strong>情况 A：如果是单元测试 (<code>is_unit_test: true</code>)</strong><ul>
<li>创建一个叫 <code>job.sh</code> 的脚本。</li>
<li>内容是：设置环境变量，安装依赖（用 <code>uv</code> 工具），然后运行 <code>launch_nemo_run_workload.py</code> 来启动单元测试。</li>
</ul>
</li>
<li><strong>情况 B：如果是 E2E 测试 (<code>is_unit_test: false</code>)</strong><ul>
<li><strong>先查户口</strong>：看看这个 Pull Request (PR) 上有没有打 <code>Run tests</code> 或 <code>Run functional tests</code> 的标签 (Label)。</li>
<li><strong>决定力度</strong>：<ul>
<li>有 <code>Run tests</code> 标签 -&gt; 跑完整测试 (<code>mr-github</code>) + 轻量模式。</li>
<li>有 <code>Run functional tests</code> 标签 -&gt; 跑完整测试 (<code>mr-github</code>)。</li>
<li>啥标签都没有 -&gt; 跑精简版测试 (<code>mr-github-slim</code>)。</li>
</ul>
</li>
<li><strong>写脚本</strong>：把决定好的参数写进 <code>job.sh</code>，准备调用 <code>launch_nemo_run_workload.py</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4>第三阶段：准备资源</h4>
<ol>
<li><strong>⏱️ 设定闹钟 (Set timeout)</strong><ul>
<li>计算一下超时时间（把输入的分钟数换算成秒）。</li>
</ul>
</li>
<li><strong>🐳 拉取镜像 (Pull container)</strong><ul>
<li>从 Docker Hub 或仓库里把指定的 Docker 镜像 (<code>container-image</code>) 拉下来。测试是在这个容器环境里跑的。</li>
</ul>
</li>
</ol>
<h4>第四阶段：正式开工</h4>
<ol>
<li><strong>🚀 执行脚本 (Run main script)</strong><ul>
<li>运行刚才写好的 <code>job.sh</code>。</li>
<li><strong>关键点</strong>：不管成功失败，先把“退出代码 (Exit Code)”记下来，不要直接报错退出，因为后面还要处理日志。</li>
</ul>
</li>
</ol>
<h4>第五阶段：验收与收尾</h4>
<ol>
<li><strong>🧐 检查结果 (Check result)</strong><ul>
<li>生成独特的日志文件名和覆盖率报告文件名（用 UUID 生成，防止重名）。</li>
<li><strong>判断成败</strong>：<ul>
<li>如果刚才跑失败了，但是输入参数里说这个任务是 <code>is-optional</code> (可选的)，那就假装它成功了，只发个警告。</li>
<li>如果真的失败了且不是可选的，那就标记为失败。</li>
</ul>
</li>
<li>如果是单元测试，还会生成代码覆盖率报告。</li>
</ul>
</li>
<li><strong>📤 上传覆盖率报告 (Upload coverage)</strong><ul>
<li>如果有覆盖率文件，把它打包上传到 GitHub Artifacts，方便人类查看。</li>
</ul>
</li>
<li><strong>📦 上传日志 (Upload logs)</strong><ul>
<li>把测试过程中的日志 (<code>logs</code> 文件夹或 <code>assets_dir</code>) 打包上传。这样如果测试挂了，开发人员可以下载日志去修 Bug。</li>
</ul>
</li>
</ol>
<hr />
<h3>总结一下它的核心逻辑</h3>
<p>这个文件的核心作用就是 <strong>“在一个 Docker 容器里，用 Python 脚本 (<code>launch_nemo_run_workload.py</code>) 跑测试”</strong>。</p>
<p>它相比直接跑命令，多了很多<strong>“智能”</strong>判断：
*   它会自动看 PR 的标签来决定跑多少测试（全量还是精简）。
*   它用 <code>uv</code> 来加速 Python 包的安装。
*   它处理了“虽然失败了但不影响大局”的可选任务逻辑。
*   它自动帮你打包了日志和测试报告。</p>