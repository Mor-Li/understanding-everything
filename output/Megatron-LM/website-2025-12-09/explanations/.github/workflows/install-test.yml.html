<h1>.github/workflows/install-test.yml</h1>
<p>这个文件叫 <code>.github/workflows/install-test.yml</code>，它是 <strong>GitHub Actions</strong> 的配置文件。</p>
<p><strong>简单来说，这个文件的作用是：</strong>
每当有人修改了代码（提交或合并），GitHub 就会自动启动一台电脑，尝试安装这个软件（Megatron-LM），看看能不能安装成功，以及安装后能不能正常运行基础功能。就像是一个<strong>自动化的质检员</strong>。</p>
<p>为了让你更容易理解，我把它想象成一个<strong>“任务清单 (Todo List)”</strong>，按照时间顺序一步一步给你讲。</p>
<hr />
<h3>📋 自动化质检员的任务清单 (Todo List)</h3>
<h4>第一阶段：接单 (触发条件)</h4>
<ul>
<li>[ ] <strong>监听动作</strong>：<ul>
<li>是否有人把代码推送到 <code>dev</code> 或 <code>main</code> 分支？</li>
<li>是否有人提交了 Pull Request (PR)？</li>
<li>是否有发布新版本的标签？</li>
</ul>
</li>
<li>[ ] <strong>如果满足以上任意一条</strong>：准备开始干活。</li>
</ul>
<h4>第二阶段：预检 (Pre-flight)</h4>
<ul>
<li>[ ] <strong>任务 1：检查是否有必要测试</strong> (<code>pre-flight</code> job)<ul>
<li>看看这次改动是不是只改了文档（比如 README）？如果是，就不用费劲去测试安装代码了，省钱省时间。</li>
<li><em>结果</em>：告诉后面的任务是“通过”还是“跳过”。</li>
</ul>
</li>
</ul>
<h4>第三阶段：正式测试 (核心任务)</h4>
<p>这里有两个并行的任务，分别用两种不同的方式尝试安装软件，互不干扰。</p>
<p><strong>任务 A：用传统方式 (Pip) 测试安装</strong> (<code>pip-test-pytorch</code>)
- [ ] <strong>前置检查</strong>：确认不是只改了文档，且是在 NVIDIA 官方仓库里。
- [ ] <strong>准备环境</strong>：
    - 启动一台 Linux 电脑 (AMD64)。
    - 拉取一个装好 PyTorch 的 Docker 镜像（版本 <code>25.05-py3</code>，这是一个很新的环境）。
- [ ] <strong>设置变量</strong>：告诉电脑 CUDA（显卡驱动库）在哪里，Python 环境在哪里。
- [ ] <strong>下载代码</strong>：把当前的 Megatron-LM 代码下载下来。
- [ ] <strong>执行安装</strong>：运行 <code>bash docker/common/install.sh</code>。这是核心步骤，模拟用户安装软件的过程。
- [ ] <strong>验证安装</strong>：
    - 下载一个测试小工具 (<code>FW-CI-templates</code>)。
    - 运行脚本，尝试在 Python 里输入 <code>import megatron.core</code>。
    - <em>判断标准</em>：如果报错（比如缺包、语法错误），任务失败；如果不报错，任务成功。</p>
<p><strong>任务 B：用新潮方式 (UV) 测试安装</strong> (<code>uv-test-pytorch</code>)
- [ ] <strong>前置检查</strong>：同上。
- [ ] <strong>准备环境</strong>：同上。
- [ ] <strong>设置变量</strong>：同上，但额外设置了 <code>UV</code> 相关的变量（<code>uv</code> 是一个比 pip 快得多的 Python 包管理工具）。
- [ ] <strong>执行安装</strong>：运行 <code>bash docker/common/install.sh --use-uv</code>。这次加上了 <code>--use-uv</code> 参数，专门测试用 uv 安装是否正常。
- [ ] <strong>(已注释) 验证安装</strong>：
    - <em>注意</em>：文件里这部分被注释掉了（被 <code>#</code> 挡住了）。
    - <em>原因</em>：注释里写着 <code>NGC PyTorch 25.05</code> 版本里的 <code>triton</code> 组件在纯 CPU 机器上有 bug。所以暂时只测安装过程，不敢测运行导入，怕误报错误。</p>
<h4>第四阶段：写总结报告 (Summary)</h4>
<ul>
<li>[ ] <strong>任务 4：汇总结果</strong> (<code>install-test-summary</code>)<ul>
<li>[ ] 等待任务 A 和任务 B 结束。</li>
<li>[ ] <strong>检查成绩单</strong>：<ul>
<li>如果前面的任务都成功了 -&gt; ✅ 打绿勾，告诉 GitHub "一切正常"。</li>
<li>如果前面有任务失败了 -&gt; ❌ 报错，并列出是哪个任务挂了。</li>
<li>如果因为是文档修改而跳过了测试 -&gt; ✅ 也算通过。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3>🔍 关键技术点解释（文中的“黑话”）</h3>
<p>如果你想看懂具体的代码细节，这里有几个关键词的翻译：</p>
<ol>
<li>
<p><strong><code>runs-on: linux-amd64-cpu16</code></strong>:</p>
<ul>
<li>指定这个测试跑在什么样的服务器上。这里是 Linux 系统，x86 架构，CPU 比较强（16核），但<strong>没有 GPU</strong>（注意看后面提到 Triton 在 CPU 机器上报错，暗示了测试环境可能没有显卡或不调用显卡）。</li>
</ul>
</li>
<li>
<p><strong><code>container: image: nvcr.io/nvidia/pytorch:25.05-py3</code></strong>:</p>
<ul>
<li>不想从零开始装系统，直接用 NVIDIA 官方打包好的环境。里面已经装好了 PyTorch、CUDA 等基础软件，省去了很多配置时间。</li>
</ul>
</li>
<li>
<p><strong><code>strategy: matrix: python-version: ['3.12']</code></strong>:</p>
<ul>
<li>这里定义了测试矩阵。目前只测 Python 3.12 版本。如果以后想测 3.10，只要在这里加一行，GitHub 就会自动裂变出多个任务并行跑。</li>
</ul>
</li>
<li>
<p><strong><code>env: ...</code> (Set PATH 步骤)</strong>:</p>
<ul>
<li><code>LD_LIBRARY_PATH</code>: 告诉 Linux 去哪里找动态链接库（比如 CUDA 库）。</li>
<li><code>UV_PROJECT_ENVIRONMENT</code>: 告诉 <code>uv</code> 工具把包安装到哪里。</li>
</ul>
</li>
<li>
<p><strong><code>needs: [pre-flight]</code></strong>:</p>
<ul>
<li>依赖关系。意思是：“先做完 <code>pre-flight</code> (预检)，再做我”。如果预检没过，后面都不跑。</li>
</ul>
</li>
</ol>
<h3>总结</h3>
<p>这个文件的核心观点是：<strong>“为了保证 Megatron-LM 的质量，每次代码变动，都要在最新的 NVIDIA PyTorch 环境（Python 3.12）下，分别用 Pip 和 UV 两种方式试着安装一遍，确保用户下载后能装上且能引用。”</strong></p>