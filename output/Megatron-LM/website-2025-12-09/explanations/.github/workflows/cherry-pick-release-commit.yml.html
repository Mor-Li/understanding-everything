<h1>.github/workflows/cherry-pick-release-commit.yml</h1>
<p>这份文件是一个 <strong>GitHub Actions 自动化流程（Workflow）</strong> 的配置文件。</p>
<p>为了让你更容易理解，我们可以把这个脚本想象成一个 <strong>“自动搬运工”</strong>。它的主要任务是：当你把代码更新到主分支（Main）时，它会自动尝试把这些更新“复制粘贴”到其他的发布分支（Release Branches）上去。</p>
<p>在技术术语里，这种把一个分支的提交（Commit）单独拿出来应用到另一个分支的操作叫 <strong>Cherry-pick</strong>。</p>
<p>下面我按照你要的 <strong>To-Do List（任务清单）</strong> 格式，一步一步拆解这个机器人在做什么：</p>
<h3>🤖 机器人的任务清单 (To-Do List)</h3>
<h4>1. 任务触发：盯着 <code>main</code> 分支</h4>
<ul>
<li><strong>代码位置：</strong>
    <code>yaml
    on:
      push:
        branches:
          - main</code></li>
<li><strong>机器人的动作：</strong> 机器人会时刻监控代码仓库。一旦有人向 <code>main</code> 分支 <strong>推送（Push）</strong> 了新代码（通常是合并了一个 PR），机器人就会大喊：“有活干了！”，并开始执行下面的任务。</li>
</ul>
<h4>2. 安全检查：确认地点</h4>
<ul>
<li><strong>代码位置：</strong>
    <code>yaml
    if: github.repository == 'NVIDIA/Megatron-LM'</code></li>
<li><strong>机器人的动作：</strong> 机器人会先看一眼：“我现在是在官方的 <code>NVIDIA/Megatron-LM</code> 仓库里吗？”<ul>
<li>如果是：继续干活。</li>
<li>如果不是（比如是你自己 Fork 出去的仓库）：直接下班，什么都不做。</li>
</ul>
</li>
</ul>
<h4>3. 寻找目标：确定要搬运到哪里</h4>
<ul>
<li><strong>代码位置：</strong>
    <code>yaml
    with:
      target-branches-pattern: 'core_(*dev_)?r[0-9]+\.[0-9]+\.[0-9]+'</code></li>
<li><strong>机器人的动作：</strong> 机器人手里拿着一个“正则表达式”（搜索规则），去仓库里找符合特定名字的分支。<ul>
<li>它在找类似 <code>core_r0.6.0</code> 或者 <code>core_dev_r1.2.3</code> 这样的分支（通常是旧版本的维护分支）。</li>
<li><strong>目的：</strong> 它想把你在 <code>main</code> 上修好的 Bug，同步应用到这些旧版本分支上。</li>
</ul>
</li>
</ul>
<h4>4. 执行搬运：调用外部“外包团队”</h4>
<ul>
<li><strong>代码位置：</strong>
    <code>yaml
    uses: NVIDIA-NeMo/FW-CI-templates/.github/workflows/_cherry_pick.yml@v0.65.9</code></li>
<li><strong>机器人的动作：</strong> 这个脚本本身其实是个“空壳经理”，具体的脏活累活它不自己干，而是调用了另一个仓库（<code>NVIDIA-NeMo/FW-CI-templates</code>）里写好的通用脚本 <code>_cherry_pick.yml</code>。<ul>
<li>它对“外包团队”说：“嗨，按照我刚才给你的目标分支名单，把 <code>main</code> 分支上刚进来的那个代码提交（Commit），给我 Cherry-pick（复制）过去。”</li>
</ul>
</li>
</ul>
<h4>5. 汇报结果：通知管理员</h4>
<ul>
<li><strong>代码位置：</strong>
    <code>yaml
    secrets:
      PAT: ${{ secrets.PAT }}
      SLACK_WEBHOOK...</code></li>
<li><strong>机器人的动作：</strong><ul>
<li>如果搬运成功（自动创建了一个新的 PR 到旧分支），或者搬运失败（代码冲突了），它会通过 Slack（一种聊天软件）发送消息通知管理员。</li>
<li>它使用了 <code>PAT</code> (Personal Access Token) 来获取权限进行代码操作。</li>
</ul>
</li>
</ul>
<hr />
<h3>总结一下</h3>
<p><strong>这个文件的核心观点是：</strong>
为了保证旧版本（Release分支）也能享受到最新版本（Main分支）的 Bug 修复或功能更新，<strong>不要让人工去一个一个分支手动复制粘贴代码</strong>，而是让这个脚本在每次 Main 分支更新时，<strong>自动尝试</strong>把代码同步过去。</p>
<p><strong>简单说就是：</strong> “主分支更新了 -&gt; 自动把更新同步给所有旧版本分支”。</p>