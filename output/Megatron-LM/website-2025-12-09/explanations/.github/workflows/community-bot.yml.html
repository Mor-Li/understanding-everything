<h1>.github/workflows/community-bot.yml</h1>
<p>这份文件其实是一份<strong>“自动化脚本的说明书”</strong>。</p>
<p>它读起来像乱码，是因为它不是写给人看的文章，而是写给 GitHub（代码托管平台）看的<strong>指令配置</strong>。</p>
<p>为了让你看懂，我把它拆解成一个 <strong>5步走的“学习任务清单” (ToDo List)</strong>。我们把你想象成这个仓库的管理员，现在你要招聘一个“机器人助理”，这份文件就是你写给这个助理的<strong>岗位描述（JD）</strong>。</p>
<hr />
<h3>✅ Task 01：搞清楚“这是在哪儿？”（文件背景）</h3>
<ul>
<li><strong>线索</strong>：看文件路径 <code>.github/workflows/community-bot.yml</code></li>
<li><strong>解读</strong>：<ul>
<li>在 GitHub 项目里，放在 <code>.github/workflows</code> 文件夹下的文件，都是<strong>“自动化工作流”</strong>。</li>
<li><strong>通俗理解</strong>：这就像你在公司里制定的一套“SOP（标准作业程序）”。一旦满足某些条件，系统就会自动执行这套程序，不需要人盯着。</li>
</ul>
</li>
</ul>
<h3>✅ Task 02：搞清楚“它是谁？”（角色定义）</h3>
<ul>
<li><strong>线索</strong>：看代码里的 <code>name: Community Bot</code></li>
<li><strong>解读</strong>：<ul>
<li>这个自动化程序的名字叫“社区机器人（Community Bot）”。</li>
<li><strong>通俗理解</strong>：你招聘了一个名叫“社区小助手”的虚拟员工。它的主要工作是帮忙打理社区里的杂事。</li>
</ul>
</li>
</ul>
<h3>✅ Task 03：搞清楚“它什么时候上班？”（触发条件）</h3>
<ul>
<li><strong>线索</strong>：看 <code>on:</code> 下面的内容
    <code>yaml
    on:
      issues: [opened, edited, ...]
      issue_comment: [created, edited, ...]</code></li>
<li><strong>解读</strong>：这是告诉机器人什么时候“醒过来”干活。<ul>
<li><strong>Issues (问题单)</strong>：当有人<strong>新建、修改、重开、关闭、删除</strong>一个 Issue（提问/报错）时。</li>
<li><strong>Issue Comment (评论)</strong>：当有人在问题单下<strong>发表、修改、删除</strong>评论时。</li>
<li><strong>通俗理解</strong>：只要社区里有人说话（提问或评论），这个机器人就会立刻收到通知：“嘿，来活了！”</li>
</ul>
</li>
</ul>
<h3>✅ Task 04：搞清楚“它具体干什么？”（核心工作）</h3>
<ul>
<li><strong>线索</strong>：看 <code>uses:</code> 这一行
    <code>yaml
    uses: NVIDIA-NeMo/FW-CI-templates/.github/workflows/_community_bot.yml@v0.65.10</code></li>
<li><strong>解读</strong>：这是最关键的一步，也是最容易看不懂的地方。<ul>
<li>这个文件<strong>本身并没有写</strong>机器人具体要干嘛（比如是自动回复？还是自动打标签？）。</li>
<li>它用 <code>uses</code> 引用了<strong>另一个地方</strong>写好的模板。那个模板在 <code>NVIDIA-NeMo</code> 这个仓库里。</li>
<li><strong>通俗理解</strong>：这是一种<strong>“外包”</strong>。<ul>
<li>你（Megatron-LM 仓库）并没有自己培训这个机器人。</li>
<li>你是直接从隔壁部门（NVIDIA-NeMo）借用了一个已经培训好的成熟机器人。</li>
<li>你对它说：“照着隔壁部门那个机器人的工作手册（<code>_community_bot.yml</code>）干活就行了。”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>✅ Task 05：搞清楚“它的工资和权限”（参数与安全）</h3>
<ul>
<li><strong>线索</strong>：看 <code>with</code>, <code>if</code>, <code>secrets</code>
    <code>yaml
    with:
      community_project_id: ${{ vars.COMMUNITY_PROJECT_ID }}
    if: github.repository == 'NVIDIA/Megatron-LM'
    secrets:
      GH_TOKEN: ${{ secrets.PAT }}</code></li>
<li><strong>解读</strong>：<ol>
<li><strong><code>with</code> (给它资料)</strong>：机器人干活需要知道把资料整理到哪里去。这里传给它一个“社区项目ID”。可以理解为告诉它：“把文件归档到第几号柜子”。</li>
<li><strong><code>if</code> (安全检查)</strong>：只有当仓库名字确实是 <code>NVIDIA/Megatron-LM</code> 时才运行。防止有人把代码复制到别的地方乱跑。</li>
<li><strong><code>secrets</code> (给它钥匙)</strong>：<code>GH_TOKEN</code> 是机器人的“工牌”或“钥匙”。因为机器人要操作仓库（比如移动帖子、整理看板），它需要权限。这个 <code>secrets.PAT</code> 就是保存在后台的一串密钥。</li>
</ol>
</li>
</ul>
<hr />
<h3>📝 总结：这文件到底讲了啥？</h3>
<p>如果用一句人话翻译整个文件：</p>
<blockquote>
<p><strong>“我是 NVIDIA Megatron-LM 项目的管理员。我设置了一个自动化规则：每当有人在 Issue 区提问或评论时，请直接调用隔壁 NVIDIA-NeMo 团队写好的那个‘社区管理机器人’程序。我会给它仓库的钥匙（Token）和归档柜的号码（Project ID），让它帮我自动整理这些帖子。”</strong></p>
</blockquote>
<p><strong>这个机器人的实际功能（虽然代码里没写，但通常包括）：</strong>
*   把新的 Issue 自动添加到项目进度看板（Project Board）里。
*   根据关键词自动分类。
*   或者检查提问格式对不对。</p>