<h1>.github/workflows/_release_library.yml</h1>
<p>这份文件 <code>_release_library.yml</code> 是一个 <strong>GitHub Actions 工作流（Workflow）</strong>。</p>
<p>简单来说，它的作用是<strong>自动化发布流程</strong>。你可以把它想象成一个“机器人项目经理”，每当你决定发布一个新版本（比如 v0.1 到 v0.2）时，这个机器人就会按照清单自动执行一系列繁琐的操作。</p>
<p>为了让你更容易理解，我把这个文件要做的事情拆解成一个 <strong>“发布任务清单 (To-Do List)”</strong>，然后一步步给你解释它是怎么做的。</p>
<hr />
<h3>📋 机器人经理的发布任务清单 (To-Do List)</h3>
<p>这个工作流按顺序执行以下任务：</p>
<ol>
<li>[ ] <strong>试运行 (Dry Run)</strong>：先假装打包试一下，确保代码没问题，别等到真发布时才报错。</li>
<li>[ ] <strong>更新版本号 (Bump Version)</strong>：<ul>
<li>计算下一个版本号是多少（比如从 1.0.0 变成 1.0.1）。</li>
<li>修改代码里的版本文件。</li>
<li>提交代码并通过 Pull Request 验证。</li>
<li>合并回主分支。</li>
</ul>
</li>
<li>[ ] <strong>正式打包发布 (Publish Wheels)</strong>：真正地构建安装包（Wheel）并上传（通常是传到 PyPI）。</li>
<li>[ ] <strong>创建 GitHub Release</strong>：在 GitHub 页面上创建一个“Release”记录，打上标签（Tag），写好更新日志。</li>
<li>[ ] <strong>发通知 (Notify)</strong>：在 Slack 群里发消息告诉大家：“发布成功啦！”</li>
</ol>
<hr />
<h3>🧐 逐步详细解读</h3>
<p>下面我按照上面的清单，对应文件里的代码块给你讲解。</p>
<h4>1. 试运行 (<code>jobs: build-test-publish-wheels-dry-run</code>)</h4>
<ul>
<li><strong>代码位置</strong>：<code>build-test-publish-wheels-dry-run</code> 部分。</li>
<li><strong>在做什么</strong>：<ul>
<li>它调用了另一个文件 <code>_build_test_publish_wheel.yml</code>。</li>
<li>关键参数是 <code>dry-run: true</code>。</li>
<li><strong>目的</strong>：这是为了安全。在做任何不可逆的操作（比如修改版本号、上传包）之前，先跑一遍测试和构建流程。如果这一步挂了，后面的都会取消。</li>
</ul>
</li>
</ul>
<h4>2. 更新版本号 (<code>jobs: bump-next-version</code>)</h4>
<p>这是文件中最长、最复杂的部分。
*   <strong>代码位置</strong>：<code>bump-next-version</code> 部分。
*   <strong>在做什么</strong>：
    1.  <strong>计算版本 (Bump version MCore / MFSDP)</strong>：
        *   脚本会去读取 <code>package_info.py</code> 文件。
        *   它会看当前版本是正式版还是预览版（rc/alpha）。
        *   <strong>逻辑</strong>：如果是 <code>rc1</code> 就变成 <code>rc2</code>；如果是正式版 <code>1.0.0</code> 就变成 <code>1.0.1</code>（Patch +1）。它分别处理了 <code>megatron.core</code> 和 <code>megatron_fsdp</code> 两个包。
    2.  <strong>创建临时分支并提交</strong>：
        *   机器人创建了一个名字像 <code>deploy-release/随机ID</code> 的临时分支。
        *   把修改后的版本号文件提交上去。
    3.  <strong>创建 PR (Pull Request)</strong>：
        *   机器人自动发起一个 PR，标题是 "beep boop 🤖: Bumping versions"。
        *   并在 PR 里评论 <code>/ok to test</code> 来触发测试。
    4.  <strong>等待检查通过 (Wait for status checks)</strong>：
        *   这是一个循环脚本（While loop）。它会每隔 10 秒去检查一下刚才那个临时分支的 CI 测试有没有通过。
        *   如果通过了，才继续；如果不通过，就报错停止。
    5.  <strong>合并代码 (Merge)</strong>：
        *   测试通过后，机器人把临时分支合并回目标分支（<code>version-bump-branch</code>）。
        *   这里还写了<strong>重试逻辑</strong>（Try 1..3），防止因为多人同时操作导致 Git 冲突（Race condition）。
    6.  <strong>清理</strong>：删除那个临时分支。</p>
<h4>3. 正式打包发布 (<code>jobs: build-test-publish-wheels</code>)</h4>
<ul>
<li><strong>代码位置</strong>：<code>build-test-publish-wheels</code> 部分。</li>
<li><strong>在做什么</strong>：<ul>
<li>再次调用 <code>_build_test_publish_wheel.yml</code>。</li>
<li>但这次关键参数是 <code>dry-run: false</code>。</li>
<li><strong>目的</strong>：这次是玩真的了。它会构建 Python 的 <code>.whl</code> 文件，并使用密钥（<code>TWINE_USERNAME/PASSWORD</code>）上传到仓库（比如 PyPI）。</li>
</ul>
</li>
</ul>
<h4>4. 创建 GitHub Release (<code>jobs: create-gh-release</code>)</h4>
<ul>
<li><strong>代码位置</strong>：<code>create-gh-release</code> 部分。</li>
<li><strong>在做什么</strong>：<ul>
<li><strong>生成日志</strong>：它会根据版本号去 <code>CHANGELOG.md</code> 里抓取对应的更新说明。如果是预览版（rc），就只写个日期。</li>
<li><strong>调用 API</strong>：使用 GitHub API 创建一个新的 Release。</li>
<li><strong>打标签</strong>：给代码打上类似 <code>v0.5.0</code> 的 Tag。</li>
</ul>
</li>
</ul>
<h4>5. 发通知 (<code>jobs: notify</code>)</h4>
<ul>
<li><strong>代码位置</strong>：<code>notify</code> 部分。</li>
<li><strong>在做什么</strong>：<ul>
<li>它构建了一个包含 GitHub Release 链接和 PyPI 下载链接的消息。</li>
<li>通过 Webhook 把这个好消息发送到公司的 Slack 频道里。</li>
</ul>
</li>
</ul>
<hr />
<h3>💡 总结</h3>
<p>这个文件的核心逻辑就是：
<strong>“先测试 -&gt; 没问题就改版本号 -&gt; 再次测试版本号修改 -&gt; 合并版本号 -&gt; 正式发布包 -&gt; 在 GitHub 上记录 -&gt; 通知大家。”</strong></p>
<p>这就避免了人工手动改版本号容易出错、或者发布了坏包的风险。</p>