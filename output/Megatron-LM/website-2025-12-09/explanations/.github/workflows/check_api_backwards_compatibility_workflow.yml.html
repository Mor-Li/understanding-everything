<h1>.github/workflows/check_api_backwards_compatibility_workflow.yml</h1>
<p>没问题，这份文件确实看着有点复杂。我们可以把它想象成一个<strong>“自动化的代码安检员”</strong>。</p>
<p>它的核心目的是：<strong>防止你提交的新代码“破坏”了旧的 API（接口），导致以前能跑的代码现在跑不通了（即向后兼容性检查）。</strong></p>
<p>我把它拆解成一个 <strong>Task Todo List</strong>，按这个安检员工作的顺序一步步给你讲：</p>
<hr />
<h3>🤖 任务清单：API 兼容性安检流程</h3>
<h4>1. 📋 任务一：决定什么时候上班 (Triggers)</h4>
<p><strong>文件位置：</strong> <code>on: ...</code>
*   <strong>动作</strong>：这个安检员不是每时每刻都在，只有以下情况它才会出现：
    *   你有代码推送到 <code>dev</code>, <code>main</code> 或者 <code>pull-request</code> 分支时。
    *   代码合并组（Merge Group）请求检查时。
    *   或者你手动点击按钮触发它（<code>workflow_dispatch</code>）。</p>
<h4>2. 🔍 任务二：预检，看是否需要干活 (Job: <code>pre-flight</code>)</h4>
<p><strong>文件位置：</strong> <code>jobs: pre-flight</code>
*   <strong>动作</strong>：安检员很忙，不想做无用功。它会先检查你这次修改的文件。
*   <strong>逻辑</strong>：
    *   <strong>Step 1</strong>：找到你这次修改和主分支（<code>main</code> 或 <code>dev</code>）的对比点（<code>BASE_SHA</code>）。
    *   <strong>Step 2</strong>：检查你有没有修改 <code>megatron/core</code> 目录下的 Python 文件。
        *   <em>排除</em> 测试文件 (<code>tests</code>) 和旧遗留代码 (<code>legacy</code>)。
    *   <strong>决策</strong>：
        *   如果你只改了文档或测试代码 -&gt; <strong>跳过后续检查</strong> (<code>should_skip=true</code>)，大家省事。
        *   如果你改了核心代码 -&gt; <strong>必须检查</strong> (<code>should_skip=false</code>)，进入下一关。</p>
<h4>3. 🛠️ 任务三：准备工具与基准 (Job: <code>check-compatibility</code>)</h4>
<p><strong>文件位置：</strong> <code>jobs: check-compatibility</code>
*   <strong>前提</strong>：只有当任务二说“不能跳过”时，这一步才会运行。
*   <strong>动作</strong>：
    *   <strong>安装环境</strong>：安装 Python 3.12 和一个叫 <code>griffe</code> 的工具（这是一个专门用来分析 Python 代码结构的库）。
    *   <strong>确定基准 (Baseline)</strong>：我们要拿你的新代码和谁比？
        *   如果是手动触发，用你输入的版本。
        *   如果是自动触发，用文件里写死的默认版本 <code>DEFAULT_BASELINE</code>（在这个文件里是一个具体的 commit hash：<code>b51db3e...</code>）。
    *   <strong>目的</strong>：安检员现在手里有了两份代码：一份是<strong>“过去稳定的版本”</strong>（基准），一份是<strong>“你现在的版本”</strong>。</p>
<h4>4. ⚔️ 任务四：执行对比检查 (Running the script)</h4>
<p><strong>文件位置：</strong> <code>steps: Run compatibility check</code>
*   <strong>动作</strong>：运行一个 Python 脚本 <code>scripts/check_api_backwards_compatibility.py</code>。
*   <strong>逻辑</strong>：
    *   脚本会对比“基准代码”和“你的代码”的公开 API（函数名、参数、类方法等）。
    *   <strong>关键点</strong>：如果你的代码删除了一个旧函数，或者改变了参数顺序，或者把必填参数改名了，脚本就会报错（Exit Code != 0）。
    *   结果会被存到一个临时文件 <code>compat_check_output.txt</code> 里。</p>
<h4>5. 🚨 任务五：如果发现破坏性修改，教你怎么做 (Failure Handling)</h4>
<p><strong>文件位置：</strong> <code>steps: Fail job if breaking changes detected</code>
*   <strong>动作</strong>：如果任务四的脚本报错了，安检员会非常贴心地在控制台打印一大段教程，告诉你怎么修。
*   <strong>它给出的 4 种解决方案（Viewpoints）</strong>：
    1.  <strong>撤销修改</strong>（Revert）：如果你是不小心改坏的，改回去。
    2.  <strong>标记为内部 API</strong>（Internal）：如果这个函数本来就不给外人用，加上 <code>@internal_api</code> 装饰器，安检员就不管你了。
    3.  <strong>标记为实验性 API</strong>（Experimental）：如果是新功能，还不稳定，加上 <code>@experimental_api</code>。
    4.  <strong>使用弃用标记</strong>（Deprecation）：如果你真的要删旧功能，不能直接删，要先加 <code>@deprecated</code> 装饰器，告诉用户“这个以后会删”，给个缓冲期。</p>
<h4>6. ✅ 任务六：汇报最终结果 (Job: <code>api-backward-compatibility-summary</code>)</h4>
<p><strong>文件位置：</strong> <code>jobs: api-backward-compatibility-summary</code>
*   <strong>动作</strong>：这是最后一步汇总。
*   <strong>逻辑</strong>：
    *   如果前面的检查都通过了，或者被跳过了 -&gt; <strong>打绿勾</strong> ✅。
    *   如果前面检查发现了破坏性修改 -&gt; <strong>打红叉</strong> ❌，并阻止你的代码合并。</p>
<hr />
<h3>总结一下这个文件的核心观点</h3>
<p>这个 Workflow 实际上在强制执行一种<strong>开发规范</strong>：</p>
<ol>
<li><strong>向后兼容是红线</strong>：只要是公开的函数（Public API），不能随便改签名或删除，否则会报错。</li>
<li><strong>只有核心代码受监控</strong>：它只关心 <code>megatron/core</code>，不关心测试代码。</li>
<li><strong>提供了“逃生通道”</strong>：如果你确实需要改动 API，你必须显式地告诉系统“这是内部用的”或者“这是实验性的”，否则系统默认认为你在破坏兼容性。</li>
</ol>
<p>你看懂了吗？其实就是：<strong>对比新旧代码 -&gt; 发现接口变了 -&gt; 报错并让你加装饰器或者改回去。</strong></p>