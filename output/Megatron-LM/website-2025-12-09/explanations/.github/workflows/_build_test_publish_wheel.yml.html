<h1>.github/workflows/_build_test_publish_wheel.yml</h1>
<p>这份文件其实就是一个 <strong>“自动化流水线说明书”</strong>。</p>
<p>你可以把它想象成一个工厂的生产流程图。它的目标非常明确：<strong>把代码打包成 Python 的安装包（Wheel 文件），测试它，然后发布到网上（PyPI）供别人下载。</strong></p>
<p>为了让你好理解，我把这个流程拆解成一个 <strong>“待办清单 (Todo List)”</strong>，我们一步一步来看它是怎么工作的。</p>
<hr />
<h3>📋 任务总览：生产与发布流水线</h3>
<p>这个流程主要分两个大阶段（Jobs）：
1.  <strong>制造与质检 (<code>build-and-test-wheels</code>)</strong>：造轮子，并测试好不好用。
2.  <strong>发货 (<code>publish-wheels</code>)</strong>：把造好的轮子上传到仓库。</p>
<hr />
<h3>第一阶段：准备工作 (Inputs &amp; Strategy)</h3>
<p>在开工之前，流水线先确认了一些“订单需求”：</p>
<ul>
<li><strong>Todo 1: 确认参数 (Inputs)</strong><ul>
<li><code>ref</code>: 用哪段代码？（默认是当前提交的代码）。</li>
<li><code>dry-run</code>: 是演习吗？（默认是 <code>true</code>，意思是只跑流程不正式发布）。</li>
<li><code>no-publish</code>: 是否禁止发布？（默认是 <code>true</code>，只打包不上传）。</li>
</ul>
</li>
<li><strong>Todo 2: 确定生产批次 (Matrix Strategy)</strong><ul>
<li>文件里的 <code>matrix</code> 部分定义了要同时开三条生产线：<ol>
<li>造 <code>megatron-core</code> 包，适配 ARM 架构（比如 Mac M1/M2 或手机芯片）。</li>
<li>造 <code>megatron-core</code> 包，适配 AMD64 架构（普通 Intel/AMD 电脑）。</li>
<li>造 <code>megatron-fsdp</code> 包，适配 AMD64 架构。</li>
</ol>
</li>
<li><em>通俗解释：为了保证不同电脑都能用，它要针对不同芯片分别打包。</em></li>
</ul>
</li>
</ul>
<hr />
<h3>第二阶段：制造与质检 (<code>build-and-test-wheels</code>)</h3>
<p>这是最复杂的部分，机器开始运转了：</p>
<ul>
<li>
<p><strong>Todo 3: 下载代码</strong></p>
<ul>
<li><code>Checkout repository</code>: 把 GitHub 上的代码拉取到服务器上。</li>
</ul>
</li>
<li>
<p><strong>Todo 4: 确定打包路径</strong></p>
<ul>
<li>脚本会根据包名 (<code>megatron-core</code> 或 <code>megatron-fsdp</code>)，找到代码所在的具体文件夹 (<code>ROOTDIR</code>)。</li>
</ul>
</li>
<li>
<p><strong>Todo 5: 处理版本号 (如果是演习)</strong></p>
<ul>
<li><strong>关键点</strong>：如果 <code>dry-run</code> 是 <code>true</code>（演习模式），脚本会修改版本号。</li>
<li>它会在版本号后面加一个 <code>.dev</code> 加上随机数（例如 <code>0.1.0.dev123456</code>）。</li>
<li><em>目的：防止测试版占用了正式版的版本号。</em></li>
</ul>
</li>
<li>
<p><strong>Todo 6: 启动 Docker 容器进行编译 (Build Wheel)</strong></p>
<ul>
<li>为了保证包在所有 Linux 上都能跑，它启动了一个标准的 Linux 环境 (<code>manylinux</code> 镜像)。</li>
<li><strong>循环编译</strong>：在这个容器里，它针对 Python 3.10, 3.11, 3.12, 3.13 依次运行 <code>build</code> 命令。</li>
<li><strong>修复轮子 (<code>auditwheel repair</code>)</strong>：这是 Python 打包的高级操作。它会把代码依赖的 C++ 库“塞进”安装包里，这样用户安装时就不需要自己配置环境了。</li>
</ul>
</li>
<li>
<p><strong>Todo 7: 记录版本号</strong></p>
<ul>
<li>把最终确定的版本号打印出来，记在小本本上 (<code>GITHUB_OUTPUT</code>)，方便后面核对。</li>
</ul>
</li>
<li>
<p><strong>Todo 8: 质检测试 (Test Wheels)</strong></p>
<ul>
<li><strong>安装</strong>：用 <code>pip install</code> 把刚才造好的包安装到当前环境。</li>
<li><strong>删源码</strong>：<code>sudo rm -rf megatron/</code>。<ul>
<li><em>为什么要删源码？</em> 这是一个防呆设计。为了确保测试的是<strong>安装好的包</strong>，而不是当前文件夹里的<strong>源代码</strong>。</li>
</ul>
</li>
<li><strong>核对</strong>：运行 Python 代码打印版本号，看是否和 Todo 7 里记录的一致。如果一致，说明包是好的。</li>
</ul>
</li>
<li>
<p><strong>Todo 9: 暂存成品 (Upload artifacts)</strong></p>
<ul>
<li>把造好并通过测试的 <code>.whl</code> 文件上传到 GitHub 的临时存储区，准备交给下一个阶段。</li>
</ul>
</li>
</ul>
<hr />
<h3>第三阶段：发货 (<code>publish-wheels</code>)</h3>
<p>如果前面的测试都通过了，而且 <code>no-publish</code> 是 <code>false</code>（允许发布），就会进入这个阶段。</p>
<ul>
<li>
<p><strong>Todo 10: 取货</strong></p>
<ul>
<li><code>Download wheels</code>: 从临时存储区把刚才那几条生产线造出来的包都下载下来，放在一起。</li>
</ul>
</li>
<li>
<p><strong>Todo 11: 确定发货地址</strong></p>
<ul>
<li>脚本会看当前的分支：<ul>
<li>如果是 <code>main</code> 分支或者发布分支 (<code>release</code>) -&gt; 发往 <strong>PyPI</strong> (正式仓库，大家都能用 <code>pip install</code> 下载)。</li>
<li>如果是其他分支 -&gt; 发往 <strong>TestPyPI</strong> (测试仓库，仅供内部测试)。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Todo 12: 正式上传</strong></p>
<ul>
<li>安装 <code>twine</code> 工具。</li>
<li>使用 <code>twine upload</code> 命令，配合密钥 (<code>TWINE_USERNAME/PASSWORD</code>)，把包推送到 PyPI 仓库。</li>
</ul>
</li>
</ul>
<hr />
<h3>💡 总结一下</h3>
<p>这个文件的逻辑就是：</p>
<ol>
<li><strong>你给我代码</strong>。</li>
<li><strong>我开三个分身</strong>（不同架构、不同包名）。</li>
<li><strong>如果是测试，我改个临时名字</strong>。</li>
<li><strong>我在标准环境里打包、修复依赖</strong>。</li>
<li><strong>我安装试一下，确保能用</strong>。</li>
<li><strong>最后，如果允许发布，我就把它上传到 PyPI 商店</strong>。</li>
</ol>