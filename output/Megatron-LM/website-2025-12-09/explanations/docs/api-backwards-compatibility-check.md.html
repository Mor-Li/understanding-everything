<h1>docs/api-backwards-compatibility-check.md</h1>
<p>这份文档其实是 Megatron Core 项目的一个<strong>“代码交规手册”</strong>。</p>
<p>简单来说，它的核心目的是：<strong>防止你写的代码改动让原来的用户跑不起来（即“向后兼容性检查”）</strong>。</p>
<p>为了让你更容易理解，我把它拆解成一个<strong>开发者视角的 Todo List（任务清单）</strong>，带你一步步通关。</p>
<hr />
<h3>第一阶段：理解规则（这是个啥？）</h3>
<p><strong>Task 1：理解“不兼容变更”（Breaking Change）</strong>
想象你给用户提供了一个函数 <code>train(x)</code>。用户写了代码调用它。
*   ❌ <strong>禁止的操作</strong>：你突然把它改成了 <code>train(x, y)</code>（y 是必填的）。
    *   <em>后果</em>：用户原来的代码 <code>train(x)</code> 会直接报错“缺少参数 y”。这就是“破坏了兼容性”。
*   ❌ <strong>禁止的操作</strong>：你直接删掉了 <code>train</code> 函数。
*   ✅ <strong>允许的操作</strong>：你把它改成 <code>train(x, y=0)</code>（y 有默认值）。
    *   <em>后果</em>：用户原来的代码 <code>train(x)</code> 还能跑，因为 y 会自动等于 0。</p>
<p><strong>Task 2：认识“检查机器人”</strong>
文档里提到的 <code>check_api_backwards_compatibility.py</code> 就是一个自动检查机器人。
*   它会在你提交代码（PR）时，自动对比<strong>你的代码</strong>和<strong>上一个正式版本</strong>。
*   如果发现你做了上面的“禁止操作”，它就会让测试失败（CI Fail），不让你合并代码。</p>
<hr />
<h3>第二阶段：日常开发（我该怎么做？）</h3>
<p><strong>Task 3：写代码时的自我检查</strong>
当你修改 <code>megatron/core</code> 目录下的公共函数时，对照以下清单：
*   [ ] 我是否删除了某个参数？（❌ 不行）
*   [ ] 我是否新增了一个<strong>没有默认值</strong>的参数？（❌ 不行）
*   [ ] 我是否改变了参数的顺序？（❌ 不行）
*   [ ] 我是否删除了一个函数？（❌ 不行）
*   [ ] 我是否只是加了一个带默认值的参数（如 <code>new_arg=None</code>）？（✅ 可以）</p>
<p><strong>Task 4：在本地运行检查（可选）</strong>
如果你不确定自己的改动是否违规，可以在本地先跑一下检查命令，不用等推送到服务器才知道：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 只要这一行，它就会告诉你有没有违规</span>
python<span class="w"> </span>scripts/check_api_backwards_compatibility.py<span class="w"> </span>--baseline<span class="w"> </span>core_r0.8.0
</code></pre></div>

<hr />
<h3>第三阶段：解决问题（报错了咋办？）</h3>
<p>如果你的代码被机器人拦截了（CI 报错），你需要根据情况选择下面的解决方案：</p>
<p><strong>情况 A：我确实不小心改坏了</strong>
*   <strong>Action</strong>：把代码改回去。比如给新增的参数加上默认值。</p>
<p><strong>情况 B：我写的这个函数是内部用的，不给用户用</strong>
*   <strong>Action</strong>：给函数贴个标签（装饰器）。
    *   告诉机器人：“别查这个函数，这是我内部用的。”
    *   <strong>代码怎么写</strong>：
        ```python
        from megatron.core.utils import internal_api</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nv">@internal_api</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="o">&lt;</span><span class="c1">--- 加上这一行，机器人就会忽略它</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">my_internal_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">pass</span>
<span class="w">    </span><span class="err">```</span>
</code></pre></div>

<p><strong>情况 C：我写的是个实验性功能，还没定型</strong>
*   <strong>Action</strong>：给函数贴个“实验性”标签。
    *   <strong>代码怎么写</strong>：
        ```python
        from megatron.core.utils import experimental_api</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nv">@experimental_api</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="o">&lt;</span><span class="c1">--- 加上这一行，机器人也会放过它</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">new_cool_feature</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">pass</span>
<span class="w">    </span><span class="err">```</span>
</code></pre></div>

<p><strong>情况 D：这个旧函数太烂了，我必须改掉它</strong>
*   <strong>Action</strong>：不能直接删！要走“废弃流程”（Deprecation）。
    *   这就好比拆迁要先贴告示，不能直接推土机进场。
    *   <strong>代码怎么写</strong>：
        ```python
        from megatron.core.backwards_compatibility_decorators import deprecated</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nv">@deprecated</span><span class="p">(</span><span class="n">version</span><span class="o">=</span><span class="ss">&quot;1.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">removal_version</span><span class="o">=</span><span class="ss">&quot;2.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">alternative</span><span class="o">=</span><span class="ss">&quot;new_func&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">old_bad_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">pass</span>
<span class="w">    </span><span class="err">```</span>
<span class="o">*</span><span class="w">   </span><span class="n">这样机器人知道你是有计划的废弃</span><span class="err">，</span><span class="n">就会让你通过</span><span class="err">。</span>
</code></pre></div>

<hr />
<h3>总结</h3>
<p>这份文档其实就讲了三件事：
1.  <strong>红线</strong>：别随意改动函数签名导致用户代码报错。
2.  <strong>工具</strong>：有一个脚本会自动查这个事。
3.  <strong>后门</strong>：如果你非要改，请使用 <code>@internal_api</code>（内部用）、<code>@experimental_api</code>（实验用）或者 <code>@deprecated</code>（预告废弃）来告诉机器人放行。</p>