<h1>tests/unit_tests/dist_checkpointing/test_safe_globals.py</h1>
<p>这段代码看起来有点抽象，是因为它在测试 PyTorch 一个比较新的<strong>安全机制</strong>。</p>
<p>简单来说，这段代码是为了验证：<strong>“在加载模型文件时，如何防止恶意的或者未知的代码被执行。”</strong></p>
<p>为了让你彻底看懂，我把这个任务拆解成 <strong>5 个待办事项 (ToDo List)</strong>，我们一步步来打勾完成。</p>
<hr />
<h3>📋 任务清单：一步步读懂代码</h3>
<h4>✅ 任务 1：理解背景知识（为什么会有这个测试？）</h4>
<p>在 Python 和 PyTorch 中，保存和加载文件（<code>torch.save</code> / <code>torch.load</code>）通常使用一个叫 <code>pickle</code> 的工具。
*   <strong>问题：</strong> <code>pickle</code> 很强大，但很不安全。如果黑客给你一个模型文件，里面包含恶意代码，你一 <code>load</code>，电脑可能就被黑了。
*   <strong>新机制：</strong> PyTorch（特别是 2.6 版本以后）引入了一种“白名单”机制。只有被认为是“安全”的类（比如官方的 Tensor、List、Dict）才允许直接加载。如果你自己写了一个类（Custom Class），默认会被拦截，报错。</p>
<h4>✅ 任务 2：看懂 <code>UnsafeClass</code> 是个啥</h4>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">UnsafeClass</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="o">...</span>
</code></pre></div>

<ul>
<li><strong>解读：</strong> 这就是一个最普通的自定义 Python 类。</li>
<li><strong>作用：</strong> 在这个测试里，它扮演“<strong>陌生人</strong>”的角色。它不是 PyTorch 官方自带的类，所以 PyTorch 的安全机制默认不认识它，会把它当成潜在的威胁。</li>
</ul>
<h4>✅ 任务 3：分析第一个测试 <code>test_safe_globals</code></h4>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_safe_globals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmp_path_dist_ckpt</span><span class="p">):</span>
    <span class="c1"># ...省略保存代码...</span>
    <span class="n">dummy_obj</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">(</span><span class="n">dummy_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 这是一个 Python 标准库的类</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dummy_obj</span><span class="p">,</span> <span class="n">ckpt_path</span><span class="p">)</span>

    <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ckpt_path</span><span class="p">)</span> <span class="c1"># 直接加载</span>
</code></pre></div>

<ul>
<li><strong>解读：</strong><ol>
<li>代码创建了一个 <code>Namespace</code> 对象（这是 Python <code>argparse</code> 库里的标准类，属于“熟人”）。</li>
<li>保存它，然后加载它。</li>
<li><strong>结果：</strong> 没有任何报错。</li>
</ol>
</li>
<li><strong>结论：</strong> 证明对于“熟人”（标准库或 PyTorch 内部类），安全机制是放行的。</li>
</ul>
<h4>✅ 任务 4：分析第二个测试 <code>test_unsafe_globals</code>（核心部分）</h4>
<p>这个测试分两个阶段，专门针对 PyTorch 2.6+ 版本。</p>
<p><strong>阶段 A：尝试加载“陌生人”，预期会报错</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 1. 创建并保存一个 UnsafeClass (陌生人)</span>
<span class="n">dummy_obj</span> <span class="o">=</span> <span class="n">UnsafeClass</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dummy_obj</span><span class="p">,</span> <span class="n">ckpt_path</span><span class="p">)</span>

<span class="c1"># 2. 尝试加载，并断言(expect)会抛出 UnpicklingError 错误</span>
<span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="n">UnpicklingError</span><span class="p">):</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ckpt_path</span><span class="p">)</span>
</code></pre></div>

<ul>
<li><strong>解读：</strong><ul>
<li>这里保存了 <code>UnsafeClass</code>。</li>
<li>当 <code>torch.load</code> 试图读取时，发现这是个不认识的自定义类，于是触发安全拦截，抛出 <code>UnpicklingError</code>（解包错误）。</li>
<li><code>pytest.raises</code> 的意思是：“如果这里报错了，测试就算通过；如果不报错，测试反而失败”。这证明了安全拦截生效了。</li>
</ul>
</li>
</ul>
<p><strong>阶段 B：把“陌生人”加入“白名单”，再次加载</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 3. 给 UnsafeClass 发一张“通行证” (加入安全全局列表)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">serialization</span><span class="o">.</span><span class="n">add_safe_globals</span><span class="p">([</span><span class="n">UnsafeClass</span><span class="p">])</span>

<span class="c1"># 4. 再次加载，这次应该成功</span>
<span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ckpt_path</span><span class="p">)</span>
</code></pre></div>

<ul>
<li><strong>解读：</strong><ul>
<li><code>add_safe_globals([UnsafeClass])</code>：这行代码告诉 PyTorch，“<code>UnsafeClass</code> 是我写的，它是安全的，请放行”。</li>
<li>再次 <code>load</code>，因为有了通行证，所以成功加载，不再报错。</li>
</ul>
</li>
</ul>
<h4>✅ 任务 5：总结全篇观点</h4>
<p>这段代码主要讲了三件事：
1.  <strong>默认安全：</strong> 标准类（如 <code>Namespace</code>）可以直接加载。
2.  <strong>默认拦截：</strong> 未知的自定义类（如 <code>UnsafeClass</code>）在 PyTorch 新版本中默认会被拦截（报错），以防止安全风险。
3.  <strong>手动放行：</strong> 开发者可以通过 <code>add_safe_globals</code> 显式地把自定义类加入白名单，从而正常加载。</p>
<hr />
<h3>💡 一句话总结</h3>
<p>这个文件是在测试 PyTorch 的<strong>反序列化安全白名单功能</strong>：<strong>既要拦住未知的坏人（报错），又要能给好人发通行证（add_safe_globals）。</strong></p>