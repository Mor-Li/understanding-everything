<h1>tests/functional_tests/python_test_utils/conftest.py</h1>
<p>这份代码看起来很吓人，但其实它的核心逻辑非常简单。它不是在“做测试”，而是在<strong>为测试做准备</strong>。</p>
<p>你可以把这个文件看作是一个<strong>“后勤部长”</strong>。它的工作是：从命令行接收命令，把需要的数据（文件路径、配置、标准答案）准备好，然后递给真正执行测试的代码。</p>
<p>为了让你更容易理解，我把你理解这份代码的过程拆解成一个 <strong>TODO List（任务清单）</strong>，我们可以一步步勾选来学习。</p>
<hr />
<h3>📋 学习任务清单 (Todo List)</h3>
<ol>
<li><strong>任务一：理解背景</strong> —— 搞清楚这个文件在测试系统里的角色。</li>
<li><strong>任务二：定义“暗号”</strong> —— 学习代码是如何定义命令行参数的（怎么告诉测试代码去哪里找文件）。</li>
<li><strong>任务三：理解“快递员” (Fixture)</strong> —— 学习 <code>pytest</code> 最核心的概念，它是怎么把数据“送”进测试函数的。</li>
<li><strong>任务四：区分“标准答案”与“考生试卷”</strong> —— 理解 Golden Values 和 Actual Values 的逻辑。</li>
<li><strong>任务五：处理“成绩单”</strong> —— 理解它是如何处理 TensorBoard 数据的。</li>
</ol>
<hr />
<h3>🚀 逐步讲解</h3>
<h4>✅ 任务一：理解背景</h4>
<p>这个文件 <code>conftest.py</code> 是 Python 测试框架 <strong>pytest</strong> 的专用配置文件。
*   <strong>规则</strong>：只要文件名叫 <code>conftest.py</code>，pytest 就会自动运行它。
*   <strong>作用</strong>：它用来定义所有测试通用的“设置”和“工具”。
*   <strong>场景</strong>：这是一个机器学习（ML）项目的测试。因为代码里提到了 <code>TensorBoard</code>（看训练曲线的）、<code>train-iters</code>（训练步数）、<code>model_config</code>（模型配置）。</p>
<hr />
<h4>✅ 任务二：定义“暗号” (CLI Arguments)</h4>
<p>测试脚本运行的时候，我们需要告诉它很多信息，比如：“标准答案在哪里？”、“这次训练跑多少步？”。</p>
<p>代码中的 <code>pytest_addoption</code> 函数就是用来定义这些“暗号”（命令行参数）的。</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">pytest_addoption</span><span class="p">(</span><span class="n">parser</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">addoption</span><span class="p">(</span><span class="s2">&quot;--golden-values-path&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Path to golden values&quot;</span><span class="p">)</span>
    <span class="c1"># ...</span>
</code></pre></div>

<p><strong>发生了什么：</strong>
*   它告诉 pytest，如果用户在命令行输入 <code>pytest --golden-values-path=/tmp/answer.json</code>，请把这个路径存下来。
*   <strong>你的理解重点</strong>：这一大段 <code>parser.addoption</code> 只是在<strong>注册</strong>这些选项，让 pytest 认识它们。</p>
<p><strong>清单里的选项含义：</strong>
*   <code>--allow-nondeterministic-algo</code>: 是否允许结果有一点点误差（近似匹配）。
*   <code>--golden-values-path</code>: <strong>标准答案</strong>（以前跑通过的、正确的数据）的文件路径。
*   <code>--actual-values-path</code>: <strong>当前结果</strong>（刚才代码跑出来的）的文件路径。
*   <code>--train-iters</code>: 训练循环了多少次。
*   <code>--tensorboard-path</code>: 训练日志放在哪。</p>
<hr />
<h4>✅ 任务三：理解“快递员” (Fixture)</h4>
<p>这是整份代码最核心的概念：<strong><code>@pytest.fixture</code></strong>。</p>
<p>在 pytest 里，fixture 就像一个<strong>快递员</strong>。
1.  测试函数不需要知道怎么去读文件、解析 JSON。
2.  测试函数只需要喊一声：“我要 <code>golden_values</code>！”
3.  fixture 就会自动运行，把处理好的数据送过去。</p>
<p><strong>看这个例子：</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">golden_values_path</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple fixture returning golden values.&quot;&quot;&quot;</span>
    <span class="c1"># request.config.getoption 就是去读取刚才任务二里注册的命令行参数</span>
    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&quot;--golden-values-path&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>翻译：</strong>
*   当有测试函数需要 <code>golden_values_path</code> 时，这个函数就会运行。
*   它从配置里拿出用户输入的路径，然后返回给测试函数。</p>
<hr />
<h4>✅ 任务四：区分“标准答案”与“考生试卷”</h4>
<p>在功能测试（Functional Tests）中，最常见的逻辑是：<strong>对比</strong>。
我们需要对比“现在的代码跑出来的结果”和“以前确认正确的标准结果”。</p>
<p><strong>1. 获取标准答案 (Golden Values):</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">golden_values</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># common 是上面导入的一个工具库</span>
    <span class="c1"># 它做的事情是：拿到路径 -&gt; 打开文件 -&gt; 读取JSON -&gt; 返回字典</span>
    <span class="k">return</span> <span class="n">common</span><span class="o">.</span><span class="n">read_golden_values_from_json</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&quot;--golden-values-path&quot;</span><span class="p">))</span>
</code></pre></div>

<ul>
<li><strong>逻辑</strong>：这是“阅卷老师”手里的<strong>标准答案</strong>。</li>
</ul>
<p><strong>2. 获取当前结果 (Actual Values):</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">actual_values</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">common</span><span class="o">.</span><span class="n">read_golden_values_from_json</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&quot;--actual-values-path&quot;</span><span class="p">))</span>
</code></pre></div>

<ul>
<li><strong>逻辑</strong>：这是“考生”（你的代码）刚刚交上来的<strong>试卷</strong>。</li>
</ul>
<p><strong>测试的逻辑（虽然不在这个文件里，但你可以想象）：</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 真正的测试函数可能会这样写：</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_accuracy</span><span class="p">(</span><span class="n">golden_values</span><span class="p">,</span> <span class="n">actual_values</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">actual_values</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">golden_values</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">]</span>
</code></pre></div>

<p>你看，因为有了 <code>conftest.py</code> 里的 fixture，测试函数直接用这两个变量就行了，不用管文件是怎么读取的。</p>
<hr />
<h4>✅ 任务五：处理“成绩单” (TensorBoard)</h4>
<p>机器学习训练通常会生成 TensorBoard 日志（记录 Loss 变化、Accuracy 变化等）。</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">tensorboard_logs</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">train_iters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple fixture returning tensorboard metrics.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">common</span><span class="o">.</span><span class="n">read_tb_logs_as_list</span><span class="p">(</span>
        <span class="n">request</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&quot;--tensorboard-path&quot;</span><span class="p">),</span> <span class="n">train_iters</span><span class="o">=</span><span class="n">train_iters</span>
    <span class="p">)</span>
</code></pre></div>

<p><strong>这里有个细节：</strong>
*   注意参数里有 <code>train_iters</code>。
*   <strong>Fixture 可以调用其他 Fixture！</strong>
*   流程：
    1.  pytest 发现需要 <code>tensorboard_logs</code>。
    2.  它发现 <code>tensorboard_logs</code> 需要 <code>train_iters</code>。
    3.  它先去运行 <code>train_iters</code> 这个 fixture（从命令行读取数字，比如 100）。
    4.  然后把 100 传给 <code>tensorboard_logs</code>。
    5.  最后调用 <code>common.read_tb_logs_as_list</code> 去读取日志文件。</p>
<hr />
<h3>💡 总结：这个文件到底讲了啥？</h3>
<p>如果把整个测试过程比作一场<strong>烹饪比赛</strong>：</p>
<ol>
<li><strong><code>pytest_addoption</code></strong> 是<strong>菜单</strong>：规定了我们可以点什么菜（指定哪些文件路径、什么参数）。</li>
<li><strong><code>@pytest.fixture</code></strong> 是<strong>备菜员</strong>：<ul>
<li>厨师（测试函数）不需要自己去买菜、洗菜。</li>
<li>厨师只要喊一声“给我牛肉（<code>golden_values</code>）”，备菜员（Fixture）就会去冰箱（文件路径）里拿出来，切好（解析JSON），直接递到厨师手里。</li>
</ul>
</li>
</ol>
<p><strong>一句话概括：</strong>
这个文件定义了一堆<strong>助手函数</strong>，专门负责从命令行读取文件路径，并把文件内容加载成 Python 对象，方便后续的测试代码直接使用这些数据进行对比。</p>