<h1>tests/test_utils/python_scripts/generate_local_jobs.py</h1>
<p>这份代码其实是一个<strong>“脚本生成器”</strong>。</p>
<p>简单来说，它的作用不是直接运行测试，而是<strong>帮你写好运行测试所需的 Shell (<code>.sh</code>) 脚本</strong>。</p>
<p>想象一下，你有一堆复杂的测试命令要敲，而且每次都要改一些参数（比如模型名字、输出路径）。这个 Python 脚本就像一个秘书，你告诉它：“我要测 Llama 模型，环境是 dev”，它就会自动给你生成一个可以直接运行的 <code>.sh</code> 文件，里面把所有的环境变量和命令都填好了。</p>
<p>为了让你更容易理解，我把你当作这个程序，给你列一个 <strong>Task To-Do List（任务清单）</strong>。程序运行的过程，就是按顺序执行下面这些任务：</p>
<hr />
<h3>📋 程序的任务清单 (To-Do List)</h3>
<ol>
<li><strong>[接收指令]</strong>：听取用户在命令行输入的参数（比如要测哪个模型？结果存哪？）。</li>
<li><strong>[获取菜单]</strong>：调用后台工具，把所有符合要求的测试任务（Workloads）找出来。</li>
<li><strong>[循环处理]</strong>：对每一个找到的测试任务，做以下事情：<ul>
<li><strong>[过滤]</strong>：如果是“构建(build)”类型的任务，直接跳过，只处理“运行”任务。</li>
<li><strong>[准备填空]</strong>：准备好要填入脚本的变量（比如输出路径、任务名字）。</li>
<li><strong>[创建文件]</strong>：在硬盘上创建一个 <code>.sh</code> 文件（路径通常是 <code>test_cases/模型名/测试名.sh</code>）。</li>
<li><strong>[写入内容]</strong>：<ul>
<li>写入 <code>export</code> 环境变量（设置模式、路径）。</li>
<li>写入具体的测试运行命令（把变量填进模板里）。</li>
<li>写入一句提示（告诉用户结果存在哪）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr />
<h3>🔍 逐步代码详解</h3>
<p>现在我们结合代码，一步步看它是怎么完成上面这个清单的。</p>
<h4>第一步：接收指令 (CLI Arguments)</h4>
<p>代码用了 <code>click</code> 库来处理命令行参数。这就是“秘书”在拿小本本记你的要求。</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@click</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;--model&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>       <span class="c1"># 你想测哪个模型？(如 gpt3, llama)</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;--scope&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>       <span class="c1"># 测试范围是什么？(默认是 mr，即合并请求测试)</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;--environment&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="c1"># 必须填：环境是 lts 还是 dev？</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;--output-path&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="c1"># 必须填：测试日志存哪？</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;--enable-lightweight-mode&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="c1"># 开关：是否开启轻量模式（只跑两步烟雾测试）？</span>
<span class="c1"># ... 其他参数</span>
<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
</code></pre></div>

<ul>
<li><strong>观点</strong>：这一段定义了脚本的<strong>入口</strong>和<strong>配置项</strong>。</li>
</ul>
<h4>第二步：获取菜单 (Load Workloads)</h4>
<p>拿到你的要求后，它去查找具体的测试配置。</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">workloads</span> <span class="o">=</span> <span class="n">recipe_parser</span><span class="o">.</span><span class="n">load_workloads</span><span class="p">(</span>
        <span class="n">container_image</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
        <span class="n">scope</span><span class="o">=</span><span class="n">scope</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">test_case</span><span class="o">=</span><span class="n">test_case</span><span class="p">,</span>
        <span class="n">environment</span><span class="o">=</span><span class="n">environment</span><span class="p">,</span>
        <span class="n">container_tag</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div>

<ul>
<li><strong>观点</strong>：<code>recipe_parser</code> 是外部工具（虽然这文件里没写细节），它负责去读取配置文件（可能是 YAML），返回一个任务列表 <code>workloads</code>。</li>
</ul>
<h4>第三步：循环处理与准备填空 (Loop &amp; Prepare Variables)</h4>
<p>它开始遍历每一个任务，并准备把“模板”变成“实际命令”。</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">for</span> <span class="n">workload</span> <span class="ow">in</span> <span class="n">workloads</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">workload</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;build&quot;</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># 我们只生成运行脚本，不需要构建脚本，跳过</span>

        <span class="c1"># magic_values 就是一个字典，用来做“填空题”</span>
        <span class="n">magic_values</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">workload</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">magic_values</span><span class="p">[</span><span class="s2">&quot;assets_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;$OUTPUT_PATH&quot;</span> <span class="c1"># 告诉脚本资源在哪</span>
        <span class="n">magic_values</span><span class="p">[</span><span class="s2">&quot;environment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">environment</span>
        <span class="c1"># ... 格式化名字等</span>
</code></pre></div>

<ul>
<li><strong>观点</strong>：这里在做<strong>字符串格式化的准备工作</strong>。原始的测试命令里可能有很多 <code>{assets_dir}</code> 这种占位符，这里把它们替换成实际的变量名。</li>
</ul>
<h4>第四步：创建文件与写入内容 (File Creation &amp; Writing)</h4>
<p>这是最核心的一步，它把生成好的内容写到硬盘上。</p>
<div class="codehilite"><pre><span></span><code>        <span class="c1"># 1. 确定文件保存路径：当前目录/test_cases/模型名/测试名.sh</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span>
            <span class="o">/</span> <span class="s2">&quot;test_cases&quot;</span>
            <span class="o">/</span> <span class="n">workload</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">]</span>
            <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">workload</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="s1">&#39;test_case&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">.sh&quot;</span>
        <span class="p">)</span>
        <span class="n">file_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># 确保文件夹存在</span>

        <span class="c1"># 2. 打开文件开始写</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="c1"># 写环境变量开关</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;export ENABLE_LIGHTWEIGHT_MODE=</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">enable_lightweight_mode</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># 写输出路径，还贴心地加了个随机UUID，防止覆盖以前的结果</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;export OUTPUT_PATH=</span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s1">/runs/$(python3 -c &quot;import uuid; print(uuid.uuid4())&quot;)</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">)</span>

            <span class="c1"># 【核心】写入具体的测试命令</span>
            <span class="c1"># .format(**magic_values) 就是把刚才准备的变量填进命令模板里</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">workload</span><span class="o">.</span><span class="n">spec</span><span class="p">[</span><span class="s2">&quot;script&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">magic_values</span><span class="p">))</span>

            <span class="c1"># 写结尾提示</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">echo This test wrote results into $OUTPUT_PATH</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<ul>
<li><strong>观点</strong>：<ul>
<li>它生成的不是 Python 代码，而是 <strong>Shell (Bash) 脚本</strong>。</li>
<li>它利用 Python 的字符串格式化功能，把复杂的参数配置“硬编码”进了一个简单的 <code>.sh</code> 文件里。</li>
<li>这样用户如果不满意，还可以手动去改生成的 <code>.sh</code> 文件，非常灵活。</li>
</ul>
</li>
</ul>
<hr />
<h3>💡 总结</h3>
<p><strong>这个文件的核心观点是：</strong>
不要让用户手动敲几十行复杂的 Docker 或 Slurm 运行命令。用 Python 根据配置自动生成这些命令，并保存在 <code>.sh</code> 文件中，方便用户在本地容器里一键运行。</p>
<p><strong>举个例子：</strong>
如果你运行：
<code>python generate_local_jobs.py --model gpt3 --environment dev --output-path /tmp/logs</code></p>
<p>它可能会在 <code>test_cases/gpt3/</code> 目录下生成一个 <code>test_gpt3_pretrain.sh</code>，内容大概是：</p>
<div class="codehilite"><pre><span></span><code><span class="nb">export</span><span class="w"> </span><span class="nv">ENABLE_LIGHTWEIGHT_MODE</span><span class="o">=</span><span class="nb">false</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">OUTPUT_PATH</span><span class="o">=</span>/tmp/logs/runs/随机ID
python<span class="w"> </span>pretrain_gpt.py<span class="w"> </span>--layers<span class="w"> </span><span class="m">12</span><span class="w"> </span>--hidden-size<span class="w"> </span><span class="m">768</span><span class="w"> </span>...<span class="w"> </span><span class="o">(</span>一大堆参数<span class="o">)</span>
<span class="nb">echo</span><span class="w"> </span>This<span class="w"> </span><span class="nb">test</span><span class="w"> </span>wrote<span class="w"> </span>results<span class="w"> </span>into<span class="w"> </span><span class="nv">$OUTPUT_PATH</span>
</code></pre></div>