<h1>tests/test_utils/recipes/bert.yaml</h1>
<p>这份文件其实是一份<strong>自动化测试的“食谱”（Recipe）</strong>。</p>
<p>想象你是一个负责测试 AI 模型（BERT）的“机器人管理员”。这份 YAML 文件就是写给你的<strong>任务清单</strong>。它告诉你在什么样的机器上、用什么样的代码、跑什么样的测试，最后输出什么结果。</p>
<p>为了让你更容易理解，我把你（机器人）需要执行的工作拆解成一个 <strong>To-Do List（待办事项清单）</strong>，我们一步一步来看。</p>
<hr />
<h3>🤖 任务清单：BERT 模型自动化测试流程</h3>
<h4>✅ Task 1: 申请硬件资源 (Spec - Hardware)</h4>
<p><strong>目标：</strong> 在开始干活前，先搞定场地和设备。
*   <strong>原文对应：</strong> <code>spec</code> 下面的 <code>nodes</code>, <code>gpus</code>, <code>platforms</code>。
*   <strong>具体动作：</strong>
    1.  我要申请 <strong>1 台服务器节点</strong> (<code>nodes: 1</code>)。
    2.  这台机器必须配有 <strong>8 张显卡</strong> (<code>gpus: 8</code>)。
    3.  机器型号要是 <strong>DGX A100</strong> (<code>platforms: dgx_a100</code>)。
    4.  测试的模型名字叫 <strong>bert</strong>。</p>
<h4>✅ Task 2: 准备“食材”——下载代码 (Spec - Script Setup)</h4>
<p><strong>目标：</strong> 机器有了，现在要把需要测试的代码下载下来。这里比较特殊，它下载了两份代码做对比或兼容。
*   <strong>原文对应：</strong> <code>script_setup</code> 部分的 shell 命令。
*   <strong>具体动作：</strong>
    1.  <strong>登录系统：</strong> 配置网络代理，登录 NVIDIA 的内部 GitLab (<code>machine gitlab-master...</code>)。
    2.  <strong>下载最新代码 (Current)：</strong>
        *   进入 <code>/opt</code> 目录，创建一个叫 <code>megatron-lm</code> 的文件夹。
        *   从仓库 (<code>$MCORE_REPO</code>) 下载当前正在开发的最新代码（也就是本次要测试的代码 <code>$MCORE_MR_COMMIT</code>）。
    3.  <strong>下载旧代码 (Legacy/Backwards)：</strong>
        *   再创建一个叫 <code>megatron-lm-legacy</code> 的文件夹。
        *   下载之前的稳定版本代码 (<code>$MCORE_BACKWARDS_COMMIT</code>)。
        *   <em>注意：</em> 最后有一句 <code>cp -a ...</code>，它是把新代码里的 <code>megatron</code> 核心库复制到了旧代码文件夹里。这通常是为了测试新旧代码混合运行时的兼容性。</p>
<h4>✅ Task 3: 配置“烹饪参数” (Spec - Script)</h4>
<p><strong>目标：</strong> 代码下好了，在运行之前，要设置好各种路径和环境变量，就像做饭前把油盐酱醋摆好。
*   <strong>原文对应：</strong> <code>script</code> 部分的前半段变量定义 (<code>ARGUMENTS=...</code>)。
*   <strong>具体动作：</strong>
    1.  <strong>设置数据路径：</strong> 告诉程序去 <code>/mnt/artifacts</code> 找训练数据。
    2.  <strong>设置输出路径：</strong> 告诉程序把日志、TensorBoard 监控数据放在 <code>{assets_dir}</code>。
    3.  <strong>指定训练脚本：</strong> 这次要跑的是 <code>pretrain_bert.py</code>（BERT 预训练）。
    4.  <strong>指定“标准答案” (Golden Values)：</strong> 这一点很重要。<code>GOLDEN_VALUES_PATH</code> 指向一个 JSON 文件。测试跑完后，机器人会把结果和这个“金标准”对比，看看损失函数（Loss）是不是一样，如果不一样，测试就挂了。</p>
<h4>✅ Task 4: 开始“跑步” (Spec - Script Execution)</h4>
<p><strong>目标：</strong> 一切就绪，按下启动按钮。
*   <strong>原文对应：</strong> <code>bash ./tests/functional_tests/shell_test_utils/run_ci_test.sh ...</code>
*   <strong>具体动作：</strong>
    *   运行 <code>run_ci_test.sh</code> 这个脚本，并把上面 Task 3 里定义的参数全部传进去。这就真正开始跑模型训练了。</p>
<h4>✅ Task 5: 制定“菜单”——具体要测哪些场景 (Products)</h4>
<p><strong>目标：</strong> 上面的 Task 1-4 是通用模板。Task 5 则是告诉机器人：“用这个模板，给我做几道不同的菜”。
*   <strong>原文对应：</strong> <code>products</code> 下面的列表。
*   <strong>具体动作：</strong>
    这里列出了多个具体的测试案例（Test Cases），每一个都会触发一次上面的流程，但参数略有不同：</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w">  </span><span class="o">**</span><span class="n">菜品</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n n-Quoted">`bert_mcore_tp2_pp2`</span><span class="o">**</span>
<span class="w">    </span><span class="o">*</span><span class="w">   </span><span class="o">**</span><span class="n">含义：</span><span class="o">**</span><span class="w"> </span><span class="n">测试</span><span class="w"> </span><span class="n">BERT</span><span class="w"> </span><span class="n">模型，使用</span><span class="w"> </span><span class="o">**</span><span class="n">TP2</span><span class="o">**</span><span class="w"> </span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">Parallel</span><span class="o">=</span><span class="n">2，张量并行切</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">份</span><span class="p">)</span><span class="w"> </span><span class="n">和</span><span class="w"> </span><span class="o">**</span><span class="n">PP2</span><span class="o">**</span><span class="w"> </span><span class="p">(</span><span class="n">Pipeline</span><span class="w"> </span><span class="n">Parallel</span><span class="o">=</span><span class="n">2，流水线并行切</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">份</span><span class="p">)</span><span class="n">。</span>
<span class="w">    </span><span class="o">*</span><span class="w">   </span><span class="o">**</span><span class="n">环境：</span><span class="o">**</span><span class="w"> </span><span class="n">开发环境</span><span class="w"> </span><span class="p">(</span><span class="n n-Quoted">`dev`</span><span class="p">)</span><span class="n">，针对代码合并请求</span><span class="w"> </span><span class="p">(</span><span class="n n-Quoted">`mr`</span><span class="p">)</span><span class="n">。</span>
<span class="w">    </span><span class="o">*</span><span class="w">   </span><span class="o">**</span><span class="n">硬件：</span><span class="o">**</span><span class="w"> </span><span class="n">这里的平台变成了</span><span class="w"> </span><span class="n n-Quoted">`dgx_h100`</span><span class="n">（比</span><span class="w"> </span><span class="n">A100</span><span class="w"> </span><span class="n">更强）。</span>

<span class="mf">2.</span><span class="w">  </span><span class="o">**</span><span class="n">菜品</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n n-Quoted">`bert_mcore_tp1_pp2`</span><span class="o">**</span>
<span class="w">    </span><span class="o">*</span><span class="w">   </span><span class="o">**</span><span class="n">含义：</span><span class="o">**</span><span class="w"> </span><span class="n">TP</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">不切张量</span><span class="p">)</span><span class="n">，PP</span><span class="o">=</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">流水线切</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">份</span><span class="p">)</span><span class="n">。</span>
<span class="w">    </span><span class="o">*</span><span class="w">   </span><span class="o">**</span><span class="n">范围：</span><span class="o">**</span><span class="w"> </span><span class="n n-Quoted">`nightly`</span><span class="w"> </span><span class="p">(</span><span class="n">每晚自动跑的测试，而不是每次提交代码都跑</span><span class="p">)</span><span class="n">。</span>

<span class="mf">3.</span><span class="w">  </span><span class="o">**</span><span class="n">其他菜品：</span><span class="o">**</span><span class="w"> </span><span class="n">还有</span><span class="w"> </span><span class="n n-Quoted">`vp2`</span><span class="w"> </span><span class="p">(</span><span class="n">虚拟流水线</span><span class="p">),</span><span class="w"> </span><span class="n n-Quoted">`resume_torch_dist`</span><span class="w"> </span><span class="p">(</span><span class="n">测试断点续训</span><span class="p">)</span><span class="w"> </span><span class="n">等各种变体。</span>
</code></pre></div>

<hr />
<h3>总结一下</h3>
<p><strong>这个文件的核心逻辑是：</strong></p>
<ol>
<li><strong><code>spec</code> (模具)：</strong> 定义了一套通用的测试方法——“找台 8 卡机器，下好代码，跑 <code>pretrain_bert.py</code>，并对比结果”。</li>
<li><strong><code>products</code> (产品列表)：</strong> 利用上面的模具，生产出各种不同配置的测试任务（比如切分并行度不同、硬件不同）。</li>
</ol>
<p>如果你是开发者，当你提交了代码，系统就会读取这个文件，按照 <code>products</code> 里的列表，启动好几个任务，去验证你的代码在各种并行策略（TP/PP）下是否都能正常训练 BERT 模型。</p>