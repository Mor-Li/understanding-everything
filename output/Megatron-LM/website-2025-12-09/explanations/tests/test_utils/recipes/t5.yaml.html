<h1>tests/test_utils/recipes/t5.yaml</h1>
<p>这份文件其实是一份<strong>自动化测试的“施工单”</strong>（Recipe）。</p>
<p>你可以把它想象成<strong>项目经理（你）</strong> 写给 <strong>测试员（计算机/CI系统）</strong> 的一张 To-Do List。目的是告诉测试员：<strong>“去帮我测一下 T5 这个模型，按照我规定的步骤和环境来测。”</strong></p>
<p>为了让你容易理解，我把这份晦涩的代码转换成一张<strong>人类能看懂的 To-Do List</strong>，并一步步拆解它的“观点”（即代码意图）。</p>
<hr />
<h3>📋 给测试员的 To-Do List (任务清单)</h3>
<ol>
<li><strong>【准备资源】</strong>：去申请一台电脑，要带 8 张显卡。</li>
<li><strong>【准备代码】</strong>：<ul>
<li>先把最新的代码下载下来（看看这次改了啥）。</li>
<li>再把以前的老代码也下载下来（做个备份或对比）。</li>
<li><em>观点：确保测试的是特定版本的代码，且兼容旧版本。</em></li>
</ul>
</li>
<li><strong>【配置参数】</strong>：<ul>
<li>告诉程序数据在哪、日志存哪、模型参数怎么设。</li>
<li><em>观点：标准化测试环境，路径不能乱填。</em></li>
</ul>
</li>
<li><strong>【执行测试】</strong>：<ul>
<li>运行一个叫 <code>run_ci_test.sh</code> 的脚本，开始跑模型。</li>
</ul>
</li>
<li><strong>【测试范围（套餐选择）】</strong>：<ul>
<li>你要跑哪些具体的测试案例？（比如：有的测 T5-11B 大模型，有的测并行计算功能，有的测断点续传功能）。</li>
<li><em>观点：针对不同的硬件（H100/A100）和场景（日常合并代码 vs 每晚巡检）跑不同的测试。</em></li>
</ul>
</li>
</ol>
<hr />
<h3>🧐 逐步拆解（一步步讲讲文中的观点）</h3>
<p>现在我们对照文件内容，把上面的 List 展开讲。</p>
<h4>第一步：基础信息与资源 (Spec - Basic Info)</h4>
<div class="codehilite"><pre><span></span><code><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">basic</span>
<span class="nt">spec</span><span class="p">:</span>
<span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;{test_case}_{environment}_{platforms}&#39;</span>
<span class="w">  </span><span class="nt">model</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">t5</span>
<span class="w">  </span><span class="nt">nodes</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span>
<span class="w">  </span><span class="nt">gpus</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8</span>
<span class="w">  </span><span class="nt">platforms</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">dgx_a100</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li>这是一个基础类型的测试。</li>
<li><strong>任务</strong>：测试员，请给我申请 <strong>1 个节点</strong>（nodes: 1），里面要有 <strong>8 张 GPU 显卡</strong>（gpus: 8）。</li>
<li><strong>默认硬件</strong>：默认用 NVIDIA DGX A100 机器跑。</li>
<li><strong>命名规则</strong>：测试任务的名字要包含“测试案例名+环境+平台”。</li>
</ul>
</li>
</ul>
<h4>第二步：准备代码环境 (Spec - script_setup)</h4>
<p>这是最复杂的一段 Shell 脚本，它的核心观点是<strong>“新旧代码都要有”</strong>。</p>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nt">script_setup</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">    </span><span class="no"># ... 登录 gitlab ...</span>

<span class="w">    </span><span class="no"># 1. 下载最新代码 (Checkout latest)</span>
<span class="w">    </span><span class="no"># 这里的逻辑是：拉取当前要测试的那个代码提交 (MR Commit)</span>
<span class="w">    </span><span class="no">git fetch origin $MCORE_MR_COMMIT</span>
<span class="w">    </span><span class="no">git checkout $MCORE_MR_COMMIT</span>

<span class="w">    </span><span class="no"># 2. 下载旧代码 (Checkout backwards-ref)</span>
<span class="w">    </span><span class="no"># 这里的逻辑是：拉取一个旧的稳定版本 (Backwards Commit)</span>
<span class="w">    </span><span class="no"># 然后把新代码里的 megatron 文件夹复制过去</span>
<span class="w">    </span><span class="no">rm -rf megatron; cp -a /opt/megatron-lm/megatron ./</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li>这段代码在做<strong>环境搭建</strong>。</li>
<li>它不仅下载了你当前提交的代码（Latest），还专门去下载了一个旧版本的代码（Legacy）。</li>
<li><strong>观点</strong>：这通常是为了测试<strong>兼容性</strong>，或者是为了用旧的框架加载新的模型代码，确保新代码合入后，不会把旧功能搞崩。</li>
</ul>
</li>
</ul>
<h4>第三步：执行测试脚本 (Spec - script)</h4>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nt">script</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|-</span>
<span class="w">    </span><span class="no"># ... 设置一大堆变量 ...</span>
<span class="w">    </span><span class="no">ARGUMENTS=(</span>
<span class="w">        </span><span class="no">&quot;DATA_PATH=/mnt/artifacts&quot;       # 数据在哪</span>
<span class="w">        </span><span class="no">&quot;OUTPUT_PATH={assets_dir}&quot;       # 结果存哪</span>
<span class="w">        </span><span class="no">&quot;TRAINING_SCRIPT_PATH=pretrain_t5.py&quot; # 跑哪个训练脚本</span>
<span class="w">        </span><span class="no"># ...</span>
<span class="w">    </span><span class="no">)</span>

<span class="w">    </span><span class="no"># 最后执行这一句：</span>
<span class="w">    </span><span class="no">bash ./tests/functional_tests/shell_test_utils/run_ci_test.sh ${{ARGUMENTS[@]}}</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li>这是实际<strong>干活</strong>的地方。</li>
<li>它定义了“输入”（数据路径）、“输出”（日志和检查点路径）以及“参数”（模型配置）。</li>
<li><strong>观点</strong>：所有的测试逻辑被封装在了 <code>run_ci_test.sh</code> 这个脚本里，这里只是负责<strong>传参</strong>。它强调了测试的<strong>标准化</strong>——不管测什么模型，都通过统一的入口脚本来启动。</li>
</ul>
</li>
</ul>
<h4>第四步：测试套餐菜单 (Products)</h4>
<p>文件下半部分列了一大堆 <code>test_case</code>，这是具体的<strong>测试矩阵</strong>。</p>
<p><strong>例子 1：开发阶段的快速测试</strong></p>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">test_case</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">t5_11b_mcore_tp4_pp1</span><span class="p p-Indicator">]</span><span class="w"> </span><span class="c1"># 测 T5 11B 参数量，4卡张量并行</span>
<span class="w">    </span><span class="nt">products</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">environment</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">dev</span><span class="p p-Indicator">]</span>
<span class="w">        </span><span class="nt">scope</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">mr</span><span class="p p-Indicator">]</span><span class="w">          </span><span class="c1"># 重点：mr 代表 Merge Request</span>
<span class="w">        </span><span class="nt">platforms</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">dgx_h100</span><span class="p p-Indicator">]</span><span class="w"> </span><span class="c1"># 指定用 H100 跑</span>
</code></pre></div>

<ul>
<li><strong>观点</strong>：当有开发者提交代码合并请求（MR）时，只跑这个测试。这通常是<strong>快速验证</strong>，确保代码没把核心功能写挂。</li>
</ul>
<p><strong>例子 2：每晚的全面体检</strong></p>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">test_case</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">t5_mcore_te_tp1_pp1_vp1_resume_torch</span><span class="p p-Indicator">]</span><span class="w"> </span><span class="c1"># 测断点续传(resume)</span>
<span class="w">    </span><span class="nt">products</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">environment</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">dev</span><span class="p p-Indicator">]</span>
<span class="w">        </span><span class="nt">scope</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">nightly</span><span class="p p-Indicator">]</span><span class="w">     </span><span class="c1"># 重点：nightly 代表每晚运行</span>
<span class="w">        </span><span class="nt">platforms</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">dgx_a100</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">dgx_h100</span><span class="p p-Indicator">]</span><span class="w"> </span><span class="c1"># A100 和 H100 都要测</span>
</code></pre></div>

<ul>
<li><strong>观点</strong>：有些测试太慢或太细（比如测试断点续传、不同的并行策略），不适合每次提交代码都跑。所以放在<strong>晚上（Nightly）</strong> 慢慢跑，覆盖更多的硬件平台（A100 + H100），做深度体检。</li>
</ul>
<hr />
<h3>总结</h3>
<p>这文件就是一个<strong>自动化测试清单</strong>。</p>
<ul>
<li>如果你是<strong>开发者</strong>，你提交代码后，系统会看 <code>scope: [mr]</code> 下面的条目，帮你跑 T5 模型的几个关键测试。</li>
<li>如果你是<strong>维护者</strong>，你每天早上起来，会看 <code>scope: [nightly]</code> 的结果，确保昨天的改动没有引入深层次的 Bug。</li>
</ul>
<p>它并不包含什么高深的算法原理，它只是在说：<strong>“用这套配置、这个环境、这组参数，去跑那个 T5 模型的训练脚本，看看能不能跑通。”</strong></p>