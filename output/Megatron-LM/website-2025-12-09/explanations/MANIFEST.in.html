<h1>MANIFEST.in</h1>
<p>完全没问题。我们可以把 <code>MANIFEST.in</code> 这个文件想象成你给搬家公司（或者打包员）列的一张<strong>“特殊物品清单”</strong>。</p>
<p>在 Python 的世界里，当你把代码打包分享给别人（比如制作成一个安装包）时，打包工具默认只会把 <code>.py</code>（源代码）装进箱子。它通常会忽略掉文本文件、说明书、或者其他杂七杂八的文件。</p>
<p>这张清单的作用就是告诉打包工具：“<strong>嘿，除了代码，把下面这些东西也给我装进去（或者扔出去）！</strong>”</p>
<p>为了让你好理解，我把这个文件的内容拆解成一个 <strong>由浅入深的 Todo List（任务清单）</strong>，我们一步步来看打包员是怎么执行命令的。</p>
<hr />
<h3>📦 打包员的任务清单 (Todo List)</h3>
<h4>✅ 任务一：单点抓取 (Include)</h4>
<p><strong>目标：</strong> 哪怕这些文件不是代码，也必须显式地把它们放进包裹里。
<strong>命令解读：</strong> <code>include [文件路径]</code></p>
<p>文中的前三行就是在做这件事：</p>
<ol>
<li>
<p><strong><code>include megatron/core/requirements.txt</code></strong></p>
<ul>
<li><strong>意思：</strong> “把 <code>requirements.txt</code> 这个文件带上。”</li>
<li><strong>为什么：</strong> 这个文件通常写着这个软件依赖哪些其他库。用户安装时需要知道还要装什么。</li>
</ul>
</li>
<li>
<p><strong><code>include megatron/core/README.md</code></strong></p>
<ul>
<li><strong>意思：</strong> “把 <code>README.md</code> 这个说明书带上。”</li>
<li><strong>为什么：</strong> 用户下载了包，总得有个说明文档看看怎么用吧。</li>
</ul>
</li>
<li>
<p><strong><code>include megatron/core/package_info.py</code></strong></p>
<ul>
<li><strong>意思：</strong> “把 <code>package_info.py</code> 也带上。”</li>
<li><strong>为什么：</strong> 虽然它是 <code>.py</code> 文件，但有时候为了保险起见（或者因为它不在标准的自动搜索路径里），会显式地指定它，确保版本信息等重要数据被包含。</li>
</ul>
</li>
</ol>
<hr />
<h4>❌ 任务二：全局黑名单 (Global Exclude)</h4>
<p><strong>目标：</strong> 不管在哪里看到这种文件，统统扔掉，绝对不要打包进去。
<strong>命令解读：</strong> <code>global-exclude [文件名]</code></p>
<p>文中的第四行：</p>
<ol>
<li><strong><code>global-exclude LICENSE</code></strong><ul>
<li><strong>意思：</strong> “在整个项目的所有角落里搜索，只要看到文件名叫 <code>LICENSE</code> 的，<strong>全部剔除</strong>，不要放进安装包里。”</li>
<li><strong>为什么：</strong> 这有点特殊。通常开源软件会包含 License（许可证）。这里特意排除，可能是因为：<ul>
<li>已经在其他地方包含了。</li>
<li>或者这是一个子模块，不想让子模块的 License 覆盖了主项目的 License。</li>
<li>或者单纯就是不想在这个包里分发许可证文件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr />
<h4>📂 任务三：地毯式搜索 (Recursive Include)</h4>
<p><strong>目标：</strong> 这个文件夹很关键，把里面所有的东西（包括子文件夹里的）一股脑全装进去。
<strong>命令解读：</strong> <code>recursive-include [文件夹] [匹配规则]</code></p>
<p>文中的最后一行：</p>
<ol>
<li><strong><code>recursive-include requirements *</code></strong><ul>
<li><strong>意思：</strong> “找到 <code>requirements</code> 这个文件夹，把里面 <strong>所有(*)</strong> 的东西，不管几层目录，全部打包。”</li>
<li><strong>为什么：</strong> 有时候依赖项比较复杂，分成了好几个文件放在一个文件夹里。这一行指令省去了把它们一个个列出来的麻烦。</li>
</ul>
</li>
</ol>
<hr />
<h3>总结一下</h3>
<p>如果把这个文件翻译成一段话给打包员听，就是：</p>
<blockquote>
<p>“嘿，兄弟，打包的时候注意一下：
1. 记得把 <code>requirements.txt</code>、<code>README.md</code> 和 <code>package_info.py</code> 这三个具体文件塞进去。
2. 哪怕看到了 <code>LICENSE</code> 文件，也<strong>千万别</strong>放进去，给我扔了。
3. 去 <code>requirements</code> 那个文件夹里，把里面的所有东西都扫荡一遍，全部带走！”</p>
</blockquote>
<p>这就是 <code>MANIFEST.in</code> 的全部含义：<strong>精准控制哪些文件最终会出现在用户的电脑上。</strong></p>