<h1>.gitlab-ci.yml</h1>
<p>这份文件是一个 <strong>GitLab CI/CD 配置文件</strong> (<code>.gitlab-ci.yml</code>)。</p>
<p>你可以把它想象成一个<strong>“自动化流水线机器人的操作手册”</strong>。每当你提交代码、合并代码或者定时任务触发时，GitLab 的机器人就会拿起这份清单，从上到下逐一核对，决定它该干什么活。</p>
<p>为了让你更容易理解，我把这个文件的逻辑拆解成一个 <strong>Task List (任务清单)</strong>。机器人会按照这个顺序一步步执行：</p>
<hr />
<h3>第一阶段：机器人自我检查 (Workflow Rules)</h3>
<p>这是文件最核心、最复杂的部分（即 <code>workflow: rules</code> 部分）。机器人首先要决定：“<strong>我这次到底要不要干活？如果要干，我要用什么配置干？</strong>”</p>
<p><strong>Task 1: 检查是否是外部 Fork 的项目？</strong>
*   <strong>规则</strong>: <code>if: $CI_PROJECT_NAMESPACE != "ADLR" ...</code>
*   <strong>动作</strong>: 如果这不是 <code>ADLR</code> 官方项目（比如是你自己 fork 出去的仓库），或者是 fork 仓库发起的 Merge Request，<strong>直接罢工 (when: never)</strong>。机器人不跑外部的单子。</p>
<p><strong>Task 2: 检查是否是定时任务 (Schedule)？</strong>
*   <strong>规则</strong>: <code>if: $CI_PIPELINE_SOURCE == "schedule" ...</code>
*   <strong>动作</strong>: 如果是定时任务，且分支是 <code>ci-approve-dev</code> 或 <code>main</code>，那就干活。如果是其他 <code>ci-</code> 开头的分支但不是定时任务触发的，就忽略。</p>
<p><strong>Task 3: 检查是否是手动触发 (Web)？</strong>
*   <strong>规则</strong>: <code>if: $CI_PIPELINE_SOURCE == "web"</code>
*   <strong>动作</strong>: 如果是你在网页上点“Run Pipeline”，那就无条件干活。</p>
<p><strong>Task 4: 检查是否是推送到主分支 (Push to Main/Dev)？</strong>
*   <strong>规则</strong>: <code>if: ... ($CI_COMMIT_BRANCH == "main" || "dev" ...)</code>
*   <strong>动作</strong>: 如果代码被合并到了 <code>main</code> 或 <code>dev</code>，这通常意味着代码已经稳定了。
    *   <strong>配置</strong>: 关闭单元测试 (<code>UNIT_TEST: "no"</code>)，开启重量级的<strong>功能测试</strong> (<code>FUNCTIONAL_TEST: "yes"</code>)，并且重复跑 5 次以确保稳定性。</p>
<p><strong>Task 5: 检查 Merge Request (MR) 的标签 (Labels)？</strong>
这是开发者日常最关心的部分。当你提一个 PR/MR 时，机器人会看你给这个 PR 贴了什么标签：</p>
<ul>
<li><strong>情况 A: 贴了 <code>fast-track</code> (快速通道)</strong><ul>
<li><strong>动作</strong>: 只跑单元测试，不跑慢的集成/功能测试。为了快！</li>
</ul>
</li>
<li><strong>情况 B: 贴了 <code>Run tests</code></strong><ul>
<li><strong>动作</strong>: 跑单元测试 + <strong>集成测试</strong> (Integration Test)。</li>
</ul>
</li>
<li><strong>情况 C: 贴了 <code>Run nightly</code> (夜间模式)</strong><ul>
<li><strong>动作</strong>: 跑单元测试 + <strong>功能测试</strong> (Functional Test)，且重复 5 次。这是为了模拟夜间构建的深度测试。</li>
</ul>
</li>
<li><strong>情况 D: 贴了 <code>Run weekly</code> (周常模式)</strong><ul>
<li><strong>动作</strong>: 跑超长时限（9000秒）的功能测试。</li>
</ul>
</li>
<li><strong>情况 E: 贴了 <code>Run functional tests</code></strong><ul>
<li><strong>动作</strong>: 跑一次标准的功能测试。</li>
</ul>
</li>
<li><strong>情况 F: 什么标签都没贴 (默认)</strong><ul>
<li><strong>动作</strong>: 只跑单元测试。这是最省资源的默认状态。</li>
</ul>
</li>
</ul>
<hr />
<h3>第二阶段：确定工作流程 (Stages)</h3>
<p>一旦机器人决定要干活，它会按照以下步骤（流水线阶段）依次执行。这对应文件中的 <code>stages</code> 部分：</p>
<p><strong>Task To-Do List:</strong>
1.  <strong>[ ] Build (构建)</strong>: 先把代码打包，准备好环境。
2.  <strong>[ ] Test (测试)</strong>: 运行单元测试（Unit Test），检查基本的代码逻辑对不对。
3.  <strong>[ ] Integration_tests (集成测试)</strong>: 把各个模块连起来跑一跑，看能不能由 <code>INTEGRATION_TEST</code> 变量控制是否开启。
4.  <strong>[ ] Functional_tests (功能测试)</strong>: 跑深度学习模型训练等重型任务，由 <code>FUNCTIONAL_TEST</code> 变量控制。
5.  <strong>[ ] Publish (发布)</strong>: 如果前面都过了，把软件包发布出去（比如发到 PyPi），由 <code>PUBLISH</code> 变量控制。</p>
<hr />
<h3>第三阶段：加载具体操作指南 (Include)</h3>
<p>你会发现这个文件里并没有写具体的 <code>script</code>（比如 <code>python run_test.py</code>）。因为它把具体的脏活累活都外包出去了。</p>
<p><strong>Task: 导入子任务说明书</strong>
*   文件底部 <code>include:</code> 部分列出了一堆 <code>.yml</code> 文件。
*   这意味着：具体的“怎么构建”、“怎么测试”的代码，分别写在 <code>.gitlab/stages/01.build.yml</code>、<code>02.test.yml</code> 等文件里。这个主文件只是个<strong>总指挥</strong>。</p>
<hr />
<h3>第四阶段：设置全局开关 (Variables)</h3>
<p>文件中间那大段的 <code>variables</code>，其实就是给机器人预设的一堆<strong>默认参数/开关</strong>。</p>
<ul>
<li><code>UNIT_TEST: "yes"</code> -&gt; 默认开启单元测试。</li>
<li><code>CLUSTER_A100</code>: -&gt; 指定如果跑 A100 显卡的任务，去哪个集群跑。</li>
<li><code>PUBLISH: "no"</code> -&gt; 默认不发布包，除非特殊规则覆盖了它。</li>
</ul>
<hr />
<h3>总结：这个文件在讲什么？</h3>
<p><strong>一句话总结：</strong>
这是一个智能调度器。它根据你<strong>怎么提交代码</strong>（是推主分支，还是提 PR）以及<strong>给 PR 贴了什么标签</strong>，来决定要不要跑测试，以及是跑“快速简单的测试”还是“耗时深度的测试”，从而在保证代码质量和节省算力资源之间做平衡。</p>