<h1>.gitlab/scripts/fetch-legacy-suite.sh</h1>
<p>这段脚本完全看不懂是很正常的，因为它涉及到了很多 Linux 命令行的“黑话”和 Git 的底层操作。</p>
<p>简单来说，这个脚本的目的是：<strong>为了做“向后兼容性测试”（Backwards Compatibility Test），搭建一个“弗兰肯斯坦”式的混合代码环境。</strong></p>
<p>它通过把<strong>最新的核心代码</strong>塞进一个<strong>旧版本的仓库外壳</strong>里，来检查新代码能不能在旧环境中运行。</p>
<p>我们可以把这个脚本看作是在执行一个 <strong>Task List（任务清单）</strong>。下面我把它拆解成 5 个具体的待办事项，一步一步带你看。</p>
<hr />
<h3>📋 脚本执行 Task List (待办清单)</h3>
<ol>
<li><strong>[准备工作]</strong>：设定安全规则，接收并检查“你要测试哪个旧版本”。</li>
<li><strong>[清理现场]</strong>：把之前的测试痕迹删掉，建一个干净的新房间。</li>
<li><strong>[穿越时空]</strong>：在这个新房间里，把代码库还原到指定的“旧版本”。</li>
<li><strong>[核心移植]</strong>：把这个“旧版本”里的核心心脏挖掉，换上我们现在的“新心脏”。</li>
<li><strong>[同步配置]</strong>：把现在的测试脚本和配置文件也复制过去，确保能跑起来。</li>
</ol>
<hr />
<h3>🕵️ 逐步详细解读</h3>
<h4>1. [准备工作]：设定规则与接收参数</h4>
<p><strong>代码片段：</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nb">set</span><span class="w"> </span>-euxo<span class="w"> </span>pipefail
<span class="c1"># ...定义变量...</span>
<span class="c1"># ...while 循环解析参数...</span>
<span class="k">if</span><span class="w"> </span><span class="o">[[</span><span class="w"> </span>-z<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">MCORE_BACKWARDS_COMMIT</span><span class="k">:-</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">]]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Error: --backwards-commit is required&quot;</span>
<span class="w">    </span>usage
<span class="k">fi</span>
</code></pre></div>

<ul>
<li><strong>这是啥？</strong><ul>
<li><code>set -euxo pipefail</code>：这是脚本的“安全带”。意思是如果脚本里任何一步出错了（报错），立刻停止运行，不要硬撑，并且把执行的每一句命令都打印出来给你看。</li>
<li><code>while</code> 循环：脚本在问你：“你要用哪个仓库地址（<code>--repo</code>）？”以及最重要的“<strong>你要回退到哪个旧版本（<code>--backwards-commit</code>）？</strong>”</li>
<li><code>if</code> 判断：如果你没告诉它要回退到哪个旧版本（commit hash），它就报错退出。这是必须的参数。</li>
</ul>
</li>
</ul>
<h4>2. [清理现场]：创建干净目录</h4>
<p><strong>代码片段：</strong></p>
<div class="codehilite"><pre><span></span><code>rm<span class="w"> </span>-rf<span class="w"> </span>megatron-lm-legacy
mkdir<span class="w"> </span>megatron-lm-legacy
<span class="nb">pushd</span><span class="w"> </span>megatron-lm-legacy
</code></pre></div>

<ul>
<li><strong>这是啥？</strong><ul>
<li><code>rm -rf megatron-lm-legacy</code>：如果之前跑过这个测试，先删个精光，防止干扰。</li>
<li><code>mkdir</code>：创建一个新文件夹，名字叫 <code>megatron-lm-legacy</code>（意思是“遗留版本的 Megatron”）。</li>
<li><code>pushd</code>：相当于“双击进入”这个文件夹。接下来的操作都在这里面进行。</li>
</ul>
</li>
</ul>
<h4>3. [穿越时空]：拉取旧版本代码</h4>
<p><strong>代码片段：</strong></p>
<div class="codehilite"><pre><span></span><code>git<span class="w"> </span>init
git<span class="w"> </span>remote<span class="w"> </span>add<span class="w"> </span>origin<span class="w"> </span><span class="nv">$MCORE_REPO</span>
git<span class="w"> </span>fetch<span class="w"> </span>origin<span class="w"> </span><span class="nv">$MCORE_BACKWARDS_COMMIT</span>
git<span class="w"> </span>checkout<span class="w"> </span><span class="nv">$MCORE_BACKWARDS_COMMIT</span>
git<span class="w"> </span>rev-parse<span class="w"> </span>HEAD
</code></pre></div>

<ul>
<li><strong>这是啥？</strong><ul>
<li>这里没有用常见的 <code>git clone</code>，而是手动组装仓库。</li>
<li>它在这个空文件夹里初始化 git，添加远程仓库地址。</li>
<li><strong>关键点</strong>：<code>git fetch ... $MCORE_BACKWARDS_COMMIT</code>。它只去下载你指定的那个<strong>旧版本</strong>的代码，而不是下载所有历史记录。</li>
<li><code>git checkout</code>：把当前文件夹的文件状态，变成了那个“旧版本”的样子。</li>
</ul>
</li>
</ul>
<h4>4. [核心移植]：旧瓶装新酒（最关键的一步）</h4>
<p><strong>代码片段：</strong></p>
<div class="codehilite"><pre><span></span><code>rm<span class="w"> </span>-rf<span class="w"> </span>megatron
cp<span class="w"> </span>-a<span class="w"> </span>../megatron-lm/megatron<span class="w"> </span>./
<span class="nb">popd</span>
</code></pre></div>

<ul>
<li><strong>这是啥？</strong><ul>
<li><code>rm -rf megatron</code>：注意！它把刚才下载下来的<strong>旧版本</strong>里的核心代码文件夹 <code>megatron</code> <strong>删掉了</strong>。</li>
<li><code>cp -a ../megatron-lm/megatron ./</code>：它从上一级目录（也就是你当前最新的代码仓库 <code>../megatron-lm</code>）里，把<strong>最新的</strong> <code>megatron</code> 核心代码拷贝了进来。</li>
<li><strong>目的</strong>：现在的状态是 -&gt; <strong>外壳（依赖、环境配置等）是旧的，但核心功能代码是新的。</strong> 这样做是为了测试：<em>我的新代码能不能兼容旧的调用方式？</em></li>
<li><code>popd</code>：退出文件夹，回到最开始的地方。</li>
</ul>
</li>
</ul>
<h4>5. [同步配置]：复制测试脚本</h4>
<p><strong>代码片段：</strong></p>
<div class="codehilite"><pre><span></span><code>cp<span class="w"> </span>megatron-lm/tests/unit_tests/run_ci_test.sh<span class="w"> </span>megatron-lm-legacy/tests/unit_tests/run_ci_test.sh
cp<span class="w"> </span>megatron-lm/pyproject.toml<span class="w"> </span>megatron-lm-legacy/pyproject.toml
</code></pre></div>

<ul>
<li><strong>这是啥？</strong><ul>
<li>虽然外壳是旧的，但为了能跑通现在的 CI（持续集成）流程，脚本把<strong>最新的</strong>测试运行脚本 (<code>run_ci_test.sh</code>) 和项目配置文件 (<code>pyproject.toml</code>) 强行覆盖到了那个“旧环境”里。</li>
<li>这样做是为了保证测试工具本身是最新的，只是运行的环境背景是旧的。</li>
</ul>
</li>
</ul>
<hr />
<h3>💡 总结</h3>
<p>这个脚本讲了一个“<strong>器官移植</strong>”的故事：</p>
<ol>
<li>它造了一个<strong>旧身体</strong>（<code>megatron-lm-legacy</code> 目录，指定旧 Commit）。</li>
<li>它切掉了<strong>旧心脏</strong>（删除了旧的 <code>megatron</code> 目录）。</li>
<li>它换上了<strong>新心脏</strong>（拷贝了当前的 <code>megatron</code> 目录）。</li>
<li>最后给它换上了<strong>新大脑</strong>（最新的测试脚本和配置），准备开始做实验。</li>
</ol>