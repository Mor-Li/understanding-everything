<h1>.gitlab/stages/01.build.yml</h1>
<p>这份文件是一个 <strong>GitLab CI/CD 的配置文件</strong>。简单来说，它是一张<strong>“自动化流水线图纸”</strong>。</p>
<p>它的核心目的是：<strong>告诉服务器如何自动打包代码，构建成 Docker 镜像，并为后续的测试做准备。</strong></p>
<p>为了让你彻底搞懂，我制定了一个 <strong>6步走的“学习任务清单” (To-Do List)</strong>。我们一步一步来拆解这个文件。</p>
<hr />
<h3>✅ Task 1: 理解“模具”与“产品” (Hidden Jobs vs Real Jobs)</h3>
<p><strong>目标</strong>：看懂为什么有些名字前面带个点 <code>.</code>。</p>
<ul>
<li><strong>概念</strong>：在 GitLab CI 中，以 <code>.</code> 开头的名字（比如 <code>.build_rules</code> 和 <code>.build_image</code>）是<strong>“隐藏任务”</strong>或者叫<strong>“模板”</strong>。它们本身不会运行，而是用来被别人“继承”的。</li>
<li><strong>文中对应</strong>：<ul>
<li><code>.build_rules</code>: 定义了“什么时候该运行构建”。</li>
<li><code>.build_image</code>: 定义了“具体怎么构建镜像”的所有脏活累活。</li>
<li><code>test:build_image</code> 和 <code>test:build_nemo_image</code>: 这才是<strong>真正的任务</strong>，它们直接套用了上面的模板。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>结论</strong>：这个文件写了两个“模具”，然后用这两个模具生产了具体的构建任务。</p>
</blockquote>
<hr />
<h3>✅ Task 2: 理解“开关” (Rules)</h3>
<p><strong>目标</strong>：看懂 <code>.build_rules</code> 是怎么控制流程的。</p>
<ul>
<li><strong>代码片段</strong>：
    <code>yaml
    .build_rules:
      rules:
        - if: $BUILD == "no"  # 如果变量 BUILD 是 "no"
          when: never         # 绝不运行
        - when: on_success    # 否则，只要前面的阶段成功了，就运行</code></li>
<li><strong>解读</strong>：这是个总开关。如果有人手动设置变量 <code>$BUILD</code> 为 "no"，整个构建就会跳过。否则，默认开启。</li>
</ul>
<hr />
<h3>✅ Task 3: 搭建“厨房” (Environment &amp; Services)</h3>
<p><strong>目标</strong>：看懂 <code>.build_image</code> 里是在准备什么样的环境。</p>
<ul>
<li><strong>核心代码</strong>：
    ```yaml
    services:<ul>
<li>name: docker:24.0.5-dind  # 重点！
tags:</li>
<li>arch/amd64                # 指定用 AMD64 架构的机器</li>
<li>${TAG}                    # 指定特定标签的机器
```</li>
</ul>
</li>
<li><strong>解读</strong>：<ul>
<li><strong>Docker-in-Docker (dind)</strong>: 这是最关键的一行。因为我们要“构建Docker镜像”，所以我们需要在一个Docker容器里再运行一个Docker守护进程。这就好比“在梦里做梦”。</li>
<li><strong>Tags</strong>: 这是在挑服务器。它告诉 GitLab：“请给我分配一台架构是 AMD64 的、且符合特定标签的大内存机器”。</li>
</ul>
</li>
</ul>
<hr />
<h3>✅ Task 4: 执行“烹饪” (Script)</h3>
<p><strong>目标</strong>：看懂 <code>script</code> 部分具体干了啥。</p>
<ul>
<li><strong>流程拆解</strong>：<ol>
<li><strong>准备调料</strong>：
    <code>bash
    apk add bash curl git  # 安装基础工具
    export ...             # 设置各种环境变量</code></li>
<li><strong>开始炒菜 (核心步骤)</strong>：
    <code>bash
    bash .gitlab/scripts/build.sh</code>
    这里调用了一个外部脚本 <code>build.sh</code>。这才是真正干活的地方（比如运行 <code>docker build</code> 命令），虽然在这个文件里看不到细节，但知道它是去打包镜像就行了。</li>
<li><strong>记录版本</strong>：
    <code>bash
    git fetch ...
    echo "MCORE_MR_COMMIT=..." | tee -a build.env</code>
    这几行是在计算当前代码的版本号，并把它写到一个叫 <code>build.env</code> 的文件里。</li>
</ol>
</li>
</ul>
<hr />
<h3>✅ Task 5: 传递“外卖单” (Artifacts)</h3>
<p><strong>目标</strong>：看懂 <code>artifacts</code> 的作用。</p>
<ul>
<li><strong>代码片段</strong>：
    <code>yaml
    artifacts:
      reports:
        dotenv: build.env</code></li>
<li><strong>解读</strong>：<ul>
<li>这个任务跑完后，机器会销毁。但我们需要把刚才生成的版本号（写在 <code>build.env</code> 里）<strong>传递给下一个阶段</strong>（比如测试阶段）。</li>
<li><code>dotenv</code> 报告就是专门用来在不同任务间传递环境变量的“接力棒”。</li>
</ul>
</li>
</ul>
<hr />
<h3>✅ Task 6: 批量生产与特殊定制 (Matrix &amp; Inheritance)</h3>
<p><strong>目标</strong>：看懂最后两个真正的任务 <code>test:build_image</code> 和 <code>test:build_nemo_image</code>。</p>
<h4>任务 A: <code>test:build_image</code> (批量生产)</h4>
<div class="codehilite"><pre><span></span><code><span class="nt">test:build_image</span><span class="p">:</span>
<span class="w">  </span><span class="nt">extends</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">.build_image</span><span class="p p-Indicator">]</span><span class="w">  </span><span class="c1"># 继承上面的模板</span>
<span class="w">  </span><span class="nt">parallel</span><span class="p">:</span>
<span class="w">    </span><span class="nt">matrix</span><span class="p">:</span><span class="w">                </span><span class="c1"># 矩阵构建（批量）</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">IMAGE</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">CI_MCORE_LTS_IMAGE</span>
<span class="w">        </span><span class="nt">FILE</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Dockerfile.ci.dev</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">...</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">IMAGE</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">CI_MCORE_DEV_IMAGE</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">...</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">IMAGE</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">UTILITY_IMAGE</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">...</span>
</code></pre></div>

<ul>
<li><strong>解读</strong>：这里用了一个高级技巧叫 <strong>Matrix (矩阵)</strong>。</li>
<li>它虽然只写了一段代码，但实际上会<strong>并行启动 3 个任务</strong>。</li>
<li>就像工厂流水线，同时生产三种口味的饮料：<ol>
<li>LTS 版镜像 (长期支持版)</li>
<li>DEV 版镜像 (开发版)</li>
<li>UTILITY 镜像 (工具版)</li>
</ol>
</li>
<li>它们都用同一个模板，只是传入的变量（<code>IMAGE</code>, <code>FILE</code>）不同。</li>
</ul>
<h4>任务 B: <code>test:build_nemo_image</code> (特殊定制)</h4>
<div class="codehilite"><pre><span></span><code><span class="nt">test:build_nemo_image</span><span class="p">:</span>
<span class="w">  </span><span class="nt">extends</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">.build_image</span><span class="p p-Indicator">]</span>
<span class="w">  </span><span class="nt">rules</span><span class="p">:</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">if</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">$FUNCTIONAL_TEST == &quot;yes&quot; ...</span><span class="w"> </span><span class="c1"># 只有特定情况才跑</span>
</code></pre></div>

<ul>
<li><strong>解读</strong>：这是一个特殊的镜像（Nemo）。</li>
<li>它不像上面那个总是运行，它有<strong>额外的条件</strong>：只有当需要做功能测试、集成测试，或者分支名包含特定字符时，这个任务才会启动。</li>
</ul>
<hr />
<h3>总结 (Summary)</h3>
<p>把这个文件翻译成人话，它在说：</p>
<ol>
<li><strong>定义规则</strong>：除非我说不跑，否则默认要跑。</li>
<li><strong>定义方法</strong>：找一台带 Docker 功能的大内存机器，安装 Git，运行 <code>build.sh</code> 脚本打包镜像，并把版本号记下来。</li>
<li><strong>执行批量任务</strong>：利用上面的方法，同时打包 <strong>LTS、Dev、工具</strong> 这三个镜像。</li>
<li><strong>执行条件任务</strong>：如果这次是为了测 Nemo 项目，那就再额外打包一个 <strong>Nemo</strong> 镜像。</li>
</ol>