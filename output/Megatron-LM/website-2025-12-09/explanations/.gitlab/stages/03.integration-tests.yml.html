<h1>.gitlab/stages/03.integration-tests.yml</h1>
<p>完全没问题。这份文件确实比较硬核，因为它涉及到 <strong>GitLab CI 的高级玩法：动态子流水线（Dynamic Child Pipelines）</strong>。</p>
<p>简单来说，这个文件<strong>并没有直接运行测试</strong>，而是<strong>生成了“运行测试的说明书”</strong>，然后再告诉 GitLab 按照这个说明书去跑。</p>
<p>我们可以把这个过程想象成<strong>“筹备一场大型晚宴”</strong>。我把这个文件的逻辑拆解成一个 <strong>To-Do List</strong>，带你一步步看懂它在干嘛。</p>
<hr />
<h3>📋 任务清单：集成测试自动化流程</h3>
<h4>✅ 第一步：门卫检查 (Rules)</h4>
<p><strong>对应代码：</strong> <code>.integration_tests_rules</code>
<strong>任务目标：</strong> 决定今天要不要办这场晚宴（要不要跑测试）。</p>
<ul>
<li><strong>逻辑解读：</strong><ol>
<li>如果变量 <code>$BUILD</code> 是 "no"，直接取消，不跑。</li>
<li>如果变量 <code>$INTEGRATION_TEST</code> 是 "yes"，那就通过，准备开始。</li>
<li>如果没说要跑，默认是不跑的 (<code>when: never</code>)。</li>
</ol>
</li>
<li><strong>总结：</strong> 这是一个开关，防止在不需要的时候浪费昂贵的 GPU 资源。</li>
</ul>
<h4>✅ 第二步：准备菜单和食材 (Configuration)</h4>
<p><strong>对应代码：</strong> <code>integration:configure</code>
<strong>任务目标：</strong> 这一步最关键。它负责<strong>计算</strong>出我们需要跑哪些测试，并写下来。</p>
<ul>
<li><strong>Sub-task 2.1: 等待前置条件 (Needs)</strong><ul>
<li>代码：<code>needs: [test:build_image, ...]</code></li>
<li>解释：必须等镜像构建好（<code>build_image</code>），或者单元测试跑完，才能开始配置集成测试。</li>
</ul>
</li>
<li><strong>Sub-task 2.2: 获取测试配方 (Before Script)</strong><ul>
<li>代码：<code>git submodule add ... megatron-lm-convergence-tests.git</code></li>
<li>解释：去另一个仓库（<code>megatron-lm-convergence-tests</code>）把具体的测试代码/配方下载下来。</li>
</ul>
</li>
<li><strong>Sub-task 2.3: 编写具体计划 (Script)</strong><ul>
<li>代码：四次调用 <code>python ... generate_jet_trigger_job.py</code></li>
<li>解释：这里运行了一个 Python 脚本。它根据当前的硬件环境（A100 或 H100 显卡）和软件环境（Dev 开发版或 LTS 长期支持版），生成了 <strong>4 份不同的配置文件（YAML）</strong>：<ol>
<li><code>functional-test-job-dev-A100.yaml</code> (开发版代码 + A100 显卡)</li>
<li><code>functional-test-job-dev-H100.yaml</code> (开发版代码 + H100 显卡)</li>
<li><code>functional-test-job-lts-A100.yaml</code> (稳定版代码 + A100 显卡)</li>
<li><code>functional-test-job-lts-H100.yaml</code> (稳定版代码 + H100 显卡)</li>
</ol>
</li>
</ul>
</li>
<li><strong>Sub-task 2.4: 保存计划书 (Artifacts)</strong><ul>
<li>代码：<code>artifacts: paths: [...]</code></li>
<li>解释：把上面生成的 4 个 <code>.yaml</code> 文件保存下来，传递给下一步使用。</li>
</ul>
</li>
</ul>
<h4>✅ 第三步：根据菜单开始上菜 (Trigger / Execution)</h4>
<p><strong>对应代码：</strong> <code>.integration_run</code> 和后面的 <code>integration:run_...</code>
<strong>任务目标：</strong> 拿着上一步写好的计划书，正式启动测试任务。</p>
<ul>
<li><strong>逻辑解读：</strong><ul>
<li>这里使用了 <code>trigger</code> 关键字。</li>
<li>它告诉 GitLab：“嘿，不要用我现在的配置了，去读取刚才生成的 <code>functional-test-job-xxx.yaml</code> 文件，用那里面的内容创建一个<strong>新的子流水线 (Child Pipeline)</strong>。”</li>
</ul>
</li>
<li><strong>为什么这么做？</strong><ul>
<li>因为测试任务非常复杂，可能要根据显卡数量动态变化。如果在主文件里写死，会非常长且难以维护。通过 Python 脚本（第二步）动态生成 YAML，想怎么改就怎么改，非常灵活。</li>
</ul>
</li>
</ul>
<h4>✅ 第四步：分会场执行 (The 4 Jobs)</h4>
<p><strong>对应代码：</strong> 文件最后的四个 <code>integration:run_...</code>
<strong>任务目标：</strong> 并行启动 4 个不同的测试环境。</p>
<ol>
<li><code>integration:run_lts_dgx_a100</code>: 负责 <strong>LTS 环境 + A100</strong></li>
<li><code>integration:run_lts_dgx_h100</code>: 负责 <strong>LTS 环境 + H100</strong></li>
<li><code>integration:run_dev_dgx_a100</code>: 负责 <strong>Dev 环境 + A100</strong></li>
<li>
<p><code>integration:run_dev_dgx_h100</code>: 负责 <strong>Dev 环境 + H100</strong></p>
</li>
<li>
<p><strong>解释：</strong> 它们都继承了第三步的模板 (<code>.integration_run</code>)，只是传入了不同的变量（<code>ENVIRONMENT</code> 和 <code>CLUSTER</code>），以此来告诉系统去读取哪一份特定的 YAML 配置文件。</p>
</li>
</ol>
<hr />
<h3>💡 总结一下全流程</h3>
<ol>
<li><strong>Check:</strong> 检查开关，确定要跑测试。</li>
<li><strong>Generate (integration:configure):</strong> 运行一个 Python 脚本，生成 4 个 <code>.yaml</code> 文件。这些文件里写着具体怎么跑测试（比如用多少个节点、跑多久）。</li>
<li><strong>Trigger (integration:run_*):</strong> GitLab 读取这 4 个生成好的 <code>.yaml</code> 文件，<strong>分裂出 4 个子流水线</strong>，真正开始在 GPU 集群上跑测试。</li>
</ol>
<p><strong>一句话概括：</strong> 这个文件本身不干活，它是一个<strong>“包工头”</strong>，负责把活儿分配清楚（生成配置），然后找 4 个分包商（触发子流水线）去干具体的活。</p>