<h1>.gitlab/stages/00.pre.yml</h1>
<p>这份文件是一个 <strong>GitLab CI/CD 的配置文件</strong>（具体来说是 <code>.pre</code> 阶段，也就是“预处理”阶段）。你可以把它看作是一个<strong>自动化的“管家”或“机器人”</strong>，在代码真正开始构建或测试之前，先做一些杂活、整理工作和自动化流程。</p>
<p>为了让你更容易理解，我把这个文件拆解成一个<strong>“机器人的任务清单 (To-Do List)”</strong>。我们可以根据<strong>触发场景</strong>（比如有人提交代码，或者有人合并代码）来看看这个机器人具体都要做什么。</p>
<hr />
<h3>场景一：当有人往主分支 (<code>main</code>) 或开发分支 (<code>dev</code>) 推送了新代码</h3>
<p><strong>机器人的任务：同步和重置测试分支</strong></p>
<p>这部分对应代码中的 <code>pre:create_ci_branches</code> 和 <code>pre:create_ci_branches_dev</code>。</p>
<ul>
<li><strong>任务 1：识别身份</strong><ul>
<li>机器人检查：你是推送到 <code>main</code> 分支还是 <code>dev</code> 分支？</li>
</ul>
</li>
<li><strong>任务 2：更新测试专用分支</strong><ul>
<li><strong>如果是 <code>main</code> 分支：</strong> 机器人会强制把一系列用于测试的分支（比如 <code>ci-nightly</code> 每日构建版, <code>ci-weekly</code> 每周构建版, <code>ci-mr</code> 等）重置为跟 <code>main</code> 一样的代码。</li>
<li><strong>如果是 <code>dev</code> 分支：</strong> 机器人会重置 <code>dev</code> 对应的测试分支（比如 <code>ci-dev-nightly</code>）。</li>
</ul>
</li>
<li><strong>目的：</strong> 确保所有的自动化测试跑的都是最新的代码，触发下游的测试流水线。</li>
</ul>
<hr />
<h3>场景二：当有人提交了一个“合并请求” (Merge Request, MR)</h3>
<p><strong>机器人的任务：帮忙贴标签、检查规范</strong></p>
<p>这部分对应代码中的 <code>pre:label_merge_request</code> 和 <code>pre:check_milestone</code>。</p>
<ul>
<li>
<p><strong>任务 3：智能打标签 (Labeling)</strong></p>
<ul>
<li>机器人会去下载一个叫 <code>gitlab-mr-labeler</code> 的工具。</li>
<li><strong>检查代码变动：</strong> 它会看你改的代码里有没有涉及 <code>megatron/core/</code> 目录下的 <code>parallel_state</code> 相关文件。</li>
<li><strong>执行动作：</strong><ul>
<li>如果改了，它就给这个 MR 自动贴上 <code>ParallelState</code> 的标签。</li>
<li>如果没改，它就把这个标签撕掉。</li>
</ul>
</li>
<li><strong>目的：</strong> 让审查代码的人一眼就能看出这个改动涉及到了并行状态的核心逻辑，需要小心审查。</li>
</ul>
</li>
<li>
<p><strong>任务 4：检查里程碑 (Milestone Check)</strong></p>
<ul>
<li>机器人检查这个 MR 有没有关联“里程碑”（Milestone，比如 v0.5, v1.0 这种版本目标）。</li>
<li><strong>执行动作：</strong> 如果你忘了填，机器人会自动把<strong>当前最新的活跃里程碑</strong>填上去。</li>
<li><strong>目的：</strong> 确保所有代码变动都能被归档到具体的项目进度里。</li>
</ul>
</li>
</ul>
<hr />
<h3>场景三：当代码合并成功后 (Post-Merge)</h3>
<p><strong>机器人的任务：自动搬运代码 (Cherry-Pick)</strong></p>
<p>这部分逻辑比较复杂，主要是为了在不同分支间同步代码。对应 <code>pre:maybe_cherry_pick_to_main</code> 和 <code>pre:maybe_cherry_pick_commit</code>。</p>
<ul>
<li>
<p><strong>任务 5：从 Dev 同步到 Main (Mirror to Main)</strong></p>
<ul>
<li><strong>触发条件：</strong> 代码合并到了 <code>dev</code> 分支，且 MR 上带有 <code>mirror-to-main</code> 的标签。</li>
<li><strong>执行动作：</strong><ol>
<li>机器人把刚才合并的那段代码“摘”（Cherry-pick）出来。</li>
<li>切换到 <code>main</code> 分支。</li>
<li>创建一个新分支，把代码放进去。</li>
<li>自动创建一个新的 MR，标题写着“cp MR ... from dev”，并自动填好描述，甚至艾特原作者说：“嘿，我已经帮你搬运到 main 分支了，请批准一下。”</li>
</ol>
</li>
<li><strong>目的：</strong> 开发分支的功能验证通过后，自动同步到主分支，省去人工操作。</li>
</ul>
</li>
<li>
<p><strong>任务 6：向旧版本分支回合代码 (Backport)</strong></p>
<ul>
<li><strong>触发条件：</strong> 代码推送到 <code>main</code> 分支，且提交信息里关联的 MR 带有 <code>core_</code> 开头的标签（比如 <code>core_v0.6</code>）。</li>
<li><strong>执行动作：</strong><ol>
<li>机器人读取标签，发现这代码需要同步给 <code>v0.6</code> 版本。</li>
<li>它检查 <code>release/v0.6</code> 分支是否存在。</li>
<li>如果存在，它就把这个修补“摘”过去，并自动创建合并请求。</li>
<li>如果失败了（比如代码冲突），它会发消息给 Slack 通知管理员。</li>
</ol>
</li>
<li><strong>目的：</strong> 维护旧版本。比如修复了一个 Bug，既要在最新版修复，也要自动同步给以前的稳定版。</li>
</ul>
</li>
</ul>
<hr />
<h3>场景四：在“合并列车” (Merge Train) 中</h3>
<p><strong>机器人的任务：站岗放哨</strong></p>
<p>这部分对应 <code>pre:check_status_of_main</code>。</p>
<ul>
<li><strong>任务 7：检查主分支健康状况</strong><ul>
<li><strong>背景：</strong> GitLab 有个功能叫 Merge Train（合并列车），让多个 MR 排队合并。</li>
<li><strong>执行动作：</strong> 在真正合并之前，运行一个 Python 脚本 <code>check_status_of_main.py</code>。</li>
<li><strong>目的：</strong> 确保目标分支（通常是 main）当前是健康的。如果主分支已经挂了（测试不通过），就暂停合并，防止把更多坏代码合进去导致雪崩。</li>
</ul>
</li>
</ul>
<hr />
<h3>总结：这个文件在干嘛？</h3>
<p>这个文件并没有做“编译代码”或“训练模型”这种重活。它定义的是<strong>项目管理的自动化逻辑</strong>：</p>
<ol>
<li><strong>自动同步分支</strong>（保持测试环境最新）。</li>
<li><strong>自动分类 MR</strong>（打标签、设里程碑）。</li>
<li><strong>自动跨分支同步代码</strong>（从 Dev 到 Main，或者从 Main 到旧版本）。</li>
<li><strong>合并前的安全检查</strong>。</li>
</ol>
<p>它就像一个极其尽职的<strong>行政秘书</strong>，确保开发流程井井有条。</p>