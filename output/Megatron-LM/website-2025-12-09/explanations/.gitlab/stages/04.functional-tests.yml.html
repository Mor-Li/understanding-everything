<h1>.gitlab/stages/04.functional-tests.yml</h1>
<p>这份文件确实写得比较“硬核”，因为它涉及到了 <strong>动态生成流水线（Dynamic Child Pipelines）</strong> 的高级用法。</p>
<p>简单来说，这个文件的作用是：<strong>在一个大型的 AI 项目（看起来是 Megatron-LM 相关的）中，自动化地在不同类型的 GPU 集群（A100 和 H100）上运行功能测试。</strong></p>
<p>为了让你容易理解，我把它想象成一个 <strong>“项目经理分配任务”</strong> 的 To-Do List，按时间顺序一步步给你讲：</p>
<hr />
<h3>📋 任务清单 (Task To-Do List)</h3>
<h4>第一阶段：把关 (规则检查)</h4>
<ol>
<li><strong>[ ] 检查是否需要开工</strong> (<code>.functional_tests_rules</code>)<ul>
<li><strong>任务：</strong> 只有当环境变量 <code>$FUNCTIONAL_TEST</code> 等于 "yes" 时，才允许执行后续任务。</li>
<li><strong>目的：</strong> 避免每次提交代码都跑这些昂贵的测试，只有明确要求跑的时候才跑。</li>
</ul>
</li>
</ol>
<h4>第二阶段：规划 (生成配置)</h4>
<ol>
<li><strong>[ ] 制定测试计划书</strong> (<code>functional:configure</code>)<ul>
<li><strong>这是最关键的一步。</strong></li>
<li><strong>任务：</strong> 准备好测试环境（下载测试脚本代码），然后运行一个 Python 脚本 (<code>generate_jet_trigger_job.py</code>)。</li>
<li><strong>动作：</strong> 这个脚本会运行 4 次，分别生成 4 份不同的“施工图纸”（YAML 配置文件）：<ol>
<li>开发环境 (Dev) + A100 显卡</li>
<li>开发环境 (Dev) + H100 显卡</li>
<li>长期支持环境 (LTS) + A100 显卡</li>
<li>长期支持环境 (LTS) + H100 显卡</li>
</ol>
</li>
<li><strong>产出：</strong> 4 个 <code>.yaml</code> 文件（放在 <code>artifacts</code> 里传给下一步）。</li>
</ul>
</li>
</ol>
<h4>第三阶段：执行 (触发测试)</h4>
<ol>
<li><strong>[ ] 派发工单并执行</strong> (<code>functional:run_...</code> 系列任务)<ul>
<li>这一步有 4 个具体的任务（对应上面的 4 份图纸）：<ul>
<li><code>functional:run_lts_dgx_a100</code></li>
<li><code>functional:run_lts_dgx_h100</code></li>
<li><code>functional:run_dev_dgx_a100</code></li>
<li><code>functional:run_dev_dgx_h100</code></li>
</ul>
</li>
<li><strong>任务：</strong> 拿着上一步生成的 <code>.yaml</code> 文件，<strong>触发一个新的子流水线 (Child Pipeline)</strong>。</li>
<li><strong>通俗解释：</strong> 就像主流水线说：“嘿，具体的测试细节都在这个 YAML 文件里写好了，你们去那个集群上照着跑吧。”</li>
</ul>
</li>
</ol>
<h4>第四阶段：外包 (可选测试)</h4>
<ol>
<li><strong>[ ] 通知隔壁项目组测试</strong> (<code>functional:run_nemo</code>)<ul>
<li><strong>任务：</strong> 触发另一个项目 (<code>dl/joc/nemo-ci</code>) 的流水线。</li>
<li><strong>状态：</strong> 这是一个手动任务 (<code>when: manual</code>)，通常是为了测试兼容性（比如测试 NeMo 框架是否能跑通）。</li>
</ul>
</li>
</ol>
<h4>第五阶段：汇报 (通知结果)</h4>
<ol>
<li><strong>[ ] 发送测试报告</strong> (<code>functional:x_notify</code>)<ul>
<li><strong>任务：</strong> 等待第三阶段的那 4 个 GPU 测试任务全部跑完。</li>
<li><strong>动作：</strong> 运行一个 Python 脚本 (<code>notify.py</code>)，把测试结果发到 Slack 或者其他通讯工具上。</li>
<li><strong>逻辑：</strong> 无论测试成功还是失败，只要是主分支或者定时任务，都要通知。</li>
</ul>
</li>
</ol>
<h4>第六阶段：维护 (更新基准)</h4>
<ol>
<li><strong>[ ] 更新参考答案</strong> (<code>functional:x_download_golden_values</code>)<ul>
<li><strong>任务：</strong> 手动下载最新的“黄金数值”（Golden Values，即基准测试数据）。</li>
<li><strong>目的：</strong> 当模型算法更新后，旧的测试标准可能不适用了，需要手动跑这个任务来更新对比标准。</li>
</ul>
</li>
</ol>
<hr />
<h3>🔍 关键点代码解析（以此辅助理解）</h3>
<h4>1. 为什么看不懂 <code>functional:configure</code>？</h4>
<div class="codehilite"><pre><span></span><code><span class="nt">script</span><span class="p">:</span>
<span class="w">  </span><span class="c1"># ... 省略变量设置 ...</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">    </span><span class="no">python tests/test_utils/python_scripts/generate_jet_trigger_job.py \</span>
<span class="w">      </span><span class="no">...</span>
<span class="w">      </span><span class="no">--output-path &quot;functional-test-job-dev-A100.yaml&quot;</span>
</code></pre></div>

<p><strong>解释：</strong> 这里没有直接写测试命令，而是用 Python <strong>写代码来生成代码</strong>。这样做的好处是灵活，可以根据不同的参数（比如是否是 Release 版本、集群名字是什么）动态生成复杂的测试配置，而不需要把几千行 YAML 写死在文件里。</p>
<h4>2. 为什么会有 <code>trigger</code>？</h4>
<div class="codehilite"><pre><span></span><code><span class="nt">.functional_run</span><span class="p">:</span>
<span class="w">  </span><span class="nt">trigger</span><span class="p">:</span>
<span class="w">    </span><span class="nt">include</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">artifact</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">functional-test-job-$ENVIRONMENT-$CLUSTER.yaml</span>
<span class="w">        </span><span class="nt">job</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">functional:configure</span>
</code></pre></div>

<p><strong>解释：</strong> 这就是 GitLab CI 的“父子流水线”。
*   <strong>父亲</strong>是当前这个文件。
*   <strong>孩子</strong>是 <code>functional:configure</code> 生成的那个 YAML 文件。
*   父亲负责生成配置，孩子负责在具体的机器上跑测试。</p>
<h3>总结</h3>
<p>这个文件其实就是一个<strong>调度中心</strong>。它自己并不直接运行深度学习训练（那太慢太复杂了），它的工作是：
1.  <strong>计算</strong>出需要跑什么测试。
2.  <strong>生成</strong>对应的任务单。
3.  <strong>分发</strong>到 A100/H100 集群去跑。
4.  <strong>收集</strong>结果并通知人。</p>