<h1>scripts/find_dependent_tests.py</h1>
<p>这份代码是一个<strong>“智能测试选择器”</strong>。</p>
<p>简单来说，它的作用是：<strong>当你在项目中修改了某些代码文件后，它能自动分析出哪些测试用例（Test Cases）受到了影响，从而只运行这些相关的测试，而不是把所有测试都跑一遍（节省时间）。</strong></p>
<p>为了让你听懂，我把这个脚本的工作逻辑拆解成一个 <strong>“项目经理分派给你的 6 个 Task”</strong>，我们一步步来看：</p>
<hr />
<h3>📋 Task List：智能依赖分析任务清单</h3>
<h4>✅ Task 1: 准备工具（能够读懂代码结构）</h4>
<p><strong>目标</strong>：不仅仅把 Python 文件当成文本读，而是要看懂里面的语法结构。
*   <strong>对应代码</strong>：<code>parse_file</code> 函数。
*   <strong>解释</strong>：它使用了 Python 自带的 <code>ast</code> (Abstract Syntax Tree，抽象语法树) 库。这就像是把一篇英语文章不仅仅读出来，而是进行了“语法分析”，知道哪里是动词（函数），哪里是名词（变量）。</p>
<h4>✅ Task 2: 建立档案（提取定义与引用）</h4>
<p><strong>目标</strong>：弄清楚每个文件里“生产”了什么，又“使用”了什么。
*   <strong>对应代码</strong>：
    *   <code>get_definitions_from_tree</code>: 找出这个文件里<strong>定义</strong>了哪些类（Class）和函数（Function）。比如文件 A 定义了函数 <code>add()</code>。
    *   <code>get_imports_from_tree</code>: 找出这个文件<strong>引用</strong>（Import）了哪些外部名称。比如文件 B 写了 <code>from A import add</code>。
*   <strong>观点</strong>：只有知道谁定义了什么，谁引用了什么，才能建立起依赖关系。</p>
<h4>✅ Task 3: 全局扫描与索引（初始化地图）</h4>
<p><strong>目标</strong>：把项目里所有的源码文件（<code>fla/</code> 目录）和测试文件（<code>tests/</code> 目录）都扫描一遍，建立一张巨大的关系网。
*   <strong>对应代码</strong>：<code>DependencyFinder.__init__</code>。
*   <strong>解释</strong>：
    *   它会遍历所有 <code>.py</code> 文件。
    *   建立三个核心字典（Map）：
        1.  <strong>文件 -&gt; 定义了啥</strong> (<code>file_to_definitions</code>)
        2.  <strong>文件 -&gt; 引用了啥</strong> (<code>file_to_imports</code>)
        3.  <strong>符号(函数/类名) -&gt; 在哪个文件定义的</strong> (<code>symbol_to_file_map</code>)
*   <strong>比喻</strong>：这一步就像是给全公司的员工做了一个通讯录，谁叫什么名字，谁在哪个部门，谁认识谁，全部记录下来。</p>
<h4>✅ Task 4: 确定“爆炸半径”（核心逻辑：依赖追踪）</h4>
<p><strong>目标</strong>：给定几个修改过的文件（输入），找出所有受影响的“符号”（函数/类）。
*   <strong>对应代码</strong>：<code>find_dependent_tests</code> 的前半部分（<code>for i in range(max_depth)</code> 循环）。
*   <strong>步骤</strong>：
    1.  <strong>起点</strong>：拿到你修改的文件列表（<code>changed_files</code>）。
    2.  <strong>特殊规则</strong>：代码里有个“潜规则”，如果你改了 <code>modeling_xxx.py</code>，它会自动把对应的 <code>configuration_xxx.py</code> 也算作被修改文件（这是为了防止漏测配置文件的变动）。
    3.  <strong>第一层波及</strong>：找出这些修改过的文件里定义了哪些函数/类（比如 <code>FuncA</code>）。
    4.  <strong>连锁反应（循环）</strong>：
        *   谁引用了 <code>FuncA</code>？假设文件 B 引用了。
        *   那么文件 B 里的代码可能也坏了。
        *   文件 B 里定义的 <code>FuncB</code> 也变成了“危险分子”。
        *   继续找谁引用了 <code>FuncB</code>……
    5.  <strong>停止</strong>：这个过程会重复 <code>max_depth</code> 次（代码里设定为 4 层），防止无限递归。</p>
<h4>✅ Task 5: 锁定嫌疑人（挑选测试文件）</h4>
<p><strong>目标</strong>：拿着上面算出来的“受影响符号列表”，去测试文件夹里抓人。
*   <strong>对应代码</strong>：<code>find_dependent_tests</code> 的后半部分。
*   <strong>判断标准</strong>：
    1.  如果一个测试文件 <code>test_xxx.py</code> <strong>import</strong> 了任何一个“受影响的符号”，那这个测试必须跑。
    2.  如果一个测试文件 import 的<strong>模块名</strong>和受影响的文件名对上了，也要跑。
    3.  如果你直接修改的就是一个测试文件，那它自己肯定要跑。
*   <strong>调试功能</strong>：代码里还包含了一些 <code>DEBUG</code> 逻辑，如果开启，它会打印出“为什么要跑这个测试”的证据链（Dependency Chain）。</p>
<h4>✅ Task 6: 执行与输出（主程序接口）</h4>
<p><strong>目标</strong>：处理命令行输入，过滤黑名单，输出结果。
*   <strong>对应代码</strong>：<code>if __name__ == "__main__":</code> 部分。
*   <strong>解释</strong>：
    *   接收命令行传入的变动文件列表。
    *   <strong>黑名单过滤</strong>：代码里有个 <code>BLACKLIST</code>，忽略掉一些不重要的文件（如 <code>utils/convert_from_llama.py</code>），这些文件改了不需要跑测试。
    *   调用上面的 <code>DependencyFinder</code>。
    *   最后把需要运行的测试文件路径打印出来（用空格分隔），通常这就传给 CI 系统（如 GitHub Actions）去执行 pytest 了。</p>
<hr />
<h3>总结文中的核心观点</h3>
<p>这段代码的核心思想是 <strong>“基于静态分析的变更影响域检测”</strong>。</p>
<ol>
<li><strong>静态分析</strong>：不运行代码，只看代码文本结构（AST）。</li>
<li><strong>传递性</strong>：A 依赖 B，B 依赖 C。如果 C 改了，A 和 B 都要重新测。</li>
<li><strong>启发式搜索</strong>：不仅仅看直接引用，还通过文件名规则（如 model 和 config 的关系）来推测隐式依赖。</li>
</ol>
<p><strong>一句话概括：</strong>
这是一个脚本，用来回答：“<strong>我改了这几个文件，请告诉我最少需要跑哪些测试，才能保证我没把代码改坏？</strong>”</p>