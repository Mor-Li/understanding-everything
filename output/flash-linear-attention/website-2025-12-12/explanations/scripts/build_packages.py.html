<h1>scripts/build_packages.py</h1>
<p>这个脚本 <code>scripts/build_packages.py</code> 的核心目的是：<strong>把原本是一个整体的 Python 项目（<code>fla</code>），拆分成两个独立的安装包来发布。</strong></p>
<p>这就好比把一套很大的乐高积木，拆成“基础包”和“扩展包”分开卖，但装好后它们还能拼在一起用。</p>
<p>以下是为你整理的 <strong>核心逻辑列表</strong> 和 <strong>详细步骤解析</strong>。</p>
<hr />
<h3>📋 核心任务清单 (Task To-Do List)</h3>
<p>脚本运行时，实际上是在按顺序执行以下任务：</p>
<ol>
<li><strong>[准备] 读取信息</strong>：从原本的 <code>setup.py</code> 里“抠”出依赖列表，从 <code>__init__.py</code> 里读出版本号。</li>
<li><strong>[分类] 拆分依赖</strong>：把依赖包分成两类（基础核心依赖 vs 其他扩展依赖）。</li>
<li><strong>[构建] 制作 <code>fla-core</code> 包</strong>：<ul>
<li>创建文件夹。</li>
<li>搬运核心代码（<code>ops</code>, <code>modules</code>, <code>utils</code>）。</li>
<li>生成配置文件 (<code>pyproject.toml</code>)。</li>
</ul>
</li>
<li><strong>[构建] 制作 <code>flash-linear-attention</code> 包</strong>：<ul>
<li>创建文件夹。</li>
<li>搬运上层代码（<code>models</code>, <code>layers</code>）。</li>
<li><strong>关键点</strong>：把 <code>fla-core</code> 设为这个包的必须依赖。</li>
</ul>
</li>
<li><strong>[打包] 执行编译</strong>：调用 Python 的构建工具，把上面两个文件夹真正打成 <code>.whl</code> 安装文件。</li>
<li><strong>[收尾] 整理产物</strong>：把打好的包统一复制到 <code>dist-packages</code> 目录下方便发布。</li>
</ol>
<hr />
<h3>🔍 一步一步详细讲解</h3>
<p>下面我把代码拆解开，用大白话讲讲每一步在干嘛：</p>
<h4>第一步：侦查情报 (Extract &amp; Categorize)</h4>
<ul>
<li><strong>代码位置</strong>：<code>extract_dependencies</code>, <code>categorize_dependencies</code></li>
<li><strong>它在干嘛</strong>：<ul>
<li>脚本去读取项目根目录下的 <code>setup.py</code>。注意，它不是运行 <code>setup.py</code>，而是像读文章一样分析它的语法（AST），把里面列出的 <code>install_requires</code>（安装依赖）全提取出来。</li>
<li><strong>拆分逻辑</strong>：<ul>
<li><strong>核心依赖</strong>：如果依赖名字里包含 <code>torch</code> 或 <code>einops</code>，就被划分为“核心依赖”。</li>
<li><strong>扩展依赖</strong>：其他的依赖都算作“扩展依赖”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>第二步：组装“基础包” (<code>fla-core</code>)</h4>
<ul>
<li><strong>代码位置</strong>：<code>build_split_packages</code> 的前半部分</li>
<li><strong>它在干嘛</strong>：<ol>
<li>它在 <code>dist/fla-core</code> 创建一个新地盘。</li>
<li><strong>搬运代码</strong>：它把原项目里的 <code>ops</code> (算子)、<code>modules</code> (模块) 和 <code>utils.py</code> (工具) 复制过去。这部分是整个库的地基。</li>
<li><strong>特殊处理</strong>：它写了一个特殊的 <code>__init__.py</code>，里面有一句 <code>pkgutil.extend_path</code>。<ul>
<li><em>解释</em>：这是为了告诉 Python，“虽然我叫 <code>fla</code>，但别的地方可能还有叫 <code>fla</code> 的代码，你要把我们合并起来看”。这叫 <strong>Namespace Package（命名空间包）</strong>。</li>
</ul>
</li>
<li><strong>生成身份证</strong>：创建 <code>pyproject.toml</code>，定义这个包叫 <code>fla-core</code>，版本号跟主项目一致。</li>
</ol>
</li>
</ul>
<h4>第三步：组装“扩展包” (<code>flash-linear-attention</code>)</h4>
<ul>
<li><strong>代码位置</strong>：<code>build_split_packages</code> 的后半部分</li>
<li><strong>它在干嘛</strong>：<ol>
<li>它在 <code>dist/flash-linear-attention</code> 创建另一个新地盘。</li>
<li><strong>搬运代码</strong>：把 <code>models</code> (模型) 和 <code>layers</code> (层) 复制过去。这些是基于核心代码搭建的上层建筑。</li>
<li><strong>设置依赖</strong>：它会在配置文件里写上：<strong>我依赖 <code>fla-core</code></strong>。这意味着用户只要安装这个包，pip 就会自动把上面的核心包也装上。</li>
<li><strong>特殊处理</strong>：注意看注释 <code>Intentionally do NOT create fla/__init__.py</code>。<ul>
<li><em>解释</em>：这个包里<strong>不放</strong> <code>__init__.py</code>，这是为了配合上面的命名空间技术，防止冲突。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4>第四步：真正打包 (Build)</h4>
<ul>
<li><strong>代码位置</strong>：<code>build_packages</code></li>
<li><strong>它在干嘛</strong>：<ul>
<li>刚才只是把文件拷好了，现在要变成可安装文件。</li>
<li>脚本会调用系统命令 <code>python -m build</code>。</li>
<li>它会分别进入 <code>dist/fla-core</code> 和 <code>dist/flash-linear-attention</code> 目录，把它们编译成 <code>.whl</code> (Wheel文件) 和 <code>.tar.gz</code> (源码包)。</li>
</ul>
</li>
</ul>
<h4>第五步：发货 (Copy Output)</h4>
<ul>
<li><strong>代码位置</strong>：<code>copy_packages_to_output</code></li>
<li><strong>它在干嘛</strong>：<ul>
<li>编译好的文件散落在不同的子文件夹里，太乱了。</li>
<li>这一步把所有生成的 <code>.whl</code> 和 <code>.tar.gz</code> 文件全部捡出来，统一复制到根目录下的 <code>dist-packages/</code> 文件夹里。</li>
<li>最后告诉你：“好了，你可以去 <code>dist-packages/</code> 拿文件去安装或上传了”。</li>
</ul>
</li>
</ul>
<h3>总结</h3>
<p>这个脚本就是一个<strong>自动化拆分发布工具</strong>。</p>
<p><strong>为什么要这么做？</strong>
通常是为了解耦。也许开发者希望 <code>fla-core</code> 作为一个轻量级的底层算子库单独存在，而 <code>flash-linear-attention</code> 是包含完整模型的全家桶。这样用户如果只需要底层算子，就不用下载整个巨大的模型库。</p>