<h1>scripts/check_gpu.py</h1>
<p>这个脚本看起来代码很多，但其实它的核心逻辑非常简单。你可以把它想象成一个<strong>“排队等待机”</strong>。</p>
<p>它的作用是：<strong>在运行新的任务之前，先检查显卡（GPU）忙不忙。如果显卡太忙（显存占用高），它就等着；如果显卡空闲了，它就放行。</strong></p>
<p>为了让你彻底看懂，我为你列了一个 <strong>4步走的 Task List（学习清单）</strong>，我们一步一步来拆解它。</p>
<hr />
<h3>📝 学习清单 (Task To-Do List)</h3>
<ol>
<li><strong>Task 1：找到“红绿灯”的标准</strong> (什么时候算忙？什么时候算闲？)</li>
<li><strong>Task 2：搞懂它是怎么“看”显卡的</strong> (它怎么知道显存用了多少？)</li>
<li><strong>Task 3：理解核心的“等待循环”</strong> (如果忙，它会怎么做？)</li>
<li><strong>Task 4：理解“超时机制”</strong> (如果一直忙，它会死等吗？)</li>
</ol>
<hr />
<h3>🔍 逐步拆解</h3>
<h4>✅ Task 1：找到“红绿灯”的标准</h4>
<p>在代码的 <code>check_gpu_memory</code> 函数开头，定义了几个关键数字，这就是它的判断标准。</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">check_gpu_memory</span><span class="p">():</span>
    <span class="n">max_memory_mib</span> <span class="o">=</span> <span class="mi">4096</span>  <span class="c1"># 阈值：4096 MiB (也就是 4GB)</span>
    <span class="n">max_wait_time</span> <span class="o">=</span> <span class="mi">3600</span>   <span class="c1"># 最大等待时间：3600秒 (1小时)</span>
    <span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">30</span>        <span class="c1"># 每次检查间隔：30秒</span>
</code></pre></div>

<ul>
<li><strong>观点 1</strong>：这个脚本认为，只要显存占用超过 <strong>4GB (4096 MiB)</strong>，显卡就算“忙”，不能运行新任务。</li>
<li><strong>观点 2</strong>：如果忙，它每隔 <strong>30秒</strong> 会醒来检查一次。</li>
</ul>
<h4>✅ Task 2：搞懂它是怎么“看”显卡的</h4>
<p>脚本需要知道当前显存用了多少。它区分了两种显卡：<strong>Intel (xpu)</strong> 和 <strong>NVIDIA (nvgpu)</strong>。</p>
<ul>
<li><strong>NVIDIA 显卡 (最常见的情况)</strong>：
    看 <code>get_nvgpu_memory_usage</code> 函数。它实际上是在后台偷偷运行了一个命令 <code>nvidia-smi</code>（你可能在终端里用过），然后把输出的数字（显存占用量）抓取回来。</li>
<li><strong>Intel 显卡</strong>：
    看 <code>check_gpu_memory</code> 中间的逻辑：
    <code>python
    if device_platform == 'intel':
        # ...
        # since xpu-smi have conflicts in apt
        memory_used_mib = 0  # &lt;--- 注意这里！</code>
    <strong>观点 3</strong>：虽然上面写了一大堆 <code>get_xpu_memory_usage</code> 和 <code>extract_gpu_memory_used</code> 的代码，但在主逻辑里，<strong>作者把 Intel 显卡的部分直接“短路”了，强制设为 0</strong>。这意味着如果是 Intel 显卡，脚本会认为显存占用永远是 0，永远直接放行。（作者注释说是因为驱动冲突问题）。</li>
</ul>
<h4>✅ Task 3：理解核心的“等待循环”</h4>
<p>这是脚本的灵魂，是一个 <code>while True</code> 的死循环：</p>
<div class="codehilite"><pre><span></span><code>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># ... 获取 memory_used_mib (显存用了多少) ...</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current GPU memory usage: </span><span class="si">{</span><span class="n">memory_used_mib</span><span class="si">}</span><span class="s2"> MiB&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">memory_used_mib</span> <span class="o">&gt;</span> <span class="n">max_memory_mib</span><span class="p">:</span>
            <span class="c1"># 如果占用 &gt; 4GB</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GPU memory usage exceeds... Sleeping...&quot;</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">)</span> <span class="c1"># 睡30秒，然后回到 while 开头重新检查</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 如果占用 &lt;= 4GB</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;GPU memory usage is within limits.&quot;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 成功退出脚本！(代表“绿灯”，后续任务可以开始了)</span>
</code></pre></div>

<ul>
<li><strong>观点 4</strong>：这是一个“看门大爷”。只要显存占用高，它就拦着不让过（让程序睡30秒）；一旦显存降下来了，它就 <code>exit(0)</code>，表示“通过”。</li>
</ul>
<h4>✅ Task 4：理解“超时机制”</h4>
<p>如果显卡一直很忙，忙了一整天怎么办？脚本不能无限等下去。</p>
<div class="codehilite"><pre><span></span><code>        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="c1"># 刚开始计时</span>

        <span class="c1"># ... 在循环里 ...</span>

        <span class="c1"># 检查现在的时间 - 开始的时间 是否超过了 最大等待时间</span>
        <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="n">max_wait_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;GPU memory usage remains high for 10 minutes. Skipping this action.&quot;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 报错退出！(代表“等不起了，不等了”)</span>
</code></pre></div>

<ul>
<li><strong>观点 5</strong>：这里有一个<strong>Bug/笔误</strong>。代码里设置的 <code>max_wait_time</code> 是 3600秒（1小时），但打印出来的字却说 "remains high for 10 minutes"（10分钟）。</li>
<li><strong>结论</strong>：实际上它会等 <strong>1小时</strong>。如果1小时后显卡还是很忙，它就执行 <code>exit(1)</code>，这通常意味着告诉调用它的父程序：“显卡太忙了，任务取消或报错”。</li>
</ul>
<hr />
<h3>💡 总结 (Summary)</h3>
<p>这个脚本讲了这么一件事：</p>
<blockquote>
<p>“我要运行一个任务，但我怕把显卡挤爆。
所以我先查一下显卡（N卡）显存用了多少。
如果<strong>超过 4GB</strong>，我就<strong>每 30秒</strong> 查一次，一直等。
如果<strong>等到 1小时</strong> 还没空出来，我就<strong>报错退出</strong>。
如果显存<strong>低于 4GB</strong>，我就<strong>正常退出</strong>，让后面的任务赶紧跑。”</p>
</blockquote>
<p>现在再回头看代码，是不是清晰多了？</p>