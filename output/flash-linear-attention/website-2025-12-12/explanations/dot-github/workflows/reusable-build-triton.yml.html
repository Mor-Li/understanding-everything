<h1>.github/workflows/reusable-build-triton.yml</h1>
<p>这份文件是一个 <strong>GitHub Actions 的“可重用工作流”（Reusable Workflow）</strong>。</p>
<p>简单来说，它就像是一个<strong>“通用配方”</strong>或<strong>“流水线蓝图”</strong>。别的项目或工作流可以“调用”它，传入一些参数（比如要在哪台机器上跑、是x86还是ARM架构），然后这个脚本就会自动完成复杂的编译和发布工作。</p>
<p>它的核心目标是：<strong>编译 Triton（一个深度学习编译器）的 Python 安装包（Wheel），并发布到内部服务器。</strong></p>
<p>为了让你好理解，我把它拆解成一个<strong>机器人的任务清单 (To-Do List)</strong>，按时间顺序一步步给你讲：</p>
<hr />
<h3>🤖 机器人的任务清单 (To-Do List)</h3>
<h4>第一阶段：准备工作 (也就是 <code>inputs</code> 和 <code>secrets</code> 部分)</h4>
<p>在干活之前，机器人先问你要了这些信息：
1.  <strong>确定在谁家干活 (<code>runner</code>)</strong>：指定这活儿是在 Intel 显卡机器上干，还是在树莓派 (Pi) 上干。
2.  <strong>确定做什么口味 (<code>arch</code>)</strong>：是做电脑版 (x86_64) 还是手机/嵌入式版 (aarch64)。
3.  <strong>确定名字 (<code>package-name</code>)</strong>：是正式版 (<code>triton</code>) 还是每晚开发的测试版 (<code>triton-nightly</code>)。
4.  <strong>拿钥匙 (<code>secrets</code>)</strong>：拿到上传文件所需的密码和代理服务器的地址。</p>
<hr />
<h4>第二阶段：清理与取材 (Steps 1-3)</h4>
<ol>
<li><strong>打扫卫生</strong> (<code>Prune stale docker containers</code>)<ul>
<li><strong>任务</strong>：清理掉旧的 Docker 容器，腾出空间，防止硬盘爆满。</li>
</ul>
</li>
<li><strong>拿菜谱和食材</strong> (<code>Checkout Triton</code>)<ul>
<li><strong>任务</strong>：从 GitHub 上把 Triton 的源代码下载下来。</li>
</ul>
</li>
<li><strong>准备厨具</strong> (<code>Set up version</code>)<ul>
<li><strong>任务</strong>：<ul>
<li>生成一个时间戳（比如 <code>20231027...</code>），如果是测试版，这个时间戳会用在版本号里。</li>
<li>安装 Python 的打包工具 <code>wheel</code> 和 <code>cibuildwheel</code>（这是专门用来造 Python包的神器）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr />
<h4>第三阶段：修改秘方 (Steps 4-5)</h4>
<p>这里是“魔改”源代码配置，为了适应特定的内网环境。
4.  <strong>修改配置文件</strong> (<code>Patch setup.py</code>)
    *   <strong>任务</strong>：修改 <code>setup.cfg</code>，指定编译时的基础目录。
5.  <strong>替换下载源</strong> (<code>Patch setup.py mirror</code>)
    *   <strong>任务</strong>：<strong>这一步很关键</strong>。Triton 编译时需要下载 LLVM（底层编译器）。
    *   <strong>逻辑</strong>：如果是在特定的内网机器（如 <code>intel-a770</code> 或 <code>pi</code>）上跑，脚本会把原本指向微软云的下载链接，强行替换成内部的镜像站 (<code>llvm.fla-org.com</code>)。
    *   <strong>目的</strong>：为了下载更快，或者因为内网访问不了外网。</p>
<hr />
<h4>第四阶段：开火烹饪 —— 核心编译 (Step 6: <code>Build wheels</code>)</h4>
<p>这是整个脚本最长、最复杂的一步。它在 Docker 容器里进行。</p>
<ol>
<li><strong>配置网络代理</strong><ul>
<li><strong>任务</strong>：根据机器名字（<code>intel-a770</code>, <code>pi</code>, <code>n100</code>），设置 HTTP 和 SOCKS 代理。</li>
<li><strong>原因</strong>：这些特定机器可能在防火墙后面，不设代理连不上网，无法安装依赖。</li>
</ul>
</li>
<li><strong>安装系统依赖</strong> (<code>CIBW_BEFORE_ALL</code>)<ul>
<li><strong>任务</strong>：在 Linux 容器里安装 <code>clang</code> (编译器), <code>lld</code> (链接器)。</li>
<li><strong>特殊操作</strong>：如果是内网机器，还会修改 <code>/etc/hosts</code> 和 <code>yum</code> 源，强制走阿里云镜像或内部镜像，防止网络超时。</li>
</ul>
</li>
<li><strong>配置缓存</strong> (<code>ccache</code>)<ul>
<li><strong>任务</strong>：设置编译缓存。如果以前编译过类似的代码，这次可以直接用，不用重新算，大大加快速度。</li>
</ul>
</li>
<li><strong>拉取 Docker 镜像</strong><ul>
<li><strong>任务</strong>：根据架构（x86 或 aarch64）下载官方标准的 Python 编译环境镜像。</li>
</ul>
</li>
<li><strong>开始编译</strong> (<code>cibuildwheel</code>)<ul>
<li><strong>任务</strong>：启动编译命令！这一步会消耗大量 CPU，生成最终的 <code>.whl</code> 文件（安装包）。</li>
</ul>
</li>
</ol>
<hr />
<h4>第五阶段：包装与送货 (Step 7: <code>Rename and Publish wheels</code>)</h4>
<p>菜做好了，现在要打包送给客户。</p>
<ol>
<li><strong>改名（仅限测试版）</strong><ul>
<li><strong>逻辑</strong>：如果你选的是 <code>triton-nightly</code>（每晚构建版）。</li>
<li><strong>任务</strong>：<ul>
<li>把刚生成的 <code>.whl</code> 包解压。</li>
<li>把包名从 <code>triton</code> 改成 <code>triton-nightly</code>。</li>
<li>把版本号加上今天的日期（比如 <code>2.1.0</code> 变成 <code>2.1.0.dev20231027</code>）。</li>
<li>重新打包封箱。</li>
</ul>
</li>
<li><strong>原因</strong>：为了区分正式版和测试版，防止用户装错。</li>
</ul>
</li>
<li><strong>上传快递</strong><ul>
<li><strong>任务</strong>：使用 <code>lftp</code> 工具，通过 FTP 协议把所有做好的 <code>.whl</code> 文件上传到内部的 PyPI 服务器 (<code>fla-org.com</code>)。</li>
<li><strong>结果</strong>：上传成功后，内部人员就可以通过 <code>pip install</code> 下载使用了。</li>
</ul>
</li>
</ol>
<hr />
<h3>总结</h3>
<p>这个脚本主要讲了这么一件事：</p>
<blockquote>
<p>“在一台指定的（可能是内网受限的）机器上，拉取代码，修改下载链接以适应内网，配置好复杂的网络代理和缓存，用 Docker 编译出 Python 安装包，如果是测试版就改个名，最后把包上传到私有服务器去。”</p>
</blockquote>