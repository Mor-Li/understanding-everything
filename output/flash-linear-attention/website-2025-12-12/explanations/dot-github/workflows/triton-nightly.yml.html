<h1>.github/workflows/triton-nightly.yml</h1>
<p>这个文件是一个 <strong>GitHub Actions</strong> 的配置文件。你可以把它想象成一个<strong>全自动化的流水线工厂</strong>的说明书。</p>
<p>它的主要目的是：每天晚上自动把代码打包成软件（Triton Nightly版），或者允许你手动触发去测试打包某一个特定版本。</p>
<p>为了让你看懂，我把阅读这个文件拆解成 <strong>5个具体的任务（Todo List）</strong>，我们一步步来完成：</p>
<hr />
<h3>✅ Task 1：搞清楚“工厂”什么时候开工？（触发条件）</h3>
<p>看文件开头的 <code>on:</code> 部分，这里定义了什么时候运行这个脚本。</p>
<ul>
<li><strong>自动开工（闹钟）</strong>：<ul>
<li><code>schedule</code>: 设置了 <code>cron: "0 8 * * *"</code>。</li>
<li><strong>含义</strong>：每天早上 8:00 (UTC时间) 准时自动运行。</li>
</ul>
</li>
<li><strong>手动开工（按钮）</strong>：<ul>
<li><code>workflow_dispatch</code>: 这意味着你可以在 GitHub 网页上点一个按钮手动启动它。</li>
<li><strong>含义</strong>：手动启动时，它还弹出一个表单让你填（<code>inputs</code>），比如：<ul>
<li><code>run_single_version_test</code>: 要不要只测一个特定版本？（默认否）</li>
<li><code>python_test_version</code>: 测哪个 Python 版本？（比如 3.12）</li>
<li><code>build_architecture</code>: 测什么芯片架构？（x86 还是 ARM）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3>✅ Task 2：理解主要生产线（Job 1: Nightly Build）</h3>
<p>这是这个文件最核心的工作。看 <code>jobs:</code> 下面的 <code>nightly-build</code> 部分。</p>
<ul>
<li><strong>谁能进入这条线？ (<code>if</code>)</strong><ul>
<li>如果是定时触发（<code>schedule</code>） -&gt; <strong>进</strong>。</li>
<li>如果是手动触发，<strong>并且</strong> 你没有勾选“只测单版本” -&gt; <strong>进</strong>。</li>
</ul>
</li>
<li><strong>分工合作 (<code>strategy: matrix</code>)</strong><ul>
<li>这里用了一个很厉害的技巧叫“矩阵（Matrix）”。它会同时启动两台机器并行工作：<ol>
<li><strong>机器 A</strong>: 跑 <code>x86_64</code> (主要用于普通电脑/服务器)。</li>
<li><strong>机器 B</strong>: 跑 <code>aarch64</code> (主要用于 ARM 架构，比如某些服务器或类似 Mac M系列芯片的环境)。</li>
</ol>
</li>
</ul>
</li>
<li><strong>具体干活 (<code>uses</code>)</strong><ul>
<li>它没有自己写怎么打包，而是“外包”给了另一个文件：<code>./.github/workflows/reusable-build-triton.yml</code>。</li>
<li><strong>重点参数</strong>：<ul>
<li><code>cibw-build</code>: <code>cp3{10,11,12,13}-...</code> 意思是把 Python 3.10 到 3.13 的版本全打一遍包。</li>
<li><code>package-name</code>: 打出来的包名字叫 <code>triton-nightly</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结 Task 2</strong>：这是常规任务，每天把所有主流 Python 版本的包都打好。</p>
<hr />
<h3>✅ Task 3：理解“定制化”准备工作（Job 2: Prepare Matrix）</h3>
<p>如果你在手动触发时，勾选了“我要测单版本”，上面的 Task 2 就不会运行，而是运行下面这套逻辑。</p>
<p>看 <code>prepare-test-matrix</code> 部分。</p>
<ul>
<li><strong>目的是什么？</strong><ul>
<li>因为你想测的版本是不确定的（可能是 x86 的 Python 3.12，也可能是 ARM 的 Python 3.11），GitHub Actions 需要先计算一下“该派哪台机器去干活”。</li>
</ul>
</li>
<li><strong>怎么计算的？ (<code>run</code> 里的脚本)</strong><ul>
<li>它读取你填写的 Python 版本（比如 <code>3.12</code> 变成 <code>312</code>）。</li>
<li>它读取你选的架构（<code>x86_64</code>, <code>aarch64</code> 或 <code>all</code>）。</li>
<li>然后它写了一段 Shell 脚本逻辑：<ul>
<li>如果你选 x86，它就准备 x86 的配置。</li>
<li>如果你选 ARM，它就准备 ARM 的配置。</li>
<li>如果你选 All，它就把两个配置拼在一起。</li>
</ul>
</li>
</ul>
</li>
<li><strong>输出结果</strong><ul>
<li>最后它生成了一段 JSON 格式的配置（<code>matrix</code>），传给下一个任务。</li>
</ul>
</li>
</ul>
<p><strong>总结 Task 3</strong>：这是一个“调度员”，负责根据你的手动输入，生成一张任务单。</p>
<hr />
<h3>✅ Task 4：执行“定制化”任务（Job 3: Execute Test Build）</h3>
<p>看 <code>execute-test-build</code> 部分。</p>
<ul>
<li><strong>等待调度</strong>：<ul>
<li><code>needs: prepare-test-matrix</code>：它必须等上面的 Task 3 算完才能动。</li>
</ul>
</li>
<li><strong>读取任务单</strong>：<ul>
<li><code>matrix: ${{ fromJson(...) }}</code>：它直接读取 Task 3 生成的那张 JSON 任务单。</li>
</ul>
</li>
<li><strong>开始干活</strong>：<ul>
<li>同样是“外包”给 <code>reusable-build-triton.yml</code>。</li>
<li>但这次参数变了：<ul>
<li><code>cibw-build</code>: 不再是所有版本，而是你在 Task 3 里算出来的那个特定版本（比如只跑 <code>cp312-manylinux_x86_64</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结 Task 4</strong>：这是“特种兵”，只打包你指定的那个特定版本，而不是全家桶。</p>
<hr />
<h3>✅ Task 5：全景回顾（总结）</h3>
<p>把所有点串起来，这个文件的逻辑流程图如下：</p>
<ol>
<li><strong>触发</strong>：早晨8点 <strong>或者</strong> 人工手动点击。</li>
<li><strong>判断</strong>：<ul>
<li><strong>情况 A（常规）</strong>：如果是定时，或者手动没选特殊测试 -&gt; <strong>执行 Job 1 (Nightly Build)</strong> -&gt; 并行打包所有 Python 版本 -&gt; <strong>结束</strong>。</li>
<li><strong>情况 B（特殊）</strong>：如果是手动且选了特殊测试 -&gt; <strong>执行 Job 2 (准备数据)</strong> -&gt; 算出要跑哪个版本 -&gt; <strong>执行 Job 3 (执行测试)</strong> -&gt; 只打包指定版本 -&gt; <strong>结束</strong>。</li>
</ul>
</li>
</ol>
<p><strong>用一句话说给老板听</strong>：
“这个脚本负责每天早上自动帮我们把 Triton 的最新代码打包成 Python 库（支持 Python 3.10-3.13），同时也支持开发人员手动去测试打包某一个特定的 Python 版本或芯片架构。”</p>