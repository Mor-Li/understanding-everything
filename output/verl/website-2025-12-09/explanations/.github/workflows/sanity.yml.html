<h1>.github/workflows/sanity.yml</h1>
<p>这份文件确实包含了很多技术细节，因为它是一个 <strong>CI（持续集成）配置文件</strong>。</p>
<p>简单来说，这就像是给机器人下达的一张<strong>“每日体检清单”</strong>。每当有人修改了代码，机器人就会自动按照这个清单，检查代码有没有犯一些低级的错误。</p>
<p>为了让你更容易理解，我把你（作为学习者）的任务拆分成一个 <strong>ToDo List</strong>，我们一项一项来勾选，顺便把文件内容讲清楚。</p>
<hr />
<h3>📋 你的学习任务清单 (ToDo List)</h3>
<ol>
<li><strong>[ ] 任务一：搞懂背景（阅读文件头部的注释）</strong><ul>
<li>了解这个项目是怎么存放测试代码的。</li>
</ul>
</li>
<li><strong>[ ] 任务二：搞懂触发机制（When?）</strong><ul>
<li>这个检查什么时候会自动运行？</li>
</ul>
</li>
<li><strong>[ ] 任务三：准备环境（Setup）</strong><ul>
<li>机器人运行检查前需要安装什么？</li>
</ul>
</li>
<li><strong>[ ] 任务四：执行具体检查（Action!）</strong><ul>
<li>机器人具体检查了哪些内容？（这是核心）</li>
</ul>
</li>
</ol>
<hr />
<h3>逐步讲解</h3>
<h4>✅ 任务一：搞懂背景（文件头部注释）</h4>
<p>文件最开头的注释（<code>#</code> 开头的部分）其实是写给开发者看的“说明书”，告诉大家测试文件该怎么放。</p>
<ul>
<li><strong>测试分类</strong>：<ul>
<li>普通的测试放在 <code>tests/</code> 下面（比如 <code>tests/models</code> 测模型）。</li>
<li>特殊的测试放在 <code>special_</code> 开头的文件夹里。</li>
<li><strong>重点</strong>：这个文件主要负责跑 <code>special_sanity</code>（快速健康检查）里的内容。</li>
</ul>
</li>
<li><strong>CPU vs GPU</strong>：<ul>
<li>默认情况下，测试是假设有显卡（GPU）的。</li>
<li>但是，如果文件名里带 <code>on_cpu</code>，或者在 <code>special_npu</code> 里，就在 CPU 或 NPU 上跑。</li>
</ul>
</li>
<li><strong>工作流概览</strong>：<ul>
<li>注释列出了很多其他的 <code>.yml</code> 文件（比如 <code>model.yml</code>, <code>e2e_*.yml</code>），说明这个 <code>sanity.yml</code> 只是众多检查中的<strong>第一道关卡</strong>（最基础的检查）。</li>
</ul>
</li>
</ul>
<h4>✅ 任务二：搞懂触发机制（When?）</h4>
<p>看代码中的 <code>on:</code> 部分：</p>
<div class="codehilite"><pre><span></span><code><span class="nt">on</span><span class="p">:</span>
<span class="w">  </span><span class="nt">push</span><span class="p">:</span>
<span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">main</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">v0.*</span><span class="p p-Indicator">]</span>
<span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span>
<span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">main</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">v0.*</span><span class="p p-Indicator">]</span>
<span class="w">    </span><span class="nt">paths</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="s">&quot;**/*.py&quot;</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;.github/workflows/sanity.yml&quot;</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;tests/special_sanity/**&quot;</span><span class="p p-Indicator">]</span>
</code></pre></div>

<ul>
<li><strong>含义</strong>：<ul>
<li><strong>Push（推送）时</strong>：只要有人往 <code>main</code> 分支或者 <code>v0.x</code> 版本分支提交代码，<strong>立刻执行</strong>。</li>
<li><strong>Pull Request（提代码合并请求）时</strong>：如果有人想把代码合并进来，并且他修改了 <code>.py</code> 文件、修改了这个配置文件本身、或者修改了 <code>sanity</code> 测试文件夹，<strong>立刻执行</strong>。</li>
</ul>
</li>
<li><strong>目的</strong>：防止有人提交了烂代码污染主分支。</li>
</ul>
<h4>✅ 任务三：准备环境（Setup）</h4>
<p>看 <code>jobs:</code> 下面的 <code>steps</code> 前几步：</p>
<div class="codehilite"><pre><span></span><code><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">ubuntu-latest</span><span class="w">  </span><span class="c1"># 1. 找一台 Linux 机器</span>
<span class="nt">python-version</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="s">&quot;3.10&quot;</span><span class="p p-Indicator">]</span><span class="w"> </span><span class="c1"># 2. 用 Python 3.10</span>
<span class="c1"># ...</span>
<span class="l l-Scalar l-Scalar-Plain">pip3 install torch ... --index-url .../cpu</span><span class="w"> </span><span class="c1"># 3. 安装 CPU 版 PyTorch</span>
<span class="l l-Scalar l-Scalar-Plain">pip install -e .[test]</span><span class="w">  </span><span class="c1"># 4. 安装当前项目和测试工具</span>
</code></pre></div>

<ul>
<li><strong>含义</strong>：<ul>
<li>机器人向 GitHub 申请了一台装有 Ubuntu 系统的虚拟电脑。</li>
<li>因为它只做“代码格式”和“简单逻辑”检查，不需要昂贵的显卡，所以它特意安装了 <strong>CPU 版本</strong> 的 PyTorch（下载快，省资源）。</li>
<li>最后把当前这个项目（verl）安装好，准备开始测试。</li>
</ul>
</li>
</ul>
<h4>✅ 任务四：执行具体检查（Action!）</h4>
<p>这是最核心的部分，机器人开始拿着放大镜找茬了。每一个 <code>- name:</code> 都是一个检查项：</p>
<ol>
<li>
<p><strong>Run sanity test (运行健康测试)</strong></p>
<ul>
<li><code>pytest -s -x tests/special_sanity</code></li>
<li><strong>解释</strong>：运行 <code>tests/special_sanity</code> 文件夹里写好的所有测试脚本。如果有任何一个失败（<code>-x</code>），立刻停止，报错。</li>
</ul>
</li>
<li>
<p><strong>Run license test (检查许可证)</strong></p>
<ul>
<li><code>python3 .../check_license.py ...</code></li>
<li><strong>解释</strong>：检查所有文件是不是都加上了开源协议头（License Header）。</li>
</ul>
</li>
<li>
<p><strong>Assert naming convention (检查命名规范 - 这里的茬找得很有趣)</strong></p>
<ul>
<li><code>grep ... 'veRL' .</code></li>
<li><strong>解释</strong>：它在代码里搜索有没有人把项目名字写成了 <code>veRL</code>（大小写混用）。</li>
<li><strong>观点</strong>：项目组强制要求大家统一用 <code>verl</code>，写错了就报错，强迫症福音。</li>
</ul>
</li>
<li>
<p><strong>Assert SGLang naming convention (检查 SGLang 拼写)</strong></p>
<ul>
<li><code>grep ... -E 'Sglang|sgLang...'</code></li>
<li><strong>解释</strong>：同上，强制要求 <code>SGLang</code> 这个词的拼写必须规范，不能乱写大小写。</li>
</ul>
</li>
<li>
<p><strong>Validate test folder structure (检查文件夹结构)</strong></p>
<ul>
<li><strong>解释</strong>：运行脚本，确保开发者没有把测试文件乱放，必须遵守任务一里提到的目录规则。</li>
</ul>
</li>
<li>
<p><strong>Assert documentation... (检查文档)</strong></p>
<ul>
<li><strong>解释</strong>：检查函数是不是都写了文档说明（Docstring）。</li>
</ul>
</li>
<li>
<p><strong>Assert device api usage (检查设备 API 用法)</strong></p>
<ul>
<li><strong>解释</strong>：运行脚本扫描代码。这通常是为了防止开发者把代码写死（比如硬编码写死用 <code>cuda:0</code>），要确保代码能兼容不同的硬件。</li>
</ul>
</li>
<li>
<p><strong>Check docstrings / DataProto (其他杂项检查)</strong></p>
<ul>
<li><strong>解释</strong>：检查文档的时间信息、检查数据协议（DataProto）的使用是否规范。</li>
</ul>
</li>
</ol>
<hr />
<h3>💡 总结：这篇文章（文件）的核心观点</h3>
<p>如果把这个文件看作一个人，他就是一个<strong>极其严格的图书管理员</strong>。</p>
<ul>
<li><strong>他的观点是</strong>：“代码不仅要能跑通，长得还得漂亮、规范。”</li>
<li><strong>他的工作是</strong>：<ol>
<li>不管谁交了代码，先拦下来。</li>
<li>给他一台普通的电脑（CPU环境）。</li>
<li>检查拼写（veRL vs verl）。</li>
<li>检查版权声明。</li>
<li>检查文件有没有放对地方。</li>
<li>跑一遍最基础的测试题。</li>
<li><strong>只要有一项不合格，就打回重写，不准合并到主分支。</strong></li>
</ol>
</li>
</ul>
<p>这就是 <code>sanity.yml</code> （Sanity Check，健全性/理智检查）的全部含义。</p>