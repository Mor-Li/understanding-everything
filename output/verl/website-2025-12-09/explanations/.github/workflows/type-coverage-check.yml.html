<h1>.github/workflows/type-coverage-check.yml</h1>
<p>没问题，这个文件看起来像是一堆代码，但其实它是一个<strong>给机器人看的“自动化工作说明书”</strong>。</p>
<p>在程序员的世界里，这叫做 <strong>GitHub Actions Workflow</strong>（工作流）。它的作用是：当你修改了代码并提交时，GitHub 会自动启动一台虚拟电脑，按照这个清单一步步检查你的代码是否合格。</p>
<p>为了让你更容易理解，我把你（作为人类）和 GitHub（作为机器人）的交互过程拆解成一个 <strong>5步走的 Task List（任务清单）</strong>。</p>
<hr />
<h3>📝 学习任务清单 (To-Do List)</h3>
<h4>✅ Task 1: 搞清楚“我们在干什么？” (宏观概念)</h4>
<ul>
<li><strong>目标</strong>：理解这个文件的核心目的。</li>
<li><strong>解释</strong>：这个文件的目的是<strong>“代码质量检查”</strong>。它不检查代码逻辑对不对（比如 1+1 是否等于 2），而是检查代码<strong>写得规不规范</strong>。</li>
<li><strong>具体检查两件事</strong>：<ol>
<li><strong>类型注释 (Type Annotation)</strong>：你有没有告诉别人这个变量是整数还是字符串？(例如 <code>age: int</code>)</li>
<li><strong>文档字符串 (Docstring)</strong>：你有没有给函数写说明书？(例如 <code>def func(): """这里是说明"""</code>)</li>
</ol>
</li>
</ul>
<h4>✅ Task 2: 搞清楚“什么时候干活？” (触发条件)</h4>
<ul>
<li><strong>对应代码</strong>：
    <code>yaml
    on:
      pull_request:
        paths:
          - '**/*.py'
          - '.github/workflows/type-coverage-check.yml'</code></li>
<li><strong>解释</strong>：机器人很懒，不是每时每刻都干活。<ul>
<li><code>pull_request</code>: 只有当你有人提交代码合并请求（PR）的时候才触发。</li>
<li><code>paths</code>: 而且，只有当你修改了 <code>.py</code> (Python代码) 文件或者修改了这个检查清单本身时，它才动。如果你只是改了个这就说明书 <code>README.md</code>，它是不会理你的。</li>
</ul>
</li>
</ul>
<h4>✅ Task 3: 准备“干活的环境” (环境搭建)</h4>
<ul>
<li><strong>对应代码</strong>：
    <code>yaml
    jobs:
      type-coverage-check:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v4
            with:
              fetch-depth: 0
          - name: Set up Python
            uses: actions/setup-python@v5
            with:
              python-version: '3.10'</code></li>
<li><strong>解释</strong>：机器人需要一台电脑来跑代码。<ol>
<li><code>runs-on: ubuntu-latest</code>: 给我开一台最新的 Linux (Ubuntu) 虚拟机。</li>
<li><code>actions/checkout@v4</code>: 把你写的代码下载到这台虚拟机上。<ul>
<li><em>注意</em>：<code>fetch-depth: 0</code> 意思是“把所有的历史修改记录都下载下来”。这是为了方便对比新旧代码，看看你这次提交到底改了啥。</li>
</ul>
</li>
<li><code>Set up Python</code>: 在这台虚拟机上安装 Python 3.10 版本。</li>
</ol>
</li>
</ul>
<h4>✅ Task 4: 安装“干活的工具” (依赖安装)</h4>
<ul>
<li><strong>对应代码</strong>：
    ```yaml<ul>
<li>name: Install dependencies
  run: |
    pip3 install torch torchvision --index-url https://download.pytorch.org/whl/cpu
    pip3 install -r requirements.txt
    pip3 install -e . --no-deps
```</li>
</ul>
</li>
<li><strong>解释</strong>：光有 Python 不行，你的代码里可能用到了很多第三方库（比如 PyTorch）。<ol>
<li>安装 CPU 版本的 PyTorch（为了省流量和时间，因为检查代码格式不需要显卡）。</li>
<li><code>requirements.txt</code>: 安装项目必须的其他库。</li>
<li><code>pip3 install -e .</code>: 把当前这个项目安装好，这样测试脚本才能引用到项目里的代码。</li>
</ol>
</li>
</ul>
<h4>✅ Task 5: 开始“正式考试” (运行检查脚本)</h4>
<p>这是整个文件最重要的部分，前面的步骤都是为了这两步做铺垫。</p>
<ul>
<li>
<p><strong>考试科目一：类型覆盖率检查</strong>
    ```yaml</p>
<ul>
<li>name: Run type annotation coverage check
  run: |
    python3 tests/special_sanity/type_coverage_check.py
```</li>
<li><strong>解释</strong>：运行一个写好的 Python 脚本 <code>type_coverage_check.py</code>。</li>
<li><strong>目的</strong>：它会扫描你的代码，计算你有多少变量和函数写了类型提示。如果比例太低（比如没达到 80%），这个步骤就会报错，你的代码就合并不进去。</li>
</ul>
</li>
<li>
<p><strong>考试科目二：文档覆盖率检查</strong>
    ```yaml</p>
<ul>
<li>name: Run docstring coverage check
  run: |
    python3 tests/special_sanity/check_api_docs.py verl
```</li>
<li><strong>解释</strong>：运行另一个脚本 <code>check_api_docs.py</code>，检查 <code>verl</code> 这个文件夹下的代码。</li>
<li><strong>目的</strong>：它会看你公开的 API 函数有没有写文档说明。如果没有写，就会报错，逼着你去补文档。</li>
</ul>
</li>
</ul>
<hr />
<h3>🚀 总结 (Summary)</h3>
<p>把这个 YAML 文件翻译成人话就是：</p>
<blockquote>
<p><strong>给 GitHub 机器人的命令：</strong></p>
<p>只要有人提交了 Python 代码修改，你就帮我开一台 Linux 电脑，装好 Python 3.10 和 PyTorch。</p>
<p>然后，运行两个特定的 Python 脚本：
1.  看看他有没有偷懒不写<strong>类型标注</strong>。
2.  看看他有没有偷懒不写<strong>函数文档</strong>。</p>
<p>如果他偷懒了，就让任务失败（报错），别让他把代码合并进来！</p>
</blockquote>