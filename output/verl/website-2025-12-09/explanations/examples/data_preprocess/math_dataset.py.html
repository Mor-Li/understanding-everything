<h1>examples/data_preprocess/math_dataset.py</h1>
<p>这份代码其实就是一个<strong>“数据加工流水线”</strong>。</p>
<p>它的核心目标是：<strong>把原始的数学题库（MATH数据集），转换成大模型训练框架（Verl）能听懂、能使用的格式，并保存下来。</strong></p>
<p>为了让你彻底看懂，我列了一个 <strong>Task Todo List（任务清单）</strong>。我们可以把这段代码想象成一个厨师在备菜，每个步骤都是为了最后能下锅炒菜（训练模型）。</p>
<hr />
<h3>📋 Task Todo List (代码任务清单)</h3>
<ol>
<li><strong>准备工作 (Setup)</strong>：确定原材料在哪，做好的菜放哪。</li>
<li><strong>采购原材料 (Load Data)</strong>：从网上下载或本地读取原始的数学题库。</li>
<li><strong>制定处理标准 (Define Rules)</strong>：<ul>
<li>规定如何把复杂的解题步骤提炼成一个“标准答案”。</li>
<li>规定要给模型下达什么指令（Prompt）。</li>
</ul>
</li>
<li><strong>流水线加工 (Process Data)</strong>：把每一道题都拿出来，按照标准重新包装。</li>
<li><strong>打包入库 (Save Data)</strong>：把处理好的数据存成高效的格式（Parquet），并备份一份样本查看。</li>
</ol>
<hr />
<h3>🚀 逐步讲解 (Step-by-Step)</h3>
<h4>Task 1: 准备工作 (Setup)</h4>
<p><strong>代码位置</strong>：<code>if __name__ == "__main__":</code> 下面的 <code>argparse</code> 部分。</p>
<ul>
<li><strong>讲了啥</strong>：这部分代码在处理“命令行参数”。当你运行这个脚本时，你可以告诉它：<ul>
<li><code>--local_dataset_path</code>: 如果你电脑里已经下载了数据，告诉它路径在哪。</li>
<li><code>--local_save_dir</code>: 处理完的数据存到哪里（默认是 <code>~/data/math</code>）。</li>
<li><code>--hdfs_dir</code>: (可选) 如果你要上传到公司的云存储（HDFS），地址是什么。</li>
</ul>
</li>
</ul>
<h4>Task 2: 采购原材料 (Load Data)</h4>
<p><strong>代码位置</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="n">data_source</span> <span class="o">=</span> <span class="s2">&quot;DigitalLearningGmbH/MATH-lighteval&quot;</span>
<span class="c1"># ...</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_dataset</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li>代码指定了一个 HuggingFace 上的数据集仓库：<code>DigitalLearningGmbH/MATH-lighteval</code>。这是因为原始的 MATH 数据集链接失效了，所以用了一个镜像版。</li>
<li>它把数据分成了 <code>train</code> (训练集) 和 <code>test</code> (测试集)。</li>
<li><strong>观点</strong>：数据是训练的燃料，这里确保燃料来源是高质量的高中数学竞赛题。</li>
</ul>
</li>
</ul>
<h4>Task 3: 制定处理标准 (Define Rules)</h4>
<p>这是代码里比较关键的逻辑部分。</p>
<p><strong>A. 提取标准答案</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_solution</span><span class="p">(</span><span class="n">solution_str</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">remove_boxed</span><span class="p">(</span><span class="n">last_boxed_only_string</span><span class="p">(</span><span class="n">solution_str</span><span class="p">))</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：原始数据里的 <code>solution</code> 是一大段解题过程。</li>
<li><strong>观点</strong>：为了让机器知道它做对没，我们需要提取最终答案。在数学竞赛题（LaTeX格式）中，最终答案通常放在 <code>\boxed{答案}</code> 里面。这个函数的作用就是<strong>把框里的答案抠出来</strong>，作为 <code>ground_truth</code>（标准答案）。</li>
</ul>
<p><strong>B. 设定指令 (Prompt Engineering)</strong></p>
<div class="codehilite"><pre><span></span><code><span class="n">instruction_following</span> <span class="o">=</span> <span class="s2">&quot;Let&#39;s think step by step and output the final answer within </span><span class="se">\\</span><span class="s2">boxed</span><span class="si">{}</span><span class="s2">.&quot;</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：这是给 AI 的额外命令。</li>
<li><strong>观点</strong>：不仅要给 AI 题目，还要强制它使用 <strong>“思维链” (CoT, Chain of Thought)</strong>。<ul>
<li><code>Let's think step by step</code>: 强迫 AI 一步步推理，能提高准确率。</li>
<li><code>output within \boxed{}</code>: 强迫 AI 按照特定格式输出，方便我们后续用代码自动判断它对不对。</li>
</ul>
</li>
</ul>
<h4>Task 4: 流水线加工 (Process Data)</h4>
<p><strong>代码位置</strong>：<code>make_map_fn</code> 函数 和 <code>dataset.map(...)</code>。</p>
<ul>
<li>
<p><strong>讲了啥</strong>：这是最核心的“包装”过程。它把每一条原始数据变成了如下的新格式：</p>
<ul>
<li><strong>User Prompt (题目)</strong>:  <code>原始题目</code> + <code>空格</code> + <code>Task 3设定的指令</code>。</li>
<li><strong>Reward Model (判卷标准)</strong>: 包含 <code>ground_truth</code> (刚才抠出来的标准答案)。</li>
<li><strong>Data Source</strong>: 标记数据来源。</li>
<li><strong>Ability</strong>: 标记这是 "math" 能力的数据。</li>
</ul>
</li>
<li>
<p><strong>代码转换示例</strong>：</p>
<ul>
<li><strong>原始</strong>：<code>{"problem": "1+1=?", "solution": "The answer is \boxed{2}"}</code></li>
<li><strong>加工后</strong>：
    <code>json
    {
        "prompt": [{"role": "user", "content": "1+1=? Let's think step by step..."}],
        "reward_model": {"style": "rule", "ground_truth": "2"},
        "ability": "math"
    }</code></li>
</ul>
</li>
<li><strong>观点</strong>：这个格式是 <strong>Verl 训练框架</strong> 规定的标准输入格式。如果不转成这样，后续的强化学习（RL）算法就跑不起来。</li>
</ul>
<h4>Task 5: 打包入库 (Save Data)</h4>
<p><strong>代码位置</strong>：最后几行 <code>to_parquet</code> 和 <code>json.dump</code>。</p>
<ul>
<li><strong>讲了啥</strong>：<ol>
<li><strong>存为 Parquet</strong>：<code>train.parquet</code>, <code>test.parquet</code>。Parquet 是一种压缩率高、读取速度极快的文件格式，适合大数据训练。</li>
<li><strong>存个 JSON 样本</strong>：<code>train_example.json</code>。这是给人看的。万一代码写错了，你打开这个小文件一眼就能看出来格式对不对，不用去解压巨大的 Parquet 文件。</li>
<li><strong>上传 HDFS</strong>：如果配置了云存储，就把做好的文件传上去。</li>
</ol>
</li>
</ul>
<hr />
<h3>💡 总结文中的核心观点</h3>
<p>这个脚本不涉及复杂的算法，它的核心观点是 <strong>“数据标准化”</strong>：</p>
<ol>
<li><strong>清洗 (Cleaning)</strong>：从长篇大论的解题过程中，精准提取出唯一的数字/公式作为标准答案。</li>
<li><strong>提示工程 (Prompting)</strong>：在预处理阶段就固化好 Prompt，强制模型在训练时学会“分步思考”和“按格式输出”。</li>
<li><strong>适配 (Formatting)</strong>：将通用的开源数据，转化为特定训练框架（Verl）所需的 JSON/Parquet 结构。</li>
</ol>