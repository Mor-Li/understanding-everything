<h1>examples/tutorial/agent_loop_get_started/sandbox.py</h1>
<p>这段代码确实涉及了一些比较具体的概念（比如异步编程、API调用、Prompt工程），直接看容易晕。</p>
<p>简单来说，这段代码定义了一个<strong>工具（Tool）</strong>，这个工具是给<strong>AI（比如ChatGPT这样的模型）</strong> 用的。它的功能是：<strong>让AI能够在一个安全的沙盒环境里运行Python代码，并拿到运行结果。</strong></p>
<p>我们可以把编写这个文件想象成你在完成一个项目，我把这个项目拆解成 <strong>6个待办任务（Todo List）</strong>，带你一步步看懂它是怎么实现的。</p>
<hr />
<h3>📝 项目目标：做一个“代码执行器”插件给AI用</h3>
<h4>✅ Task 1: 建立连接通道 (怎么让代码跑起来？)</h4>
<p><strong>目标</strong>：我们需要一个函数，能把代码发给远程服务器运行，然后把结果拿回来。
<strong>对应代码</strong>：<code>async def code_interpreter(self, code: str) -&gt; str:</code></p>
<ul>
<li><strong>原理解析</strong>：<ul>
<li>本地电脑通常不直接运行AI写的代码（怕有毒、怕死循环），所以要发给一个外部的“沙盒”（Sandbox）去跑。</li>
<li>这段代码用 <code>aiohttp</code>（一个发网络请求的库）向 <code>sandbox_fusion_url</code> 发送了一个 POST 请求。</li>
<li>发送的内容是 <code>{"code": code}</code>。</li>
<li>收到的结果里包含了 <code>stdout</code>（标准输出，即print的内容）和 <code>stderr</code>（错误信息）。最后把这两个拼起来返回。</li>
</ul>
</li>
</ul>
<h4>✅ Task 2: 告诉AI怎么用这个工具 (写说明书)</h4>
<p><strong>目标</strong>：AI不知道你有一个“代码执行器”，你需要把这个函数的“说明书”格式化发给AI。
<strong>对应代码</strong>：<code>def get_openai_tool_schema(self) -&gt; OpenAIFunctionToolSchema:</code></p>
<ul>
<li><strong>原理解析</strong>：<ul>
<li><code>get_json_schema(self.code_interpreter)</code> 这一行非常省事，它自动读取 Task 1 中写的函数定义，自动生成一份 JSON 格式的说明书。</li>
<li>这份说明书会告诉AI：“我有一个工具叫 <code>code_interpreter</code>，它需要一个参数叫 <code>code</code>，是字符串类型的。”</li>
</ul>
</li>
</ul>
<h4>✅ Task 3: 准备“剥壳”工具 (处理AI的坏习惯)</h4>
<p><strong>目标</strong>：AI写代码时喜欢用 Markdown 格式（就是被 ```py 和 ``` 包裹起来），我们需要把这些装饰去掉，只留代码。
<strong>对应代码</strong>：
1. <code>self.code_pattern = re.compile(r"```py(.*?)```", re.DOTALL)</code> (在 <code>__init__</code> 里)
2. <code>matches = self.code_pattern.findall(code)</code> (在 <code>execute</code> 里)</p>
<ul>
<li><strong>原理解析</strong>：<ul>
<li>这里用正则表达式（Regex）定义了一个规则：只提取 <code>py` 和</code> 之间的内容。</li>
<li>如果不做这一步，直接把带有 Markdown 符号的文本发给沙盒，程序会报错。</li>
</ul>
</li>
</ul>
<h4>✅ Task 4: 帮AI“补全”代码 (关键的补丁逻辑)</h4>
<p><strong>目标</strong>：有时候AI写代码只写计算逻辑（比如 <code>1 + 1</code>），却忘了写 <code>print</code>。如果不打印，沙盒运行完什么都不返回，AI就不知道结果了。我们需要自动帮它加上 <code>print()</code>。
<strong>对应代码</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="n">lines</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">))):</span>
    <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="k">continue</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;print&quot;</span><span class="p">):</span>
        <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;print(</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">)&quot;</span>  <span class="c1"># 强制加上 print</span>
    <span class="k">break</span>
</code></pre></div>

<ul>
<li><strong>原理解析</strong>：<ul>
<li>这段逻辑很“鸡贼”。它把代码按行切分，从最后一行往回找。</li>
<li>找到最后一行有内容的代码，检查它是不是以 <code>print</code> 开头。</li>
<li>如果不是（比如是 <code>a + b</code>），就把它改成 <code>print(a + b)</code>。</li>
<li><strong>为什么这么做？</strong> 代码里的注释写了：最好的办法是训练模型让它自己学会print，但在这个教程里为了省事，直接用代码强行补上。</li>
</ul>
</li>
</ul>
<h4>✅ Task 5: 整合流程 (执行入口)</h4>
<p><strong>目标</strong>：把上面所有的步骤串起来，变成一个主函数供系统调用。
<strong>对应代码</strong>：<code>async def execute(self, instance_id: str, parameters: dict, **kwargs)</code></p>
<ul>
<li><strong>原理解析</strong>：<ul>
<li>这是 <code>BaseTool</code> 要求的标准接口。</li>
<li><strong>步骤 A</strong>: 从参数里拿到原始代码 <code>code = parameters["code"]</code>。</li>
<li><strong>步骤 B</strong>: 执行 Task 3（用正则去壳）。</li>
<li><strong>步骤 C</strong>: 执行 Task 4（自动加 print）。</li>
<li><strong>步骤 D</strong>: 执行 Task 1（发给沙盒运行）。</li>
<li><strong>步骤 E</strong>: 把结果包装成 <code>ToolResponse</code> 返回给 AI。</li>
</ul>
</li>
</ul>
<h4>✅ Task 6: 定义身份 (类初始化)</h4>
<p><strong>目标</strong>：把这个类起个名字，继承基本工具类。
<strong>对应代码</strong>：<code>class SandboxTool(BaseTool):</code></p>
<ul>
<li><strong>原理解析</strong>：<ul>
<li>这就是标准的 Python 类定义，继承自 <code>BaseTool</code>，表示它是一个符合 verl 框架规范的工具。</li>
</ul>
</li>
</ul>
<hr />
<h3>总结一下它的工作流</h3>
<p>当 AI 决定要写代码时，流程是这样的：</p>
<ol>
<li><strong>AI 说</strong>：我要用 <code>SandboxTool</code>，参数是 <code>code="```py\nx=5\ny=6\nx*y```"</code>。</li>
<li><strong><code>execute</code> 函数接收请求</strong>。</li>
<li><strong>正则处理</strong>：去掉 markdown 符号，变成 <code>x=5\ny=6\nx*y</code>。</li>
<li><strong>自动补全</strong>：发现最后一行 <code>x*y</code> 没打印，自动改成 <code>print(x*y)</code>。</li>
<li><strong>发送请求</strong>：把代码发给沙盒服务器。</li>
<li><strong>沙盒返回</strong>：<code>"30"</code>。</li>
<li><strong>返回给 AI</strong>：结果是 30。</li>
</ol>
<p>现在再回头看代码，是不是清晰很多了？</p>