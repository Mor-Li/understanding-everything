<h1>tests/utils/reward_score/reward_score/test_sandbox_fusion_on_cpu.py</h1>
<p>这份代码文件 <code>test_sandbox_fusion_on_cpu.py</code> 是一个<strong>测试套件（Test Suite）</strong>。</p>
<p>它的核心目的是测试一个名为 <code>check_correctness</code> 的函数。这个函数的作用是：<strong>把一段代码（通常是AI生成的）和一些输入数据，发送到一个安全的沙盒环境（Sandbox）中去运行，然后检查运行结果是否正确。</strong></p>
<p>你可以把它想象成在测试一个 <strong>“判题系统”</strong>（类似 LeetCode 或 牛客网的后台判题机）。</p>
<p>为了让你看懂，我把它拆解成三个部分：<strong>核心概念</strong>、<strong>任务清单（ToDo List）</strong>、<strong>详细步骤解读</strong>。</p>
<hr />
<h3>1. 核心概念：这文件在干嘛？</h3>
<p>这个文件在验证 <code>check_correctness</code> 这个工具是否靠谱。它主要关心以下几个问题：
1.  <strong>基本功能</strong>：代码写对了能判对吗？写错了能判错吗？
2.  <strong>错误处理</strong>：代码死循环了怎么办？编译报错了怎么办？
3.  <strong>高并发（压力测试）</strong>：如果一瞬间来了100个判题请求，系统会不会崩？结果会不会乱？
4.  <strong>资源控制</strong>：为了防止CPU爆炸，有没有限制同时运行的任务数量？</p>
<hr />
<h3>2. 任务清单 (Task ToDo List)</h3>
<p>如果你是这个文件的作者，你的开发逻辑（ToDo List）是这样的：</p>
<ul>
<li><strong>[准备工作]</strong> 定义各种测试用的“假代码”：<ul>
<li>✅ 写一段完全正确的代码。</li>
<li>❌ 写一段能运行但输出错误的代码。</li>
<li>🚫 写一段语法错误（编译不过）的代码。</li>
<li>💥 写一段运行时崩溃（Runtime Error）的代码。</li>
<li>⏳ 写一段死循环（超时）的代码。</li>
</ul>
</li>
<li><strong>[集成测试 - 连真环境]</strong> 连接真实的沙盒 API 进行测试：<ul>
<li>测试“正确”的情况。</li>
<li>测试“答案错误”的情况。</li>
<li>测试“编译/运行错误/超时”的情况。</li>
<li>测试 <strong>高并发</strong>（比如同时发100个请求），确保结果依然准确，没有串号。</li>
</ul>
</li>
<li><strong>[单元测试 - 连假环境]</strong> Mock（模拟）API 进行测试：<ul>
<li>测试当网络不稳定或API报错时，程序是否健壮。</li>
<li>测试输入数据格式不对时，是否抛出正确的错误信息。</li>
</ul>
</li>
<li><strong>[进阶测试 - 多进程控制]</strong>：<ul>
<li>测试<strong>全局并发限制</strong>（Semaphore/信号量）。确保即使开启多个进程，同时请求沙盒的数量也不会超过设定的阈值（防止把服务器打挂）。</li>
</ul>
</li>
<li><strong>[特殊格式测试]</strong>：<ul>
<li>测试 LeetCode 风格的代码（指定函数名 <code>fn_name</code> 而不是标准输入输出）。</li>
<li>测试 <code>assert</code> 断言风格的测试用例。</li>
</ul>
</li>
</ul>
<hr />
<h3>3. 逐步解读文中的观点（代码逻辑）</h3>
<p>下面我按照文件内容的顺序，一步步给你讲它在测什么：</p>
<h4>第一步：准备素材 (Test Code Definitions)</h4>
<p>代码开头定义了一堆字符串变量（如 <code>CODE_SUCCESS</code>, <code>CODE_TIMEOUT</code>）。
*   <strong>观点</strong>：为了测试判题机，我得先准备好各种“样本”。既要有好学生（正确代码），也要有坏学生（死循环、报错的代码）。</p>
<h4>第二步：真实环境的基础测试 (Integration Tests)</h4>
<p>从 <code>test_integration_success_correct</code> 到 <code>test_integration_runtime_timeout</code>。
*   <strong>观点</strong>：最基本的功能必须跑通。
    *   如果代码输出 <code>output1</code>，判题机必须返回 <code>True</code> 和 <code>success</code>。
    *   如果代码输出 <code>wrong</code>，判题机必须返回 <code>False</code> 和 <code>wrong_answer</code>。
    *   如果代码写了 <code>a=b</code>（语法错），判题机必须识别出 <code>compile_error</code>。
    *   如果代码 <code>sleep(10)</code> 但限制只给 5秒，判题机必须报 <code>timeout</code>。</p>
<h4>第三步：真实环境的压力测试 (Concurrency High Load)</h4>
<p>函数 <code>test_integration_concurrency_high_load</code>。
*   <strong>观点</strong>：判题系统必须能处理“大量并发”。
*   <strong>做法</strong>：
    1.  生成 100 个任务。
    2.  故意混杂一些会超时的、会算错的、会算对的任务。
    3.  <strong>同时</strong>扔给判题机。
    4.  <strong>检查</strong>：结果的数量对不对？顺序乱没乱？（比如第5个任务是超时的，结果列表里第5个必须是超时）。</p>
<h4>第四步：单元测试与模拟 (Unit Tests with Mock)</h4>
<p>函数 <code>test_unit_concurrency_order</code> 和 <code>test_unit_api_timeout_error_concurrent</code>。
*   <strong>观点</strong>：有些极端网络情况很难在真实环境复现，我们用 Mock（替身/模拟器）来测。
*   <strong>细节</strong>：
    *   即使第2个任务处理得很慢，第1个和第3个很快，最终返回的结果列表顺序也必须是 <code>[结果1, 结果2, 结果3]</code>，不能乱序。
    *   如果 API 突然报 <code>504 Gateway Timeout</code>，程序不能崩，要记录下 <code>api_error</code>。</p>
<h4>第五步：多进程并发控制 (The Complex Part)</h4>
<p>函数 <code>test_multiprocess_global_concurrency_limit_with_semaphore</code>。这是全篇最难懂的地方。
*   <strong>背景</strong>：Python 的多进程（Multiprocessing）如果大家都在疯狂发请求，可能会把沙盒服务器冲垮。
*   <strong>观点</strong>：我们需要一个“红绿灯”（Semaphore/信号量）来限制<strong>全局</strong>同时进行的请求数。
*   <strong>做法</strong>：
    1.  设定限制：比如全系统最多只允许 5 个并发请求。
    2.  启动 4 个进程，每个进程里又有 3 个线程试图发请求（总共12个请求）。
    3.  <strong>监控</strong>：在任何一个时间点，正在进行的请求数有没有超过 5 个？
    4.  <strong>结论</strong>：如果最大观测值 &lt;= 5，说明限流成功。</p>
<h4>第六步：特殊场景与格式检查</h4>
<p>函数 <code>test_fn_name_success_single_case</code> 和 <code>test_assert_case_success</code>。
*   <strong>观点</strong>：现在的代码生成不仅仅是读写 <code>stdin/stdout</code>（ACM模式），还有像 LeetCode 那样只写一个函数的（核心代码模式），或者用 <code>assert</code> 语句来验证的。
*   <strong>做法</strong>：测试系统是否支持解析 <code>fn_name</code>（函数名）并正确执行，以及是否能处理 Python 的 <code>assert</code> 语句作为判题依据。</p>
<h3>总结</h3>
<p>这个文件就是一个<strong>质检员</strong>。它在说：</p>
<blockquote>
<p>“我要确保这个代码评分工具（Reward Score / Sandbox Fusion），无论是面对好代码、烂代码、网络故障，还是成百上千的并发请求，都能<strong>准确、稳定、有序</strong>地给出评分结果，而且不会因为请求太多把机器跑挂。”</p>
</blockquote>