<h1>tests/special_sanity/check_pr_description.py</h1>
<p>这个脚本是一个<strong>自动化检查工具</strong>（通常用于 GitHub Actions 的 CI/CD 流程中）。</p>
<p>它的核心目的是：<strong>防止开发者在提交代码合并请求（Pull Request/PR）时偷懒，直接使用默认模版而不填写具体的修改内容。</strong></p>
<p>这就好比老师发了一张填空题试卷（模版），如果学生交上来的卷子前几行跟空卷子一模一样，老师就认为学生没做题，直接打回。</p>
<p>下面我按照你的要求，把这个脚本的工作流程拆解成一个 <strong>Task To-Do List</strong>，一步步带你看它是怎么工作的。</p>
<hr />
<h3>🤖 脚本执行任务清单 (Task To-Do List)</h3>
<h4>1. 准备工作：确定位置</h4>
<ul>
<li>[ ] <strong>任务 1：</strong> 确认当前运行环境里有没有设置 <code>GITHUB_EVENT_PATH</code> 这个环境变量。<ul>
<li><em>目的：</em> 这是一个指向 JSON 文件的路径，里面存着这次 PR 的所有信息（比如是谁提交的、内容是啥）。如果没有这个路径，脚本就报错罢工。</li>
</ul>
</li>
<li>[ ] <strong>任务 2：</strong> 确定“标准答案”（模版文件）在哪里。<ul>
<li><em>代码逻辑：</em> 默认在 <code>.github/PULL_REQUEST_TEMPLATE.md</code>。</li>
</ul>
</li>
</ul>
<h4>2. 获取“标准答案” (Template)</h4>
<ul>
<li>[ ] <strong>任务 3：</strong> 打开模版文件，<strong>只读取前 5 行</strong>。<ul>
<li><em>代码逻辑：</em> 对应 <code>load_template</code> 函数。它把这 5 行文字读出来，去掉首尾空格，存到一个列表里。</li>
<li><em>为什么是前 5 行？</em> 因为通常模版的开头都是固定的标题，比如 <code>### What does this PR do?</code>。</li>
</ul>
</li>
</ul>
<h4>3. 获取“考生答卷” (PR Body)</h4>
<ul>
<li>[ ] <strong>任务 4：</strong> 打开 <code>GITHUB_EVENT_PATH</code> 指向的 JSON 文件，找到 <code>pull_request</code> -&gt; <code>body</code> 字段。<ul>
<li><em>代码逻辑：</em> 对应 <code>load_pr_body</code> 函数。这个字段就是开发者在网页上填写的“PR 描述”内容。</li>
</ul>
</li>
</ul>
<h4>4. 核心检查：比对查重</h4>
<ul>
<li>[ ] <strong>任务 5：</strong> 把开发者的“答卷”（PR Body）也切分成行，并提取<strong>前 5 行</strong>。</li>
<li>[ ] <strong>任务 6：</strong> <strong>【关键步骤】</strong> 对比“标准答案”（模版前5行）和“考生答卷”（PR前5行）。<ul>
<li><strong>情况 A：完全一样。</strong><ul>
<li><em>判断：</em> 开发者根本没改模版开头的文字，直接提交了。</li>
<li><em>动作：</em> <strong>报错 (Raise Error)</strong>。抛出 <code>PRDescriptionError</code>，并提示：“看起来你没更新 'What does this PR do?' 部分，请填写具体内容。”</li>
</ul>
</li>
<li><strong>情况 B：不一样。</strong><ul>
<li><em>判断：</em> 开发者修改了开头的内容（或者把模版删了写了自己的话），说明填过了。</li>
<li><em>动作：</em> <strong>通过 (Pass)</strong>。打印出两者的内容供调试，然后继续。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>5. 结束</h4>
<ul>
<li>[ ] <strong>任务 7：</strong> 如果前面没报错，打印一行绿色的成功信息：<code>✅ '### What does this PR do?' section has been filled out.</code>，脚本成功退出。</li>
</ul>
<hr />
<h3>📝 代码与观点的对应讲解</h3>
<p>现在如果你回头看代码，就能对应上了：</p>
<ol>
<li>
<p><strong><code>NUM_LINES = 5</code></strong></p>
<ul>
<li><strong>观点：</strong> 不需要检查整篇文章，只要检查前 5 行。如果前 5 行跟模版一模一样，那大概率就是没改。</li>
</ul>
</li>
<li>
<p><strong><code>load_template(path)</code></strong></p>
<ul>
<li><strong>观点：</strong> 这是在读取“空试卷”的样子。它用了 <code>strip()</code> 来忽略空格的差异。</li>
</ul>
</li>
<li>
<p><strong><code>check_pr_description(body, template_lines)</code></strong></p>
<ul>
<li>这是核心裁判。</li>
<li>代码段：
    <code>python
    if pr_first == template_lines:
        raise PRDescriptionError(...)</code></li>
<li><strong>观点：</strong> 如果<strong>用户写的前几行</strong> == <strong>模版的前几行</strong>，那就是违规操作，必须阻止合并代码。</li>
</ul>
</li>
</ol>
<h3>总结</h3>
<p>这个脚本就是一个<strong>“防偷懒守门员”</strong>。它强迫开发者把 PR 模版里的默认提示文字（比如“请在这里描述你的修改...”）删掉或改写，确保每个代码提交都有真实的描述信息。</p>