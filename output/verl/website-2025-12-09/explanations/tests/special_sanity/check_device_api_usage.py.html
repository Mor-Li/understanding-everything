<h1>tests/special_sanity/check_device_api_usage.py</h1>
<p>这份代码其实是一个 <strong>“代码合规性检查员”</strong>（Sanity Check）。</p>
<p>它的核心目的是：<strong>防止开发者在代码里直接把硬件写死成 NVIDIA 的显卡（CUDA）</strong>。</p>
<p>为了让代码能在不同硬件（比如 AMD 显卡、TPU 等）上运行，项目规定：<strong>不要直接写 <code>cuda</code> 或 <code>nccl</code>，而应该用项目封装好的通用工具 <code>verl/utils/device.py</code>。</strong></p>
<p>为了帮你理解，我把它拆解成一个 <strong>“安检员的工作清单（Todo List）”</strong>，每一步对应代码里的逻辑：</p>
<h3>📋 安检员的任务清单 (Task Todo List)</h3>
<h4>✅ Task 1: 确定检查范围 (接收参数)</h4>
<ul>
<li><strong>代码位置</strong>: <code>if __name__ == "__main__":</code> 下的 <code>parser</code> 部分。</li>
<li><strong>动作</strong>: 脚本启动时，安检员会问：“今天要查哪个文件夹？”</li>
<li><strong>解释</strong>: 通过命令行参数 <code>--directory</code> 获取要检查的代码目录路径。</li>
</ul>
<h4>✅ Task 2: 收集目标文件 (遍历文件)</h4>
<ul>
<li><strong>代码位置</strong>: <code>pathlist = Path(directory_in_str).glob("**/*.py")</code></li>
<li><strong>动作</strong>: 安检员走进那个文件夹，把里面所有的 <code>.py</code> (Python 源代码) 文件列成一张清单。</li>
<li><strong>解释</strong>: 它只关心 Python 代码文件，忽略其他类型的文件。</li>
</ul>
<h4>✅ Task 3: 排除“特权”文件 (检查白名单)</h4>
<ul>
<li><strong>代码位置</strong>: <code>for sw in SEARCH_WHITELIST:</code> ... <code>if path_in_whitelist: continue</code></li>
<li><strong>动作</strong>: 安检员拿着一张“VIP 白名单”（<code>CUDA_KEYWORD_CHECK_WHITELIST</code> 和 <code>NCCL_KEYWORD_CHECK_WHITELIST</code>），对着手里的文件逐个核对：<ul>
<li>“这个文件在白名单上吗？”</li>
<li><strong>如果是</strong>: “行，你是特权文件（通常是底层工具或配置文件），允许你直接操作 CUDA，<strong>跳过检查</strong>。”</li>
<li><strong>如果不是</strong>: “你不是特权文件，必须接受检查。”</li>
</ul>
</li>
<li><strong>解释</strong>: 有些底层文件必须直接调用 CUDA 接口，所以要在检查中豁免掉。</li>
</ul>
<h4>✅ Task 4: 搜身 (内容扫描)</h4>
<ul>
<li><strong>代码位置</strong>: <code>with open(path_in_str...</code> 和 <code>for sk in SEARCH_KEYWORDS:</code></li>
<li><strong>动作</strong>: 对于没在白名单里的文件，安检员打开文件内容，开始逐行扫描，寻找 <strong>“违禁词”</strong>。</li>
<li><strong>违禁词列表</strong>:<ol>
<li><code>.cuda</code> (例如 <code>tensor.cuda()</code>)</li>
<li><code>"cuda"</code> (字符串形式)</li>
<li><code>"nccl"</code> (通信后端)</li>
</ol>
</li>
</ul>
<h4>✅ Task 5: 判决 (报错或通过)</h4>
<ul>
<li><strong>代码位置</strong>: <code>assert not find_invalid_device_management</code></li>
<li><strong>动作</strong>:<ul>
<li><strong>情况 A (发现违禁词)</strong>: 安检员大喊：“<strong>Failed!</strong> 抓到了！你在文件里写了 <code>.cuda</code>！请回去重写，改用 <code>verl/utils/device.py</code> 里的通用写法！” -&gt; <strong>程序报错退出，测试不通过。</strong></li>
<li><strong>情况 B (没发现)</strong>: 安检员说：“<strong>Success</strong>，文件很干净，符合规范。” -&gt; <strong>继续检查下一个文件。</strong></li>
</ul>
</li>
</ul>
<hr />
<h3>总结：这段代码想告诉你什么？</h3>
<p>如果你在提交代码时（CI 流程中）被这个脚本拦住了，说明：</p>
<ol>
<li>你写的代码里出现了 <code>.cuda</code> 或者 <code>"cuda"</code> 这种字眼。</li>
<li>你的文件不在“白名单”里。</li>
<li><strong>你需要修改代码</strong>：不要直接写 <code>.cuda()</code>，去看看 <code>verl/utils/device.py</code>，用那里面的方法来代替（比如用 <code>device_mesh</code> 或者统一的 <code>device</code> 变量）。</li>
</ol>
<p><strong>一句话概括：</strong> 这是一个自动化的“代码警察”，强迫大家写出兼容性更好、不绑定特定硬件的代码。</p>