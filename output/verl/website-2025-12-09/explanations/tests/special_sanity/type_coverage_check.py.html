<h1>tests/special_sanity/type_coverage_check.py</h1>
<p>这份代码其实是一个<strong>代码质量检查工具</strong>，专门用来检查 Python 代码中是否写了<strong>类型注解（Type Annotations）</strong>。</p>
<p>简单来说，它的作用就像一个“阅卷老师”，检查你提交的代码里，函数有没有乖乖写上 <code>x: int</code> 或者 <code>-&gt; str</code> 这样的类型提示。</p>
<p>为了让你更容易理解，我把它拆解成一个 <strong>“阅卷老师的工作清单（To-Do List）”</strong>，一步步带你看它是怎么工作的：</p>
<hr />
<h3>📋 阅卷老师的工作清单 (Task List)</h3>
<h4>Task 1: 确定要检查哪些作业（确定文件范围）</h4>
<p><strong>代码逻辑：</strong> <code>get_changed_files()</code> 和 <code>argparse</code> 部分
*   <strong>老师的想法：</strong> “我不能把全校几年前的作业都检查一遍，太累了。我只检查<strong>你今天新修改或新提交</strong>的文件。”
*   <strong>具体操作：</strong>
    *   工具会运行 <code>git diff</code> 命令，找出你最近修改过的 <code>.py</code> 文件。
    *   <em>例外情况：</em> 如果你在命令行加了 <code>--target-file</code>，它就只查你指定的那个文件。
    *   <em>例外情况：</em> 凡是 <code>tests/</code> 目录下的测试文件，它都不查（通常测试代码要求没那么严）。</p>
<h4>Task 2: 确定要检查哪几行字（确定行号范围）</h4>
<p><strong>代码逻辑：</strong> <code>get_changed_lines()</code>
*   <strong>老师的想法：</strong> “即使在这个文件里，没改动的旧代码我也不管，我只盯着你<strong>新增或修改的那几行代码</strong>。”
*   <strong>具体操作：</strong>
    *   再次利用 <code>git diff</code>，精确到行号。比如你只改了第 10 到 20 行，那它只检查这几行里有没有定义新函数。
    *   <em>例外情况：</em> 如果你加了 <code>--all-lines</code> 参数，它就会检查整个文件的每一行。</p>
<h4>Task 3: 开始语法分析（阅读代码结构）</h4>
<p><strong>代码逻辑：</strong> <code>check_file()</code> 和 <code>ast.parse()</code>
*   <strong>老师的想法：</strong> “我不是去‘运行’你的代码，而是把你的代码当成文章来‘阅读’结构（语法树）。”
*   <strong>具体操作：</strong>
    *   它使用 Python 自带的 <code>ast</code> 库，把代码解析成树状结构。它能认出哪里是函数定义（<code>FunctionDef</code>），哪里是赋值语句。</p>
<h4>Task 4: 执行评分标准（核心检查规则）</h4>
<p><strong>代码逻辑：</strong> <code>has_type_annotations()</code> <strong>(这是最核心的部分)</strong>
*   <strong>老师的想法：</strong> “我要看看你的函数定义合不合格。”
*   <strong>评分标准（必须满足）：</strong>
    1.  <strong>输入参数要有类型：</strong> 比如 <code>def add(a: int, b: int)</code> 里的 <code>: int</code>。
    2.  <strong>返回值要有类型：</strong> 比如 <code>-&gt; int</code>。
*   <strong>豁免权（这些情况不算错）：</strong>
    1.  <strong>私有方法：</strong> 名字以 <code>_</code> 开头的函数（如 <code>_process</code>）可以不写。
    2.  <strong>特殊参数：</strong> <code>self</code>、<code>cls</code>、<code>*args</code>、<code>**kwargs</code> 这些参数不用写类型。</p>
<h4>Task 5: 统计分数与反馈（计算覆盖率）</h4>
<p><strong>代码逻辑：</strong> <code>main()</code> 函数后半部分
*   <strong>老师的想法：</strong> “查完了，我来算算你及格没。”
*   <strong>具体操作：</strong>
    *   它会统计一共检查了多少个相关的节点（<code>total_changed</code>），其中有多少个是合格的（<code>total_annotated</code>）。
    *   计算公式：<strong>合格数 / 总数 = 覆盖率 (Ratio)</strong>。
    *   如果发现有函数没写类型，它会把文件名、行号、代码内容打印出来，并在前面标上 <code>⚠️</code> 或 <code>❌</code>。</p>
<h4>Task 6: 决定是否让你通过（阈值判断）</h4>
<p><strong>代码逻辑：</strong> <code>if ratio &lt; args.threshold:</code>
*   <strong>老师的想法：</strong> “你的及格线是 30%（默认值）。”
*   <strong>最终结果：</strong>
    *   如果覆盖率低于 <strong>0.3 (30%)</strong>，脚本会报错（<code>raise Exception</code>），导致你的代码提交或测试流程失败。
    *   如果高于 30%，打印 <code>✅ Type annotation coverage acceptable.</code>，恭喜你通过。</p>
<hr />
<h3>总结</h3>
<p>这个脚本就是一个<strong>强制你写 Python 类型注解的自动化工具</strong>。它主要用于 CI/CD（自动化测试）流程中，防止开发者偷懒，写出没有类型提示的代码，从而保证代码的可读性和质量。</p>
<p><strong>如果你运行它报错了，你需要做的就是：</strong>
找到报错提示的那几行代码，给函数参数加上 <code>: 类型</code>，给函数结尾加上 <code>-&gt; 类型</code>。</p>