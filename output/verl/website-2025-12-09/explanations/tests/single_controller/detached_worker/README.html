<h1>tests/single_controller/detached_worker</h1>
<p>这个文件夹 <code>tests/single_controller/detached_worker</code> 是用来测试 <strong>Verl 框架</strong>在 <strong>Ray 分布式系统</strong>下的一种特殊“骚操作”能力的：<strong>“分离模式” (Detached Mode)</strong>。</p>
<p>为了让你秒懂，我们用<strong>“网吧”</strong>来打比方：</p>
<h3>1. 这个文件夹主要负责什么功能？</h3>
<p><strong>核心功能：测试“主机”和“显示器”能否分家。</strong></p>
<p>在普通的程序里，脚本一停，程序就全退出了。但在这个文件夹测试的模式下，我们想实现：
即便<strong>控制端</strong>（显示器/键盘）拔掉了、关机了、甚至脚本崩了，<strong>计算端</strong>（那台昂贵的、正在跑大模型的主机）依然要在后台活着，不能关机，随时等待下一次连接。</p>
<p>这叫 <strong>“计算与控制解耦”</strong>。</p>
<hr />
<h3>2. 各个文件是干什么的？</h3>
<p>这里就两个主角，像是一场接力赛：</p>
<h4>📄 <code>server.py</code> —— <strong>网管 (开机人)</strong></h4>
<ul>
<li><strong>角色</strong>：它是负责<strong>“开店”</strong>的。</li>
<li><strong>动作</strong>：<ol>
<li>它把那几台昂贵的 GPU 机器（Worker）启动起来。</li>
<li>给它们装好系统（初始化模型）。</li>
<li>给它们贴上名字标签（比如 "Trainer_0"）。</li>
<li><strong>最关键的一步</strong>：它告诉 Ray 系统：“这几台机器我要<strong>留着（Detached）</strong>，别我一走你就把电断了。”</li>
<li>做完这些，<code>server.py</code> 这个脚本自己就退出了。<strong>但 GPU 机器还在后台嗡嗡转，处于待机状态。</strong></li>
</ol>
</li>
</ul>
<h4>📄 <code>client.py</code> —— <strong>顾客 (上机人)</strong></h4>
<ul>
<li><strong>角色</strong>：它是负责<strong>“使用”</strong>的。</li>
<li><strong>动作</strong>：<ol>
<li>它在 <code>server.py</code> 跑完之后才运行。</li>
<li>它没有去买新电脑，而是拿着名字标签去问系统：“有没有叫 'Trainer_0' 的机器？”</li>
<li>连上那台已经在待机的 GPU 机器。</li>
<li>扔给它一堆数据：“给爷跑个训练！”</li>
<li>拿回结果，测试成功。</li>
</ol>
</li>
</ul>
<hr />
<h3>3. 高层认知：一句话理解它的作用</h3>
<p>你可以把这部分代码想象成在测试 <strong>“无人值守挂机”</strong> 功能。</p>
<ul>
<li><strong>以前的模式</strong>：你必须一直盯着电脑屏幕，脚本关了，训练就停了。</li>
<li><strong>现在的模式 (Detached)</strong>：<ul>
<li>你运行 <code>server.py</code>，相当于告诉服务器：“你们先跑起来，准备好环境，挂在那儿别动。”</li>
<li>你可以合上笔记本电脑回家睡觉。</li>
<li>第二天早上，你打开 <code>client.py</code>，连上去发个指令，或者查看一下状态。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong>
这个文件夹就是为了证明 Verl 框架<strong>支持“断线重连”</strong>。它允许训练任务在后台像<strong>“幽灵”</strong>一样长期存活，而不需要你的 Python 脚本一直开着。</p>