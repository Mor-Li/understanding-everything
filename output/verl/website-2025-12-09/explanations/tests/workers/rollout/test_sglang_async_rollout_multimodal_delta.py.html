<h1>tests/workers/rollout/test_sglang_async_rollout_multimodal_delta.py</h1>
<p>这份代码其实是一个<strong>单元测试（Unit Test）</strong>文件。</p>
<p>它的核心目的是为了验证一个叫 <code>AsyncRolloutRequest</code> 的类（在这个系统中用于管理对话状态的对象），在处理<strong>多模态（文字+图片）</strong>对话时，能不能正确地进行<strong>增量更新（Delta Update）</strong>。</p>
<p>简单来说，就是测试：<strong>“当我在一段对话中不断加入新的图片和文字时，系统能不能只处理新加进来的部分，而不是每次都把以前的所有图片和文字重新算一遍？”</strong></p>
<p>为了让你看懂，我把这个测试代码做的事情拆解成一个 <strong>Task To-Do List</strong>，你可以想象程序正在一步步执行这个清单：</p>
<hr />
<h3>📝 任务清单 (Task To-Do List)</h3>
<h4>第一阶段：准备工作 (Preparation)</h4>
<ul>
<li>[ ] <strong>Task 1: 准备素材</strong><ul>
<li>这里的素材是 3 张网上的图片（一张海滩图，一张 GitHub Logo，一张 Octocat 吉祥物）。</li>
<li>还要准备对应的 3 段文字描述。</li>
<li><em>（可选）</em> 把所有图片缩放到同样的大小（为了测试不同尺寸处理逻辑）。</li>
</ul>
</li>
</ul>
<h4>第二阶段：初始化对话 (Initialization)</h4>
<ul>
<li>[ ] <strong>Task 2: 建立初始对话状态</strong><ul>
<li>创建一个“系统提示词”（System Prompt）：告诉 AI 你要看图说话。</li>
<li>创建“第一轮对话”：用户发给 AI <strong>第 1 张图片</strong> 和一句话“这是第一张图”。</li>
<li>初始化 <code>AsyncRolloutRequest</code> 对象：这是测试的核心对象，它把上面的信息存起来，处于“待处理”状态。</li>
</ul>
</li>
</ul>
<h4>第三阶段：模拟对话循环 (The Loop - 核心测试点)</h4>
<ul>
<li>[ ] <strong>Task 3: 模拟 AI 回复与工具反馈 (循环处理剩下的图片)</strong><ul>
<li><em>现在手里还有第 2、3 张图没用。进入循环：</em></li>
<li><strong>Step 3.1 (AI 说话):</strong> 调用 <code>req.add_assistant_message</code>。模拟 AI 说：“这张图是一只猫...”（使用准备好的描述文字）。</li>
<li><strong>Step 3.2 (工具反馈):</strong> 调用 <code>req.add_tool_response_messages</code>。模拟系统（Tool）给 AI 塞了 <strong>一张新图片</strong>（第 2 张图）。<ul>
<li><strong>关键测试点：</strong> 这里测试的是 <strong>“Delta（增量）”</strong>。代码会检查加入新图后，数据的长度是不是按预期增加了，而不是乱变。</li>
</ul>
</li>
<li><strong>Step 3.3 (验证数据):</strong> 检查 <code>req.multi_modal_data["image"]</code> 里的图片列表是不是正确变成了 <code>[图1, 图2]</code>。</li>
</ul>
</li>
</ul>
<h4>第四阶段：最终一致性检查 (Sanity Check)</h4>
<ul>
<li>[ ] <strong>Task 4: 验证“增量更新” vs “从头计算” 是否一致</strong><ul>
<li><strong>方法 A (增量法):</strong> 就是上面 Task 3 做的事，一步步往里加东西，得到的最终 Token ID 序列（<code>req.input_ids</code>）。</li>
<li><strong>方法 B (全量法):</strong> 把所有对话历史（图1+文字+图2+文字...）一次性扔给处理器（Processor），生成一套完整的 Token ID 序列。</li>
<li><strong>对比:</strong> 断言（Assert） <strong>A 和 B 的结果必须完全一样</strong>。</li>
<li><em>目的：</em> 证明代码里的“一步步加图片”逻辑是完美的，和“一次性算好”结果没区别，但效率更高。</li>
</ul>
</li>
</ul>
<hr />
<h3>🔬 逐步代码对应讲解</h3>
<p>现在如果你回头看代码，就能对应上了：</p>
<p><strong>1. 函数 <code>_test_add_tool_response_messages_image_delta</code></strong>
这是通用的测试逻辑函数。</p>
<ul>
<li>
<p><strong>准备图片：</strong>
    <code>python
    # 对应 Task 1
    processed_images = []
    for img_url in image_list: ... # 下载并处理图片</code></p>
</li>
<li>
<p><strong>初始化请求：</strong>
    ```python
    # 对应 Task 2
    # 创建包含第1张图的 message
    messages = [ ..., {"role": "user", "content": [..., {"image": [processed_images[0]]}]} ]</p>
<h1>创建核心对象</h1>
<p>req = AsyncRolloutRequest(..., messages=messages, multi_modal_data={"image": [processed_images[0]]}, ...)
```</p>
</li>
<li>
<p><strong>循环添加内容 (Delta)：</strong>
    ```python
    # 对应 Task 3
    for idx, img in enumerate(processed_images):
        if idx == 0: continue # 跳过第1张，因为初始化时已经加进去了</p>
<div class="codehilite"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">模拟</span><span class="w"> </span><span class="n">AI</span><span class="w"> </span><span class="n">说话</span><span class="w"> </span><span class="p">(</span><span class="n">添加文字</span><span class="p">)</span>
<span class="n">req</span><span class="p">.</span><span class="n">add_assistant_message</span><span class="p">(</span><span class="n">processor</span><span class="p">,</span><span class="w"> </span><span class="n">content</span><span class="o">=</span><span class="n">description_list</span><span class="o">[</span><span class="n">idx - 1</span><span class="o">]</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="n">模拟工具返回新图片</span><span class="w"> </span><span class="p">(</span><span class="n">这是最关键的一步</span><span class="err">！</span><span class="p">)</span>
<span class="err">#</span><span class="w"> </span><span class="n">ToolResponse</span><span class="w"> </span><span class="n">里面包含了一张新图</span><span class="w"> </span><span class="n">img</span>
<span class="n">req</span><span class="p">.</span><span class="n">add_tool_response_messages</span><span class="p">(</span><span class="n">processor</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">ToolResponse(image=[img</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="err">]</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="mf">3.</span><span class="w"> </span><span class="n">验证图片列表是不是累加了</span>
<span class="n">assert</span><span class="w"> </span><span class="n">req</span><span class="p">.</span><span class="n">multi_modal_data</span><span class="o">[</span><span class="n">&quot;image&quot;</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">processed_images</span><span class="o">[</span><span class="n">: idx + 1</span><span class="o">]</span>
</code></pre></div>

<p>```</p>
</li>
<li>
<p><strong>最后的一致性对比：</strong>
    ```python
    # 对应 Task 4
    # 获取所有的 message 历史
    messages = [msg.model_dump() for msg in req.messages]</p>
<h1>用处理器一次性算一遍 (full_prompt_info)</h1>
<p>full_prompt_info = req._handle_apply_chat_template(..., messages, ...)</p>
<h1>核心对比：增量算出来的 input_ids 和一次性算出来的必须相等</h1>
<p>assert full_prompt_ids.eq(req.input_ids).all()
```</p>
</li>
</ul>
<p><strong>2. 两个测试用例 (<code>test_...</code>)</strong>
底下的两个函数 <code>test_add_tool_response_messages_image_delta</code> 和 <code>..._resize_image</code> 只是具体的执行入口：
*   第一个不缩放图片。
*   第二个强制缩放图片（测试当图片大小变化时，Token计算是否依然准确）。</p>
<h3>总结</h3>
<p>这篇文章讲的是：<strong>验证系统在多轮对话中，能否正确地、增量地处理新加入的图片，保证数据的一致性。</strong></p>