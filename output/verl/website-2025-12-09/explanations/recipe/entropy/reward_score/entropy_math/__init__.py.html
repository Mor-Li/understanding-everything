<h1>recipe/entropy/reward_score/entropy_math/<strong>init</strong>.py</h1>
<p>这个文件其实是一个<strong>“超级数学判题机”</strong>。</p>
<p>简单来说，它的作用是：当你训练的大模型做了一道数学题，给出了一个答案（<code>model_response</code>），这个脚本负责拿它和标准答案（<code>ground_truth</code>）进行比对，判断模型是对是错，并打分。</p>
<p>因为数学表达很灵活（比如 $\frac{1}{2}$ 和 $0.5$ 是一样的），不能简单地比较字符串是否相等，所以这个文件写了非常复杂的逻辑来“清洗”和“计算”答案。</p>
<p>为了让你看懂，我把它拆解成一个 <strong>“判卷老师的工作清单 (Todo List)”</strong>，按代码执行的逻辑一步步给你讲：</p>
<hr />
<h3>判卷老师的工作清单 (Task Todo List)</h3>
<h4>✅ Task 1: 拿到考卷，先找答案在哪 (Extraction)</h4>
<ul>
<li><strong>动作</strong>：从模型长篇大论的回答中，提取出最终答案。</li>
<li><strong>代码对应</strong>：<code>compute_score</code> 函数调用 <code>extract_answer</code>。</li>
<li><strong>逻辑</strong>：<ul>
<li>老师只看被框起来的部分，寻找 LaTeX 格式的 <code>\boxed{...}</code>。</li>
<li>如果模型没写 <code>\boxed{}</code>，老师就找不到答案，直接判 0 分（<code>score: 0.0</code>）。</li>
</ul>
</li>
</ul>
<h4>✅ Task 2: 帮学生擦掉多余的废话 (Normalization - String Cleaning)</h4>
<ul>
<li><strong>动作</strong>：把答案里的单位、标点、格式修饰符统统去掉，只留核心数值或表达式。</li>
<li><strong>代码对应</strong>：<code>mathd_normalize_answer</code>, <code>_strip_string</code>, <code>unit_texts</code> (那个超长的单位列表)。</li>
<li><strong>逻辑</strong>：<ul>
<li>学生写 "5 meters" -&gt; 改成 "5"。</li>
<li>学生写 "$100" -&gt; 改成 "100"。</li>
<li>学生写 "30 degrees" -&gt; 改成 "30"。</li>
<li>学生写 <code>\text{4}</code> -&gt; 改成 <code>4</code>。</li>
<li><strong>目的</strong>：防止因为多写了个单位或者格式不同而被误判错误。</li>
</ul>
</li>
</ul>
<h4>✅ Task 3: 第一轮批改 - 字符串“长得像不像” (String Matching)</h4>
<ul>
<li><strong>动作</strong>：对比清洗后的模型答案和标准答案，看字符串是否完全一致。</li>
<li><strong>代码对应</strong>：<code>grade_answer_mathd</code>。</li>
<li><strong>逻辑</strong>：<ul>
<li>如果标准答案是 "5"，模型清洗后也是 "5"，直接给满分，收工。</li>
<li>如果不一致，进入下一轮更高级的判断。</li>
</ul>
</li>
</ul>
<h4>✅ Task 4: 第二轮批改 - 数学上“等不等” (Symbolic Grading)</h4>
<ul>
<li><strong>动作</strong>：如果字符串不一样（比如 "1/2" 和 "0.5"），就把它们转换成数学对象进行计算比对。</li>
<li><strong>代码对应</strong>：<code>grade_answer_sympy</code>, <code>are_equal_under_sympy</code>, <code>sympy</code> 库。</li>
<li><strong>逻辑</strong>：<ul>
<li><strong>分数与小数</strong>：利用 <code>SymPy</code> 库计算。它知道 <code>1/2 - 0.5 = 0</code>，所以判对。</li>
<li><strong>表达式简化</strong>：它知道 <code>x + x</code> 和 <code>2x</code> 是一回事。</li>
<li><strong>集合/元组</strong>：如果答案是多个数（比如 <code>3, 4</code>），它会检查顺序和内容是否一致。</li>
<li><strong>特殊处理</strong>：如果是分数（<code>\frac</code>），代码会很小心，有时要求必须化简。</li>
</ul>
</li>
</ul>
<h4>✅ Task 5: 终极批改 - 动用重型武器 (Advanced Verification)</h4>
<ul>
<li><strong>动作</strong>：如果前面都判错了，但开启了 <code>fast=False</code>（慢速高召回模式），就用更强大的工具再查一遍。</li>
<li><strong>代码对应</strong>：<code>is_latex_equal</code>, <code>verify</code> (来自 <code>math_verify</code> 库)。</li>
<li><strong>逻辑</strong>：<ul>
<li>这是一个更高级的 LaTeX 解析器，专门处理复杂的数学公式比对。</li>
<li>它能处理很多 <code>SymPy</code> 处理不了的怪异 LaTeX 写法。</li>
<li><strong>防死机机制</strong>：因为数学解析很容易卡死（死循环），代码里加了很多 <code>timeout</code> (超时控制)，如果解析超过 1-5 秒还没结果，就强制停止并判错，防止程序卡住。</li>
</ul>
</li>
</ul>
<h4>✅ Task 6: 防作弊与异常检测 (Sanity Check)</h4>
<ul>
<li><strong>动作</strong>：检查答案是不是在“刷屏”。</li>
<li><strong>代码对应</strong>：<code>repeatness</code>。</li>
<li><strong>逻辑</strong>：<ul>
<li>如果模型输出了一堆 "aaaaa..." 或者重复乱码，直接判错。</li>
</ul>
</li>
</ul>
<h4>✅ Task 7: 给出最终成绩 (Scoring)</h4>
<ul>
<li><strong>动作</strong>：输出一个字典结果。</li>
<li><strong>代码对应</strong>：<code>compute_score</code> 的返回值。</li>
<li><strong>内容</strong>：<ul>
<li><code>score</code>: 1.0 (对) 或 0.0 (错)。</li>
<li><code>format_score</code>: 只要能提取出答案就算格式对。</li>
<li><code>acc</code>: True/False。</li>
</ul>
</li>
</ul>
<hr />
<h3>总结</h3>
<p>这个文件的核心思想是：<strong>为了不冤枉模型，用尽一切办法（字符串清洗、数学计算库 SymPy、专业验证库 MathVerify）来证明模型的答案在数学上等同于标准答案。</strong></p>