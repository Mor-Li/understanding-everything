<h1>recipe/entropy/reward_score/entropy_math/grader.py</h1>
<p>这份代码其实就是一个<strong>“数学自动阅卷老师”</strong>。它的核心任务是判断<strong>“模型给出的答案（prediction）”</strong>和<strong>“标准答案（reference）”</strong>是否一致。</p>
<p>因为数学答案的写法千奇百怪（比如 $0.5$ 和 $1/2$ 是一样的，$1,000$ 和 $1000$ 是一样的），所以不能简单地看字符串是否相等。</p>
<p>我为你列了一个<strong>阅卷流程的 Todo List</strong>，代码就是按照这个顺序一步步执行的。如果某一步通过了，就打钩（返回 True），否则继续往下查。</p>
<hr />
<h3>阅卷流程 Todo List (由易到难)</h3>
<h4>1. 📋 准备工作：清理卷面 (Normalization)</h4>
<p>在开始比较之前，先要把答案格式统一，去掉干扰项。
*   <strong>任务：</strong> 去掉多余的符号。
    *   如果答案里有 <code>$</code> 符号（LaTeX格式），去掉它。
    *   如果答案里有 <code>%</code> 或 <code>\%</code>，去掉它（后面会专门处理百分比数值）。
    *   <strong>处理 $\pi$</strong>：把文本里的 <code>\pi</code> 替换成数字 <code>3.14159...</code>。
    *   <strong>处理进制</strong>：如果出现 <code>101_2</code> 这种进制写法，只取下划线前面的数字。
*   <strong>对应代码函数：</strong> <code>normalize()</code>, <code>handle_base()</code>, <code>handle_pi()</code></p>
<h4>2. 🔍 第一轮检查：字面完全一致吗？ (String Match)</h4>
<p>这是最简单粗暴的检查。
*   <strong>任务：</strong>
    *   忽略大小写。
    *   忽略空格。
    *   如果处理后的字符串完全一样，直接算对。
*   <strong>对应代码位置：</strong> <code>math_equal</code> 函数开头的字符串比较部分。</p>
<h4>3. 🔢 第二轮检查：数值相等吗？ (Numerical Equal)</h4>
<p>如果字面不一样（比如 "0.5" 和 "50%"），就把它们变成数字比大小。
*   <strong>任务：</strong>
    *   尝试把两个答案都转换成浮点数（float）。
    *   <strong>处理百分号</strong>：如果标准答案可能是百分数，那就把数字 <code>x</code>，<code>x/100</code>，<code>x*100</code> 三种情况都算一遍。
    *   <strong>允许误差</strong>：计算机浮点数有误差，只要两个数非常接近（<code>tolerance</code> 默认 1e-4），就算相等。
*   <strong>对应代码位置：</strong> <code>is_digit()</code>, <code>isclose()</code> 以及 <code>math_equal</code> 中间的 try-except 块。</p>
<h4>4. 📦 第三轮检查：集合、区间、列表相等吗？ (Structure/Interval Check)</h4>
<p>数学题经常问集合 <code>{1, 2}</code> 或者区间 <code>[0, 1)</code>。
*   <strong>任务：</strong>
    *   <strong>格式化区间</strong>：把 <code>Interval.open(a, b)</code> 这种写法统一成 <code>(a, b)</code>。
    *   <strong>去括号对比</strong>：不管是用 <code>[]</code> 还是 <code>()</code> 还是 <code>{}</code>，先去掉括号看看里面内容是不是一样。
    *   <strong>拆分对比</strong>：如果是由逗号分隔的多个数（比如坐标点 <code>(3, 4)</code> 或列表 <code>[1, 2, 3]</code>），就把它们拆开，一个一个数去比对（递归调用前面的数值检查）。
    *   <strong>矩阵对比</strong>：如果是矩阵（Matrix），解析矩阵里的每个元素，一一对应检查。
*   <strong>对应代码位置：</strong> <code>format_intervals()</code>, 以及 <code>math_equal</code> 后半部分处理 <code>split(",")</code> 和 <code>Matrix</code> 的逻辑。</p>
<h4>5. 🧮 最后一轮检查：符号/代数相等吗？ (Symbolic Equal)</h4>
<p>这是最慢但最强大的大招。如果前面都挂了，可能答案是代数表达式（比如 <code>x + 1</code> 和 <code>1 + x</code>）。
*   <strong>任务：</strong>
    *   使用 Python 的数学库 <code>SymPy</code> 来解析复杂的 LaTeX 字符串。
    *   <strong>做减法</strong>：计算 <code>(预测答案 - 标准答案)</code>。利用 <code>simplify()</code> 化简，如果结果等于 0，说明两者数学上相等。
    *   <strong>求数值解</strong>：如果化简太难，就试着把符号代入数值计算结果（<code>N()</code> 函数），看结果是否足够接近。
    *   <strong>超时控制</strong>：因为符号计算很慢，为了防止卡死，设置了 <code>timeout</code>（默认10秒），算太久就直接放弃。
*   <strong>对应代码函数：</strong> <code>symbolic_equal()</code></p>
<hr />
<h3>总结</h3>
<p>这段代码的逻辑就是：
<strong>先看长得像不像 ➡️ 再看算出的数等不等 ➡️ 再看列表/矩阵里的元素对不对 ➡️ 最后用高数工具算一下表达式是否等价。</strong></p>
<p>只要通过其中任何一关，就返回 <code>True</code>（做对了），全部通不过才返回 <code>False</code>（做错了）。</p>