<h1>recipe/gkd/teacher/start_server.sh</h1>
<p>这个脚本的主要目的是<strong>启动一个“老师模型”的服务</strong>。</p>
<p>在很多AI训练（特别是知识蒸馏 GKD）中，我们需要一个强大的模型（Teacher）来指导弱一点的模型（Student）。这个脚本就是用来把那个强大的“老师”运行起来，让它准备好回答问题。</p>
<p>我们可以把它看作是在<strong>开一家餐厅</strong>。</p>
<p>以下是你要求的 <strong>Task To-Do List</strong>，我们将脚本拆解为 6 个步骤：</p>
<h3>📝 启动老师模型 (Start Server) To-Do List</h3>
<ol>
<li><strong>[配置参数]</strong>：确定餐厅开在几号门面（端口），以及大厨是谁（模型路径）。</li>
<li><strong>[定义工具]</strong>：雇佣一个“检查员”，专门负责盯着服务有没有启动成功。</li>
<li><strong>[清理现场]</strong>：把之前还没关门的旧服务强制关掉，防止冲突。</li>
<li><strong>[启动前台]</strong>：启动代理服务（Proxy），负责接待请求。</li>
<li><strong>[确认就绪]</strong>：让“检查员”一直等着，直到前台真正开门营业。</li>
<li><strong>[启动后厨]</strong>：启动真正的模型推理服务（Worker），开始干活。</li>
</ol>
<hr />
<h3>详细步骤讲解</h3>
<p>下面我把代码对应到上面的 List 里，逐行给你解释：</p>
<h4>1. [配置参数] 设定端口和模型</h4>
<div class="codehilite"><pre><span></span><code><span class="nb">export</span><span class="w"> </span><span class="nv">PROXY_FRONTEND_PORT</span><span class="o">=</span><span class="m">15555</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">PROXY_BACKEND_PORT</span><span class="o">=</span><span class="m">15556</span>

<span class="nv">BACKEND</span><span class="o">=</span>vllm
<span class="nv">CKPT_PATH</span><span class="o">=</span><span class="s2">&quot;/path/to/TEACHER_MODEL/&quot;</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li>定义了两个“门牌号”（端口）：15555 和 15556。</li>
<li>定义了后端引擎是用 <code>vllm</code>（一种很快的模型推理工具）。</li>
<li><strong>重要</strong>：<code>CKPT_PATH</code> 是你的模型文件存放的地方（你需要把它改成你实际的路径）。</li>
</ul>
</li>
</ul>
<h4>2. [定义工具] 编写等待函数</h4>
<div class="codehilite"><pre><span></span><code>wait_server_ready<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nv">server</span><span class="o">=</span><span class="nv">$1</span>
<span class="w">    </span><span class="nv">ip</span><span class="o">=</span><span class="nv">$2</span>
<span class="w">    </span><span class="nv">port</span><span class="o">=</span><span class="nv">$3</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span>true<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">        </span><span class="c1"># ... (省略了中间的检测代码)</span>
<span class="w">        </span><span class="c1"># 用 telnet 尝试连接端口，如果通了就 break 退出循环，不通就 sleep 1秒再试</span>
<span class="w">    </span><span class="k">done</span>
<span class="o">}</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li>这段代码<strong>不会立刻执行</strong>，它只是定义了一个叫 <code>wait_server_ready</code> 的功能（函数）。</li>
<li>它的作用是：你给它一个 IP 和端口，它就死皮赖脸地每隔 1 秒去敲一次门，直到门开了（服务启动了）它才停止。</li>
</ul>
</li>
</ul>
<h4>3. [清理现场] 杀掉旧进程</h4>
<div class="codehilite"><pre><span></span><code>ps<span class="w"> </span>-ef<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">&quot;python proxy.py&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-v<span class="w"> </span>grep<span class="w"> </span><span class="p">|</span><span class="w"> </span>awk<span class="w"> </span>-F<span class="w"> </span><span class="s1">&#39; &#39;</span><span class="w"> </span><span class="s1">&#39;{print $2}&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>-r<span class="w"> </span><span class="nb">kill</span><span class="w"> </span>-9
ps<span class="w"> </span>-ef<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">&quot;python worker.py&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-v<span class="w"> </span>grep<span class="w"> </span><span class="p">|</span><span class="w"> </span>awk<span class="w"> </span>-F<span class="w"> </span><span class="s1">&#39; &#39;</span><span class="w"> </span><span class="s1">&#39;{print $2}&#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>-r<span class="w"> </span><span class="nb">kill</span><span class="w"> </span>-9
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li>在启动新服务之前，必须确保没有“僵尸进程”占着位置。</li>
<li>这两行命令极其暴力：查找所有叫 <code>proxy.py</code> 和 <code>worker.py</code> 的 Python 程序，然后用 <code>kill -9</code> 把它们全部杀掉。确保环境是干净的。</li>
</ul>
</li>
</ul>
<h4>4. [启动前台] 运行 Proxy</h4>
<div class="codehilite"><pre><span></span><code>nohup<span class="w"> </span>python<span class="w"> </span>proxy.py<span class="w"> </span><span class="p">&amp;</span>&gt;<span class="w"> </span>proxy.log<span class="w"> </span><span class="p">&amp;</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li><code>python proxy.py</code>：运行代理脚本。这个 <code>proxy</code> 就像餐厅的服务员/前台，它负责接收外部请求，然后转发给后面的模型。</li>
<li><code>nohup ... &amp;</code>：意思是“在后台默默运行，不要因为我关掉终端窗口你就挂了”。</li>
<li><code>&amp;&gt; proxy.log</code>：把它的所有输出（日志）都写到 <code>proxy.log</code> 文件里，别打印在屏幕上乱晃。</li>
</ul>
</li>
</ul>
<h4>5. [确认就绪] 等待 Proxy 启动成功</h4>
<div class="codehilite"><pre><span></span><code>wait_server_ready<span class="w"> </span>proxy<span class="w"> </span>localhost<span class="w"> </span><span class="nv">$PROXY_BACKEND_PORT</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;teacher proxy is ready&quot;</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li>这里用到了第2步定义的工具。</li>
<li>它在检测 <code>localhost</code>（本机）的 <code>15556</code> 端口（PROXY_BACKEND_PORT）通了没有。</li>
<li>只有当 Proxy 真的启动好了，脚本才会往下走，打印 "teacher proxy is ready"。</li>
</ul>
</li>
</ul>
<h4>6. [启动后厨] 运行 Worker (大厨)</h4>
<div class="codehilite"><pre><span></span><code>nohup<span class="w"> </span>python<span class="w"> </span>worker.py<span class="w"> </span>--backend<span class="w"> </span><span class="nv">$BACKEND</span><span class="w"> </span>--tp-size<span class="w"> </span><span class="m">1</span><span class="w"> </span>--n-logprobs<span class="w"> </span><span class="m">256</span><span class="w"> </span>--ckpt-path<span class="w"> </span><span class="nv">$CKPT_PATH</span><span class="w"> </span><span class="p">&amp;</span>&gt;<span class="w"> </span>worker.log<span class="w"> </span><span class="p">&amp;</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;start teacher worker&quot;</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;teacher server is ready&quot;</span>
</code></pre></div>

<ul>
<li><strong>讲了啥</strong>：<ul>
<li>这是最关键的一步。<code>python worker.py</code> 启动了真正的 AI 模型。</li>
<li>它带了很多参数：<ul>
<li><code>--backend vllm</code>：使用 vllm 加速。</li>
<li><code>--ckpt-path ...</code>：加载第1步里指定的模型文件。</li>
</ul>
</li>
<li>同样也是 <code>nohup ... &amp;</code> 后台运行，日志写在 <code>worker.log</code> 里。</li>
</ul>
</li>
</ul>
<h3>总结</h3>
<p>这个脚本就是一套<strong>全自动的启动流程</strong>：
<strong>清理旧的 -&gt; 启动中介 -&gt; 等中介好了 -&gt; 启动大模型 -&gt; 完成。</strong></p>