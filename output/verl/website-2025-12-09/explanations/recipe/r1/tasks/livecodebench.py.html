<h1>recipe/r1/tasks/livecodebench.py</h1>
<p>这份代码其实就是一个<strong>“自动阅卷老师”</strong>。</p>
<p>它的核心任务是：拿到AI写的一段Python代码，运行它，看看能不能通过所有的测试用例（Test Cases），最后给出一个“通过”或“不通过”的结论。</p>
<p>为了让你更容易理解，我把这段代码执行的过程拆解成一个 <strong>TODO List（任务清单）</strong>，我们可以一步步来看它是怎么工作的：</p>
<hr />
<h3>📝 任务清单 (Todo List)</h3>
<h4>✅ Task 1: 提取“答卷” (清洗代码)</h4>
<p><strong>对应的代码位置：</strong> <code>compute_score</code> 函数的开头。</p>
<blockquote>
<p><code>solution = completion.split("```python")[-1].split("```")[0]</code></p>
</blockquote>
<ul>
<li><strong>发生了什么：</strong>
    AI 回答问题时通常会说很多废话（比如“好的，这是你要的代码...”）。</li>
<li><strong>这一步的作用：</strong>
    就像老师把试卷上的闲聊涂掉，只保留核心答案。它利用字符串分割，把包裹在 <code>`python ...</code> <code>里的纯代码提取出来，赋值给</code>solution`。</li>
</ul>
<h4>✅ Task 2: 准备“标准答案” (解压测试用例)</h4>
<p><strong>对应的代码位置：</strong> <code>compute_score</code> 函数中间的 <code>try...except</code> 块。</p>
<blockquote>
<p><code>in_outs = json.loads(test_cases)</code> 或那一大串 <code>pickle.loads(zlib...)</code></p>
</blockquote>
<ul>
<li><strong>发生了什么：</strong>
    <code>test_cases</code> 是题目对应的输入和预期输出。有时候它是普通的文本（JSON），有时候为了节省空间或传输方便，它被压缩和编码了（Base64 -&gt; Zlib压缩 -&gt; Pickle序列化）。</li>
<li><strong>这一步的作用：</strong>
    就像老师拿出密封的参考答案袋，如果被压缩了就先解压，最后还原成可以在程序里读取的数据格式（<code>in_outs</code>）。</li>
</ul>
<h4>✅ Task 3: 准备“隔离考场” (设置多进程)</h4>
<p><strong>对应的代码位置：</strong> <code>check_correctness</code> 函数。</p>
<blockquote>
<p><code>manager = multiprocessing.Manager()</code> ... <code>p = multiprocessing.Process(...)</code></p>
</blockquote>
<ul>
<li><strong>发生了什么：</strong>
    直接运行别人的代码很危险（可能会死循环，或者把内存撑爆）。</li>
<li><strong>这一步的作用：</strong>
    这里并没有直接在主程序里运行代码，而是开了一个<strong>独立的子进程</strong>（<code>multiprocessing</code>）。
    这就像给学生安排了一个<strong>独立的、封闭的考场</strong>。如果学生在里面捣乱（代码写坏了），不会炸掉整个学校（主程序）。</li>
</ul>
<h4>✅ Task 4: 考试开始 &amp; 计时 (运行与超时控制)</h4>
<p><strong>对应的代码位置：</strong> <code>check_correctness</code> 函数中的 <code>p.start()</code> 和 <code>p.join(timeout=...)</code>。</p>
<ul>
<li><strong>发生了什么：</strong><ol>
<li><strong>开始考试：</strong> 调用 <code>_temp_run</code>，进而调用 <code>run_test</code>（这是真正把数据喂给代码跑的地方）。</li>
<li><strong>倒计时：</strong> <code>p.join(timeout=...)</code> 设置了一个最长等待时间。</li>
<li><strong>强制收卷：</strong> 如果时间到了进程还没结束（<code>if p.is_alive(): p.kill()</code>），说明代码可能死循环了，直接杀掉进程。</li>
</ol>
</li>
</ul>
<h4>✅ Task 5: 批改分数 (计算结果)</h4>
<p><strong>对应的代码位置：</strong> <code>compute_score</code> 函数的最后。</p>
<blockquote>
<p><code>success = all(map(lambda x: x is True, res))</code></p>
</blockquote>
<ul>
<li><strong>发生了什么：</strong>
    <code>run_test</code> 会返回一组结果（比如 <code>[True, True, False]</code> 表示前两个测试点过了，第三个没过）。</li>
<li><strong>这一步的作用：</strong>
    这里用 <code>all()</code> 函数来判断。只有当<strong>所有</strong>测试点都返回 <code>True</code> 时，最终结果才算 <code>True</code>（通过）。只要有一个错，就是 <code>False</code>（失败）。</li>
</ul>
<hr />
<h3>总结一下</h3>
<p>这份文件的逻辑流向是这样的：</p>
<ol>
<li>
<p><strong><code>compute_score</code> (总指挥)</strong>:</p>
<ul>
<li>拿到 AI 的回复，剥离出代码。</li>
<li>拿到测试题，解压成数据。</li>
<li>把这两样东西交给 <code>check_correctness</code>。</li>
</ul>
</li>
<li>
<p><strong><code>check_correctness</code> (考场管理员)</strong>:</p>
<ul>
<li>开启一个新进程（安全气囊）。</li>
<li>设置一个闹钟（超时机制）。</li>
<li>如果在规定时间内跑完，记录成绩；如果超时，判为失败。</li>
</ul>
</li>
<li>
<p><strong><code>_temp_run</code> (监考员)</strong>:</p>
<ul>
<li>在子进程里实际执行代码（调用外部工具 <code>run_test</code>）。</li>
<li>把结果写回到共享的记录本上（<code>manager.list</code>）。</li>
</ul>
</li>
</ol>
<p>这就是一个典型的<strong>代码评测脚本</strong>（Online Judge Logic）。</p>