<h1>recipe/vla/models/openvla_oft/constants.py</h1>
<p>这份代码其实不是复杂的算法，而是一份<strong>“智能配置文件”</strong>。</p>
<p>它的核心作用是：<strong>根据你当前想训练哪种机器人（比如 Libero、Aloha 还是 Bridge），自动把一套对应的参数（常量）加载进来，省得你手动去改。</strong></p>
<p>为了让你彻底看懂，我为你设计了一个由浅入深的 <strong>Task Todo List</strong>。我们一步步把这个文件“拆解”开来。</p>
<hr />
<h3>✅ Task 1: 搞懂背景——这是给什么用的？</h3>
<p><strong>代码位置</strong>：<code>recipe/vla/models/openvla_oft/constants.py</code></p>
<ul>
<li><strong>VLA 是什么？</strong> VLA (Vision-Language-Action) 是一种大模型，它不仅能看图（Vision）、说话（Language），还能控制机器人动作（Action）。</li>
<li><strong>这个文件的作用：</strong> 就像你玩游戏前要选“键位设置”一样。不同的机器人（比如有的单臂，有的双臂）需要的“键位”（参数）是不一样的。这个文件就是用来定义这些参数的。</li>
</ul>
<hr />
<h3>✅ Task 2: 搞懂 LLM（大语言模型）相关的“暗号”</h3>
<p>看代码这一段：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Llama 2 token constants</span>
<span class="n">IGNORE_INDEX</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
<span class="n">ACTION_TOKEN_BEGIN_IDX</span> <span class="o">=</span> <span class="mi">31743</span>
<span class="n">STOP_INDEX</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># &#39;&lt;/s&gt;&#39;</span>
</code></pre></div>

<p><strong>解读：</strong>
因为 VLA 模型的基础是 Llama 2（一个语言模型），它处理的是“Token”（词元）。
1.  <strong><code>IGNORE_INDEX = -100</code></strong>: 训练模型时，有些东西不需要模型去学习（比如问题本身，只要学答案），就标记为 -100，意思是“考试时不考这题，忽略它”。
2.  <strong><code>ACTION_TOKEN_BEGIN_IDX = 31743</code></strong>: 这是一个分界线。在这个数字之前的 Token 代表普通文字（比如“你好”），从这个数字开始，代表<strong>机器人的动作指令</strong>。
3.  <strong><code>STOP_INDEX = 2</code></strong>: 告诉模型“话说完了”或者“动作做完了”的停止符号。</p>
<hr />
<h3>✅ Task 3: 搞懂“归一化” (Normalization)——让数据变乖</h3>
<p>看代码这一段：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">NormalizationType</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
    <span class="n">NORMAL</span> <span class="o">=</span> <span class="s2">&quot;normal&quot;</span>               <span class="c1"># 均值0，方差1</span>
    <span class="n">BOUNDS</span> <span class="o">=</span> <span class="s2">&quot;bounds&quot;</span>               <span class="c1"># 压缩到 [-1, 1]</span>
    <span class="n">BOUNDS_Q99</span> <span class="o">=</span> <span class="s2">&quot;bounds_q99&quot;</span>       <span class="c1"># 去掉极端值后压缩到 [-1, 1]</span>
</code></pre></div>

<p><strong>解读：</strong>
机器人的传感器数据千奇百怪。有的关节角度是 0 到 360，有的位置坐标是 0 到 1000。
如果直接给模型吃这些数据，模型会“消化不良”。
*   <strong>Normalization（归一化）</strong> 就是把所有数据都压缩到一个标准范围（比如 -1 到 1 之间）。
*   这里定义了三种压缩方法，就像定义了三种“清洗蔬菜”的方法，后面会选一种用。</p>
<hr />
<h3>✅ Task 4: 认识三位“机器人选手”</h3>
<p>代码里定义了三个字典：<code>LIBERO_CONSTANTS</code>, <code>ALOHA_CONSTANTS</code>, <code>BRIDGE_CONSTANTS</code>。我们挑一个典型的 <code>ALOHA</code> 来讲：</p>
<div class="codehilite"><pre><span></span><code><span class="n">ALOHA_CONSTANTS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;NUM_ACTIONS_CHUNK&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span>  <span class="c1"># 一次预测多少步？</span>
    <span class="s2">&quot;ACTION_DIM&quot;</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span>         <span class="c1"># 机器人有多少个关节？</span>
    <span class="s2">&quot;PROPRIO_DIM&quot;</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span>        <span class="c1"># 机器人能感觉到多少个状态？</span>
    <span class="s2">&quot;ACTION_PROPRIO_NORMALIZATION_TYPE&quot;</span><span class="p">:</span> <span class="n">NormalizationType</span><span class="o">.</span><span class="n">BOUNDS</span><span class="p">,</span> <span class="c1"># 用哪种清洗方法？</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>解读：</strong>
*   <strong><code>ACTION_DIM</code> (动作维度)</strong>: Aloha 是个双臂机器人，每只手7个关节，加起来就是 14。如果是 Libero（单臂），这里就是 7。
*   <strong><code>NUM_ACTIONS_CHUNK</code> (动作块)</strong>: 模型不是一步一步想，而是一次想好未来的一串动作。Aloha 一次想 25 步，Libero 一次想 8 步。</p>
<hr />
<h3>✅ Task 5: 核心逻辑——自动侦探 (Auto-Detection)</h3>
<p>这是这个文件最“聪明”的地方。看函数 <code>detect_robot_platform()</code>：</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">detect_robot_platform</span><span class="p">():</span>
    <span class="n">cmd_args</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="c1"># 获取你在终端敲的命令</span>

    <span class="k">if</span> <span class="s2">&quot;libero&quot;</span> <span class="ow">in</span> <span class="n">cmd_args</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;LIBERO&quot;</span>
    <span class="k">elif</span> <span class="s2">&quot;aloha&quot;</span> <span class="ow">in</span> <span class="n">cmd_args</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;ALOHA&quot;</span>
    <span class="c1"># ... (以此类推)</span>
</code></pre></div>

<p><strong>解读：</strong>
当你运行训练脚本时，你可能会输入类似这样的命令：
<code>python train.py --dataset_name aloha_dataset ...</code></p>
<ol>
<li>代码会读取你敲的这行命令 (<code>sys.argv</code>)。</li>
<li>它会在命令里找关键词。</li>
<li>如果你命令里写了 "aloha"，它就知道：“噢！主人今天要训练 Aloha 机器人！”</li>
<li>如果没有找到关键词，默认使用 "LIBERO"。</li>
</ol>
<hr />
<h3>✅ Task 6: 最终执行——对号入座</h3>
<p>代码的最后部分：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 1. 侦测平台</span>
<span class="n">ROBOT_PLATFORM</span> <span class="o">=</span> <span class="n">detect_robot_platform</span><span class="p">()</span>

<span class="c1"># 2. 根据平台选字典</span>
<span class="k">if</span> <span class="n">ROBOT_PLATFORM</span> <span class="o">==</span> <span class="s2">&quot;LIBERO&quot;</span><span class="p">:</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="n">LIBERO_CONSTANTS</span>
<span class="k">elif</span> <span class="n">ROBOT_PLATFORM</span> <span class="o">==</span> <span class="s2">&quot;ALOHA&quot;</span><span class="p">:</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="n">ALOHA_CONSTANTS</span>
<span class="c1"># ...</span>

<span class="c1"># 3. 把字典里的值赋给全局变量</span>
<span class="n">NUM_ACTIONS_CHUNK</span> <span class="o">=</span> <span class="n">constants</span><span class="p">[</span><span class="s2">&quot;NUM_ACTIONS_CHUNK&quot;</span><span class="p">]</span>
<span class="n">ACTION_DIM</span> <span class="o">=</span> <span class="n">constants</span><span class="p">[</span><span class="s2">&quot;ACTION_DIM&quot;</span><span class="p">]</span>
<span class="c1"># ...</span>
</code></pre></div>

<p><strong>解读：</strong>
这就好比：
1.  服务员看了一眼你的点菜单（侦测平台）。
2.  确定你是吃“川菜”还是“粤菜”（选字典）。
3.  最后把菜端上来（赋值给全局变量）。</p>
<p>这样，其他文件引用这个 <code>constants.py</code> 时，直接用 <code>ACTION_DIM</code> 就行了，不需要关心具体是哪个机器人，因为这里已经自动处理好了。</p>
<hr />
<h3>📝 总结</h3>
<p>这个文件讲了这么一件事：
<strong>“我先看看你在命令行里提到了哪个机器人，然后我把那个机器人的关节数量、动作步数、数据处理方式都准备好，供后续的模型训练使用。”</strong></p>