<h1>recipe/open_math_reasoning/run_generation.sh</h1>
<p>没问题，这个脚本看起来很吓人，但其实它的逻辑非常线性。</p>
<p>你可以把这个脚本想象成<strong>“组织一场大规模的 AI 数学考试”</strong>。</p>
<p>为了让你更容易理解，我把你作为“考官”需要做的事情列成了一个 <strong>ToDo List (任务清单)</strong>。我们将代码拆解，一步步对应到这个清单里。</p>
<hr />
<h3>📝 任务清单：AI 数学考试流程</h3>
<h4>✅ Task 1: 准备考场和考生 (基础设置)</h4>
<p>首先，你需要告诉电脑：我们要用哪个 AI 模型（考生），以及我们要用多少显卡（考场设备）。</p>
<p><strong>代码对应：</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 如果没指定 MODEL_PATH，就用默认路径（这里指向一个训练了 19751 步的模型）</span>
<span class="nv">MODEL_PATH</span><span class="o">=</span><span class="si">${</span><span class="nv">MODEL_PATH</span><span class="k">:-</span><span class="p">/path/to/ckpt/global_step_19751/huggingface</span><span class="si">}</span>

<span class="c1"># 每个节点用 8 张显卡</span>
<span class="nv">NGPUS_PER_NODE</span><span class="o">=</span><span class="si">${</span><span class="nv">NGPUS_PER_NODE</span><span class="k">:-</span><span class="nv">8</span><span class="si">}</span>
<span class="c1"># 用 1 个节点（机器）</span>
<span class="nv">NNODES</span><span class="o">=</span><span class="si">${</span><span class="nv">NNODES</span><span class="k">:-</span><span class="nv">1</span><span class="si">}</span>
<span class="c1"># 考试结果存到哪里</span>
<span class="nv">OUTPUT_PATH</span><span class="o">=</span><span class="si">${</span><span class="nv">OUTPUT_PATH</span><span class="k">:-</span><span class="nv">$HOME</span><span class="p">/data/gen/qwen_8b_gen_test.parquet</span><span class="si">}</span>
<span class="c1"># 模型的并行度（如果模型太大，一张卡装不下，需要切分，这里设为1表示不切分或默认值）</span>
<span class="nv">GEN_TP</span><span class="o">=</span><span class="si">${</span><span class="nv">GEN_TP</span><span class="k">:-</span><span class="nv">1</span><span class="si">}</span>
</code></pre></div>

<ul>
<li><strong>解读：</strong> 这里定义了“谁来考”（Model）、“在哪考”（GPU数量）、“考卷交哪里”（Output Path）。</li>
</ul>
<h4>✅ Task 2: 准备试卷 (数据输入)</h4>
<p>接下来，你需要拿出试题。这里使用的是 AIME（美国数学邀请赛）的题目，难度很高。</p>
<p><strong>代码对应：</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nv">aime24_test_path</span><span class="o">=</span><span class="si">${</span><span class="nv">HOME</span><span class="si">}</span>/data/math-ai/aime24_test.parquet
<span class="nv">aime25_test_path</span><span class="o">=</span><span class="si">${</span><span class="nv">HOME</span><span class="si">}</span>/data/math-ai/aime25_test.parquet
<span class="c1"># 把两年的考题打包成一个列表</span>
<span class="nv">train_files</span><span class="o">=</span><span class="s2">&quot;[&#39;</span><span class="nv">$aime24_test_path</span><span class="s2">&#39;, &#39;</span><span class="nv">$aime25_test_path</span><span class="s2">&#39;]&quot;</span>
</code></pre></div>

<ul>
<li><strong>解读：</strong> 这里指定了输入数据文件。虽然变量名叫 <code>train_files</code>，但在生成的语境下，这就是<strong>测试题库</strong>。</li>
</ul>
<h4>✅ Task 3: 制定考试规则 (参数配置)</h4>
<p>这是最长的一段。你需要启动 Python 程序，并告诉它考试的具体规则：是随便写写，还是认真思考？每道题做几遍？</p>
<p><strong>代码对应：</strong></p>
<div class="codehilite"><pre><span></span><code>python3<span class="w"> </span>-m<span class="w"> </span>verl.trainer.main_generation_server<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>trainer.nnodes<span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">NNODES</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>trainer.n_gpus_per_node<span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">NGPUS_PER_NODE</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>...
</code></pre></div>

<p>我们需要拆解这些复杂的参数，看看它们代表什么规则：</p>
<ol>
<li>
<p><strong>加载考生：</strong></p>
<ul>
<li><code>actor_rollout_ref.model.path</code>: 载入 Task 1 里定义的模型。</li>
<li><code>trust_remote_code=True</code>: 允许运行模型自带的代码（通常 Qwen 等新模型需要这个）。</li>
</ul>
</li>
<li>
<p><strong>答题风格 (Temperature &amp; Top P)：</strong></p>
<ul>
<li><code>rollout.temperature=1.0</code>: <strong>创造力/随机性</strong>。1.0 表示比较活跃，不是死板地只选概率最高的词。</li>
<li><code>rollout.top_p=0.7</code>: <strong>严谨度</strong>。只在概率总和为 70% 的靠谱词汇里选，防止胡言乱语。</li>
</ul>
</li>
<li>
<p><strong>答题篇幅 (Length)：</strong></p>
<ul>
<li><code>rollout.prompt_length=2048</code>: 题目最长能有多少字。</li>
<li><code>rollout.response_length=20480</code>: <strong>回答允许写多长</strong>。注意这里设了 2万多 token，说明这是在做<strong>长思维链 (Chain-of-Thought)</strong> 推理，允许 AI 写很长的解题步骤。</li>
</ul>
</li>
<li>
<p><strong>考试策略 (Sampling)：</strong></p>
<ul>
<li><code>rollout.n=32</code>: <strong>题海战术</strong>。对于<strong>每一个</strong>问题，让 AI 生成 <strong>32 个</strong> 不同的回答。</li>
<li><em>为什么要这样做？</em> 因为数学题很难，AI 可能会算错。生成 32 个答案后，通常会用“多数投票”或者验证器来选出正确答案（Pass@K 指标）。</li>
</ul>
</li>
<li>
<p><strong>加速引擎 (vLLM)：</strong></p>
<ul>
<li><code>rollout.name=vllm</code>: 使用 <strong>vLLM</strong> 这个库来推理。它比普通的 HuggingFace 推理快非常多，显存管理更好。</li>
<li><code>gpu_memory_utilization=0.9</code>: 允许 vLLM 占用 90% 的显存，把性能拉满。</li>
</ul>
</li>
</ol>
<h4>✅ Task 4: 收集试卷 (输出)</h4>
<p>最后，把所有考生的 32 份回答整理好。</p>
<p><strong>代码对应：</strong></p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span>data.train_files<span class="o">=</span><span class="s2">&quot;</span><span class="nv">$train_files</span><span class="s2">&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span>data.prompt_key<span class="o">=</span>prompt<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>+data.output_path<span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">OUTPUT_PATH</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="se">\</span>
</code></pre></div>

<ul>
<li><strong>解读：</strong> 这里告诉程序，题目在 parquet 文件的哪一列（<code>prompt</code>），考完试的结果存到 Task 1 定义的 <code>OUTPUT_PATH</code> 里。</li>
</ul>
<hr />
<h3>总结：这个脚本在干嘛？</h3>
<p>用一句话说：
<strong>这个脚本使用 vLLM 加速引擎，让一个 Qwen-8B 模型去“参加” AIME 数学竞赛，每道题尝试解 32 次，并允许它进行超长的思考（20k tokens），最后把所有解题过程保存下来。</strong></p>
<p>这通常是用来评估模型数学能力（看 32 次里能对几次），或者是为了生成高质量的训练数据（把 32 次里做对的那些挑出来去训练下一个模型）。</p>