<h1>docs/sglang_multiturn/interaction_system.rst</h1>
<p>这份文档确实比较技术化，它主要介绍了一个用于<strong>强化学习（RL）训练</strong>的<strong>多轮交互系统</strong>。</p>
<p>简单来说，它的核心思想是：<strong>在训练AI时，不仅是“问一个问题，AI回一个答案，然后打分”，而是让AI在生成答案的过程中，能和一个“交互代理（Agent）”进行多轮对话，根据反馈不断调整，最后再打分。</strong></p>
<p>为了让你听懂，我把这个文档的内容拆解成一个 <strong>“搭建多轮交互训练系统”的 To-Do List</strong>，一步步带你过一遍。</p>
<hr />
<h3>✅ 任务清单：从零搭建多轮交互 RL 系统</h3>
<h4>1. 理解核心概念 (Overview)</h4>
<ul>
<li><strong>目标</strong>：让模型在训练中能“多轮对话”。</li>
<li><strong>场景</strong>：比如做数学题，模型做了一步，交互系统（像个老师）提示“这里错了”，模型再改，直到做对或次数用完。</li>
<li><strong>新特性</strong>：<strong>支持多种交互模式混用</strong>。以前只能全班都上数学课，现在可以同一个batch里，有的样本上数学课（用数学交互逻辑），有的上编程课（用代码运行器交互逻辑）。</li>
</ul>
<h4>2. 编写“交互老师”的代码 (Implementation)</h4>
<p>你需要写一个 Python 类，定义这个“老师”怎么跟模型互动。文档要求必须继承 <code>BaseInteraction</code> 类。
*   <strong>TODO 2.1 - <code>start_interaction</code></strong>: 课程开始。初始化环境，比如生成一个唯一的 ID。
*   <strong>TODO 2.2 - <code>generate_response</code></strong>: 核心互动逻辑。
    *   模型说了一句话。
    *   你（代码）判断对不对。
    *   <strong>返回结果</strong>：
        1.  <code>should_terminate</code>: 是否结束对话？（比如做对了，或者太笨了尝试次数超标了）。
        2.  <code>response</code>: 给模型的反馈（例如：“你算错了，再想想” 或 “正确！”）。
        3.  <code>score</code>: 当前这一轮的得分。
*   <strong>TODO 2.3 - <code>calculate_score</code></strong>: 算分逻辑（比如跟标准答案比对）。
*   <strong>TODO 2.4 - <code>finalize_interaction</code></strong>: 下课了，清理内存。</p>
<blockquote>
<p><strong>例子 (GSM8K)</strong>：文档里给了个数学题的例子。如果模型答案对不上标准答案，系统就回“错了，再试试”，如果对了就回“正确”并给满分。</p>
</blockquote>
<h4>3. 配置“花名册” (Configuration)</h4>
<p>写好了代码，你得告诉系统去哪里找这些“老师”。你需要写一个 YAML 配置文件。
*   <strong>TODO 3.1</strong>: 创建 <code>interaction_config.yaml</code>。
*   <strong>TODO 3.2</strong>: 在里面注册你的交互类。
    *   给它起个名字（比如 <code>name: "math_teacher"</code>）。
    *   指定代码路径（<code>class_name: "..."</code>）。
    *   可以注册多个（比如再加一个 <code>name: "code_verifier"</code>）。</p>
<h4>4. 准备训练数据 (Data Requirements)</h4>
<p>你的训练数据不仅要有 Prompt（提示词），还要指定<strong>这一题由哪位老师负责</strong>。
*   <strong>TODO 4.1</strong>: 在数据集中添加 <code>interaction_kwargs</code> 字段。
*   <strong>TODO 4.2</strong>: 指定 <code>name</code>。
    *   比如样本 A 是数学题，就写 <code>{"name": "math_teacher", "answer": "42"}</code>。
    *   样本 B 是代码题，就写 <code>{"name": "code_verifier", "test_case": "..."}</code>。
*   <em>如果不写名字，系统为了兼容旧版本，会默认使用 "gsm8k" 这个名字。</em></p>
<h4>5. 启动训练 (Training Integration)</h4>
<p>最后，在运行训练脚本时，把开关打开。
*   <strong>TODO 5.1</strong>: 在启动命令中开启多轮支持 (<code>multi_turn.enable: true</code>)。
*   <strong>TODO 5.2</strong>: 指向刚才写的配置文件路径 (<code>interaction_config_path: "..."</code>)。
*   <strong>TODO 5.3</strong>: 设置最大允许的回合数（防止模型和老师无限聊下去）。</p>
<hr />
<h3>总结一下它的工作流 (Lifecycle)</h3>
<p>想象一个学生（模型）在做题：</p>
<ol>
<li><strong>PENDING (准备)</strong>: 系统调用 <code>start_interaction</code>，老师准备好考题和答案。</li>
<li><strong>GENERATING (做题)</strong>: 模型生成了一段回答。</li>
<li><strong>INTERACTING (批改)</strong>: 系统暂停模型生成，把回答扔给 <code>generate_response</code>。<ul>
<li>老师看了一眼，发现错了，回复：“第2步错了”。</li>
</ul>
</li>
<li><strong>GENERATING (修正)</strong>: 模型收到反馈，继续生成下一段回答。</li>
<li><strong>COMPLETED (结束)</strong>: 模型终于做对了，或者老师觉得没救了（达到最大轮数），标记结束，计算最终奖励 (Reward)。</li>
</ol>
<h3>为什么这个系统很厉害？</h3>
<ul>
<li><strong>异步 (Async)</strong>：批改作业的时候不会卡住整个训练流程，效率高。</li>
<li><strong>灵活 (Sample-Level)</strong>：这就好比在一个教室里，同时在教数学、语文和编程，系统会自动给每个学生分配对应的老师，而不是强制所有人上同一门课。</li>
</ul>
<p>希望这个 List 能帮你读懂这篇文档！</p>