<h1>docs/sglang_multiturn/sandbox_fusion.rst</h1>
<p>这份文档其实是一份<strong>工程设计文档（Design Doc）</strong>。它的背景是：开发人员正在为一个叫 <code>verl</code> 的大模型训练框架添加功能。</p>
<p>简单来说，他们的目标是：<strong>让正在训练中的 AI 模型（Actor）不仅能说话，还能写 Python 代码，并且把代码发到一个安全的“沙盒”里运行，拿到结果后再继续训练。</strong></p>
<p>为了让你更容易理解，我把这份文档的内容拆解成一个<strong>“开发者的 To-Do List（任务清单）”</strong>，按照逻辑顺序一步步给你讲：</p>
<hr />
<h3>✅ 任务清单：为 AI 植入“代码执行”能力</h3>
<h4>第一阶段：立项与需求分析 (Motivations &amp; Goals)</h4>
<p><strong>核心任务：</strong> 决定我们要干什么，不干什么。</p>
<ol>
<li><strong>[TODO] 确立目标：</strong> 我们要让 AI 在生成内容的过程中（Rollout 阶段），能够调用工具（Tool-calling）。</li>
<li><strong>[TODO] 选定方案：</strong> 以前是直接在本地跑代码（不安全、难扩展），现在的任务是把代码发给一个远程的、安全的服务器去跑。这个远程服务叫 <code>Sandbox Fusion</code>（基于 FaaS - 函数即服务）。</li>
<li><strong>[TODO] 划定边界（Non-Goals）：</strong><ul>
<li>这次只管“怎么跑通代码”，不管“跑得好不好（训练效果）”。</li>
<li>不管服务器挂了怎么办（容错）。</li>
<li>不管监控指标。</li>
</ul>
</li>
</ol>
<h4>第二阶段：定规矩 (Design Details - Schema)</h4>
<p><strong>核心任务：</strong> 告诉 AI 怎么使用这个工具。</p>
<ol>
<li><strong>[TODO] 定义接口（Tool Schema）：</strong><ul>
<li>我们需要告诉 AI：“嘿，你可以用一个叫 <code>code_interpreter</code> 的工具。”</li>
<li>规定 AI 必须传回来的数据格式是 JSON，里面必须包含一个叫 <code>code</code> 的字段（就是它想写的 Python 代码）。</li>
<li><em>文档里的 <code>OpenAIFunctionToolSchema</code> 代码块就是在做这件事。</em></li>
</ul>
</li>
</ol>
<h4>第三阶段：交通管制 (Rate Limiting Design)</h4>
<p><strong>核心任务：</strong> 防止 AI 疯狂发请求把远程沙盒服务器冲垮。</p>
<ol>
<li><strong>[TODO] 设计“限流器”（Rate Limiter）：</strong><ul>
<li><strong>问题：</strong> 如果几百个 AI 进程同时发代码去运行，远程服务器会报 <code>429 Too Many Requests</code> 错误。</li>
<li><strong>解决：</strong> 做一个“令牌桶”算法。</li>
<li><strong>具体实现：</strong><ul>
<li>利用 Ray（一个分布式计算框架）创建一个全局的“计数员”（Global Actor）。</li>
<li>设置一个上限（比如 <code>rate_limit=10</code>），意味着同时只能有 10 个代码在跑。</li>
<li>想跑代码的进程必须先去“计数员”那里领号（<code>acquire</code>），跑完还号（<code>release</code>）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4>第四阶段：核心代码实现 (Tool Implementation)</h4>
<p><strong>核心任务：</strong> 写 Python 代码把上面的一切串起来。</p>
<ol>
<li><strong>[TODO] 实现工具类 <code>SandboxFusionTool</code>：</strong><ul>
<li><strong>接收订单：</strong> 拿到 AI 生成的代码。</li>
<li><strong>排队：</strong> 去刚才写的“限流器”那里排队。</li>
<li><strong>发货与收货：</strong> 轮到自己后，把代码发给远程的 <code>sandbox_fusion_url</code>，等待运行结果（比如 <code>stdout</code> 输出）。</li>
<li><strong>反馈：</strong> 把运行结果（比如计算出的数字）塞回给 AI，让 AI 根据这个结果继续说话。</li>
</ul>
</li>
</ol>
<h4>第五阶段：测试与验收 (Test Plan &amp; E2E)</h4>
<p><strong>核心任务：</strong> 证明这套系统能用。</p>
<ol>
<li>
<p><strong>[TODO] 单元测试（Unit Tests）：</strong></p>
<ul>
<li>测试如果代码太长了会怎么样？</li>
<li>测试如果是批量请求会怎么样？</li>
<li>测试限流器是不是真的能拦住超量的请求？</li>
</ul>
</li>
<li>
<p><strong>[TODO] 端到端测试（E2E Tests）：</strong></p>
<ul>
<li><strong>场景：</strong> 让 AI 做一道 GSM8K 数学题。</li>
<li><strong>预期流程：</strong><ol>
<li>用户问：John 去年赚 10万，奖金 1万。今年赚 20万，奖金比例一样，今年总共赚多少？</li>
<li>AI 思考：我要算一下比例。</li>
<li><strong>AI 调用工具：</strong> 生成 Python 代码 <code>print(200000 + 200000 * (10000/100000))</code>。</li>
<li><strong>系统介入：</strong> 沙盒运行代码，返回 <code>220000.0</code>。</li>
<li><strong>AI 继续：</strong> 看到结果是 22万，于是回答：“答案是 220000”。</li>
</ol>
</li>
<li><em>文档最后展示的那个很长的 JSON 和对话记录，就是这个测试成功的证据。</em></li>
</ul>
</li>
</ol>
<hr />
<h3>总结</h3>
<p>这篇文档讲的就是：<strong>如何在一个大规模的 AI 训练系统中，安全、有序、受控地加入“远程代码执行”功能，让 AI 变成能写代码并获得运行结果的“程序员”。</strong></p>