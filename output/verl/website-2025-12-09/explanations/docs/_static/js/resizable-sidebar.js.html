<h1>docs/_static/js/resizable-sidebar.js</h1>
<p>这份代码其实是为了解决两个非常具体的<strong>用户体验问题</strong>，主要用于像 Sphinx/ReadTheDocs 这种文档网站。</p>
<p>为了让你更容易理解，我们可以把这段代码想象成一个程序员接到的<strong>两个主要开发任务（Task）</strong>。</p>
<p>我为你列了一个 Todo List，并按照代码的执行逻辑一步步给你讲解。</p>
<hr />
<h3>任务一：做一个可以拖拽调整宽度的侧边栏</h3>
<p><strong>目标</strong>：用户觉得左侧目录栏太窄或太宽，想要自己用鼠标拖动调整，而且刷新页面后还要记住这个宽度。</p>
<h4>✅ 第一步：准备工作 (初始化)</h4>
<ul>
<li><strong>代码逻辑</strong>：<ul>
<li>找到侧边栏元素 (<code>.wy-nav-side</code>) 和内容区域元素 (<code>.wy-nav-content-wrap</code>)。</li>
<li>如果找不到这两个元素，代码就直接停止（防止报错）。</li>
<li><strong>创建“把手”</strong>：用代码在侧边栏边缘生成一个透明的竖条 (<code>div.resize-handle</code>)，这就是用户鼠标要去“抓”的地方。</li>
</ul>
</li>
</ul>
<h4>✅ 第二步：读取记忆 (加载配置)</h4>
<ul>
<li><strong>代码逻辑</strong>：<ul>
<li><strong>检查本地存储</strong>：打开网页时，先问问浏览器 <code>localStorage</code>：“上次用户把宽度设为多少了？”</li>
<li><strong>安全检查</strong>：如果读取到的宽度太离谱（比如小于200或大于600），就恢复默认值（300px）。</li>
<li><strong>应用宽度</strong>：把这个宽度赋值给侧边栏，同时调整右侧内容的左边距（<code>margin-left</code>），确保内容不被遮挡。</li>
</ul>
</li>
</ul>
<h4>✅ 第三步：实现拖拽 (鼠标事件三部曲)</h4>
<p>这是这段代码的核心交互逻辑：</p>
<ol>
<li>
<p><strong>鼠标按下 (<code>mousedown</code>)</strong>：</p>
<ul>
<li>当你在“把手”上按下鼠标时，开关打开 (<code>isResizing = true</code>)。</li>
<li>记录当前鼠标的位置（X坐标）和侧边栏当前的宽度。</li>
<li><strong>小技巧</strong>：代码创建了一个全屏透明的遮罩层 (<code>overlay</code>)。这是为了防止你拖得太快，鼠标滑到了页面里的 iframe 或其他元素上导致拖拽失效。</li>
</ul>
</li>
<li>
<p><strong>鼠标移动 (<code>mousemove</code>)</strong>：</p>
<ul>
<li>只要开关是开着的，就计算：<code>新宽度 = 初始宽度 + (鼠标现在的X - 鼠标刚按下的X)</code>。</li>
<li><strong>限制范围</strong>：代码里写死了 <code>Math.max(200, Math.min(600, width))</code>，意思是侧边栏最窄 200px，最宽 600px，不能无限拖。</li>
<li>实时更新页面上的宽度。</li>
</ul>
</li>
<li>
<p><strong>鼠标松开 (<code>mouseup</code>)</strong>：</p>
<ul>
<li>开关关闭 (<code>isResizing = false</code>)。</li>
<li>移除那个透明遮罩层。</li>
<li><strong>保存记忆</strong>：把最终的宽度写入 <code>localStorage</code>，这样你下次刷新页面，宽度还是保持这样。</li>
</ul>
</li>
</ol>
<h4>✅ 第四步：快捷重置</h4>
<ul>
<li><strong>代码逻辑</strong>：<ul>
<li>如果你在“把手”上<strong>双击</strong> (<code>dblclick</code>)，侧边栏会瞬间变回默认的 300px。</li>
</ul>
</li>
</ul>
<hr />
<h3>任务二：修复导航栏遮挡内容的 Bug</h3>
<p><strong>目标</strong>：因为网页顶部通常有一个固定的导航栏（Header），当用户点击左侧目录跳转时，标题往往会被顶部的导航栏挡住。这个任务就是为了解决这个问题。</p>
<h4>✅ 第一步：等待菜单加载 (MutationObserver)</h4>
<ul>
<li><strong>背景</strong>：有时候侧边栏的菜单是后来才加载出来的（动态生成）。</li>
<li><strong>代码逻辑</strong>：<ul>
<li>使用 <code>MutationObserver</code>（变动观察者）。它像一个监控摄像头，盯着页面看。</li>
<li>一旦发现侧边栏里加入了新的链接 (<code>&lt;a&gt;</code>标签)，立刻执行修复逻辑。</li>
</ul>
</li>
</ul>
<h4>✅ 第二步：劫持点击事件 (暴力替换)</h4>
<ul>
<li><strong>代码逻辑</strong>：<ul>
<li>找到侧边栏所有的链接。</li>
<li><strong>克隆节点</strong>：<code>link.cloneNode(true)</code>。这招很“暴力”，它会把原本链接上绑定的所有乱七八糟的事件全部清除，只保留我们下面要写的逻辑。</li>
<li><strong>监听点击</strong>：给新链接加上我们自己的点击事件。</li>
</ul>
</li>
</ul>
<h4>✅ 第三步：计算精准位置 (核心修复)</h4>
<p>当用户点击链接时，代码会判断：
1.  <strong>如果是外部链接</strong>（比如跳转到 Google）：不管它，直接跳。
2.  <strong>如果是页内锚点</strong>（比如 <code>#section-1</code>）：
    *   阻止默认的跳转行为（<code>e.preventDefault()</code>）。
    *   找到目标标题在页面上的位置。
    *   <strong>关键算术题</strong>：<code>目标位置 - 60px</code>。这里的 <code>60</code> 就是顶部导航栏的高度。
    *   <strong>平滑滚动</strong>：使用 <code>window.scrollTo({ behavior: 'smooth' })</code> 让页面优雅地滑过去，而不是生硬地跳过去，并且正好停在标题露出来的地方。</p>
<h4>✅ 第四步：处理页面刚打开的情况</h4>
<ul>
<li><strong>代码逻辑</strong>：<ul>
<li>如果用户直接通过带 <code>#</code> 的网址打开页面（例如发给别人的链接），代码会检测 <code>window.location.hash</code>。</li>
<li>同样执行上面的“减去 60px”的逻辑，确保用户一进来看到的标题没被遮住。</li>
</ul>
</li>
</ul>
<hr />
<h3>总结</h3>
<p>这段代码其实就是为了让文档网站变得<strong>“好用”</strong>：
1.  <strong>前半部分</strong>：让你能<strong>拖拽</strong>侧边栏，并且记住你的喜好。
2.  <strong>后半部分</strong>：让你点击目录时，页面能<strong>滚动</strong>到正确的位置，不被顶部菜单挡住。</p>