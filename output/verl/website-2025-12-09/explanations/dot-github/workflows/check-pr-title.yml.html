<h1>.github/workflows/check-pr-title.yml</h1>
<p>这个文件确实容易让人晕，因为它其实是<strong>“一份项目说明书” + “一段具体的执行代码”</strong> 混合在一起了。</p>
<p>上面的大部分英文注释（#号开头的）其实是在介绍整个项目的测试架构，而下面的一小段代码才是这个文件真正要做的事情。</p>
<p>为了让你彻底搞懂，我把阅读和理解这个文件拆解成一个 <strong>Task List (待办清单)</strong>，我们一步一步来打勾完成。</p>
<hr />
<h3>✅ Task 1: 搞懂“地图” —— 测试文件夹是怎么分类的？</h3>
<p><strong>（对应文件开头 <code>Tests layout</code> 部分）</strong></p>
<p>首先，作者在注释里画了一张地图，告诉我们在 <code>tests/</code> 这个文件夹下，东西是怎么摆放的：</p>
<ul>
<li><strong>普通功能测试</strong>：按照模块分。比如 <code>tests/trainer</code> 测训练器，<code>tests/models</code> 测模型。</li>
<li><strong>特殊功能测试</strong>（带 <code>special_</code> 前缀的）：<ul>
<li><code>special_distributed</code>: 必须用多张显卡（GPU）才能跑的测试。</li>
<li><code>special_e2e</code>: 端到端测试（从头跑到尾，比如完整的训练流程）。</li>
<li><code>special_npu</code>: 专门给 NPU（另一种AI芯片）跑的。</li>
<li><code>special_sanity</code>: <strong>快速健康检查</strong>（比如查查代码格式、拼写，不用跑大模型）。</li>
<li><code>special_standalone</code>: 需要独立环境跑的测试。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>观点 1</strong>：测试代码不能乱放，要按功能分，特殊的（比如费显卡的）要单独拎出来。</p>
</blockquote>
<hr />
<h3>✅ Task 2: 搞懂“规则” —— CPU 和 GPU 怎么分？</h3>
<p><strong>（对应文件中间 <code>Accelerators for tests</code> 部分）</strong></p>
<p>这里作者定了一个“起名规则”，用来区分哪些测试用 CPU 跑，哪些用 GPU 跑：</p>
<ul>
<li><strong>默认情况</strong>：只要你没特殊说明，默认都认为你要用 <strong>GPU</strong>。</li>
<li><strong>例外情况</strong>：<ul>
<li>如果文件名结尾是 <code>_on_cpu.py</code>，那就强制在 <strong>Linux CPU</strong> 环境下跑。</li>
<li><code>special_npu</code> 文件夹里的不用 GPU。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>观点 2</strong>：通过文件名后缀（<code>_on_cpu.py</code>）来自动区分硬件需求，省得每次都要手动配置。</p>
</blockquote>
<hr />
<h3>✅ Task 3: 搞懂“流水线” —— 自动化测试分几步走？</h3>
<p><strong>（对应文件 <code>Workflow layout</code> 部分）</strong></p>
<p>这里介绍了 GitHub 里的自动机器人（CI）是怎么工作的。它把测试分成了四个梯队：</p>
<ol>
<li><strong>必查的轻量级测试（CPU Sanity）</strong>：<ul>
<li>每次都要跑，速度快。</li>
<li>包括：<strong>检查PR标题（就是本文件）</strong>、查密钥泄露、查文档格式等。</li>
</ul>
</li>
<li><strong>重型多卡测试</strong>：<ul>
<li>跑得慢，费资源。比如 <code>model.yml</code>, <code>vllm.yml</code>。</li>
</ul>
</li>
<li><strong>端到端测试 (E2E)</strong>：<ul>
<li>模拟真实用户跑全流程。</li>
</ul>
</li>
<li><strong>单元测试 (Unit Tests)</strong>：<ul>
<li><strong>CPU单元测试</strong>：专门跑那些名字带 <code>_on_cpu.py</code> 的文件。</li>
<li><strong>GPU单元测试</strong>：跑剩下那些不带后缀的文件。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>观点 3</strong>：测试要有层次。先跑简单的（查标题），再跑复杂的（跑模型）。如果你加了新测试，记得别让 CPU 和 GPU 测试重复跑同一个文件。</p>
</blockquote>
<hr />
<h3>✅ Task 4: 执行“任务” —— 这个文件具体在干啥？</h3>
<p><strong>（对应文件最下方的 <code>on:</code> 和 <code>jobs:</code> 代码部分）</strong></p>
<p>读完了上面的“说明书”，这里才是这个文件 <code>check-pr-title.yml</code> 真正干活的地方。</p>
<ul>
<li><strong>触发时机 (<code>on</code>)</strong>：<ul>
<li>当有人提交 Pull Request (PR)，或者修改 PR，或者同步代码时。</li>
</ul>
</li>
<li><strong>执行步骤 (<code>steps</code>)</strong>：<ol>
<li><strong>Checkout code</strong>: 把代码下载下来。</li>
<li><strong>Set up Python</strong>: 装个 Python 3.11 环境。</li>
<li><strong>Run PR title checker</strong>: 运行一个脚本 <code>tests/special_sanity/check_pr_title.py</code>，专门检查你的 <strong>PR 标题</strong>写得规不规范。</li>
<li><strong>Run PR description checker</strong>: 运行另一个脚本，检查你的 <strong>PR 描述</strong>（详细说明）写得对不对。</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>观点 4</strong>：代码写得好还不够，提交代码时的“标题”和“说明”也必须符合规范（比如必须写清楚是 fix bug 还是 feature），否则不让过。</p>
</blockquote>
<hr />
<h3>总结 (Summary)</h3>
<p>如果你要给同事讲这个文件，你可以这么说：</p>
<blockquote>
<p>“这个文件是一个<strong>GitHub Action 配置文件</strong>。</p>
<ol>
<li>它的<strong>主要功能</strong>是：在每次提交 PR 时，自动检查<strong>标题和描述</strong>是否符合规范（属于最基础的 Sanity Check）。</li>
<li>但它同时在开头的注释里，<strong>充当了整个项目的测试文档</strong>，解释了文件夹结构、CPU/GPU 测试文件的命名规则，以及整个 CI 流水线的分类。”</li>
</ol>
</blockquote>