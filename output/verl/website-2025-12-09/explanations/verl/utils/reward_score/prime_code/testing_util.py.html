<h1>verl/utils/reward_score/prime_code/testing_util.py</h1>
<p>这份代码文件 <code>testing_util.py</code> 的核心作用是<strong>构建一个自动化的判题系统（Online Judge）</strong>。</p>
<p>简单来说，它的工作就是：<strong>拿一段生成的代码，喂给它输入数据，看它的输出是否和标准答案一致。</strong></p>
<p>为了让你更容易理解，我把它想象成一个<strong>“判卷老师”</strong>，并将它执行任务的流程拆解为一个 TODO List。</p>
<hr />
<h3>📝 判卷老师的任务清单 (Task Todo List)</h3>
<p>这个 <code>run_test</code> 函数就是判卷老师的主脑，它的工作流程如下：</p>
<h4>Phase 1: 考前安检与准备 (Preparation)</h4>
<ol>
<li><strong>[ ] 没收危险工具 (<code>reliability_guard</code>)</strong><ul>
<li><strong>动作</strong>：在运行代码前，先把 <code>os.system</code>, <code>os.remove</code>, <code>subprocess</code> 等功能禁用了。</li>
<li><strong>目的</strong>：防止生成的代码搞破坏（比如删除系统文件、无限通过 <code>fork</code> 炸内存）。</li>
</ul>
</li>
<li><strong>[ ] 确认考试题型 (<code>CODE_TYPE</code>)</strong><ul>
<li><strong>动作</strong>：检查题目类型。</li>
<li><strong>Type A (Call-based)</strong>：类似 LeetCode，给你一个函数名（如 <code>def solve(x):</code>），我调用函数检查返回值。</li>
<li><strong>Type B (Standard Input)</strong>：类似 ACM/Codeforces，代码直接从键盘读数据 (<code>input()</code>) 并打印到屏幕 (<code>print()</code>)。</li>
</ul>
</li>
</ol>
<h4>Phase 2: 试卷整理与预处理 (Compilation)</h4>
<ol>
<li><strong>[ ] 补充辅助工具 (Imports)</strong><ul>
<li><strong>动作</strong>：在用户代码前面自动加上一大堆 <code>import</code> (如 <code>math</code>, <code>re</code>, <code>collections</code>)。</li>
<li><strong>目的</strong>：防止用户代码因为忘记引用常见库而报错。</li>
</ul>
</li>
<li><strong>[ ] 代码整形 (AST Parsing)</strong><ul>
<li><strong>如果</strong>是 Type B (标准输入模式)：<ul>
<li>判卷老师会用 <code>ast</code> 模块修改代码，把全局代码塞进一个叫 <code>def code():</code> 的函数里。</li>
<li>会把 <code>if __name__ == "__main__":</code> 这类代码块去掉，防止重复运行出错。</li>
</ul>
</li>
</ul>
</li>
<li><strong>[ ] 编译代码 (RuntimeModule)</strong><ul>
<li><strong>动作</strong>：尝试编译这段代码。</li>
<li><strong>结果</strong>：如果编译这就挂了（语法错误），直接打分 <code>-2</code> 并记录错误信息。</li>
</ul>
</li>
</ol>
<h4>Phase 3: 逐题批改 (Execution Loop)</h4>
<p>这里开始遍历每一个测试用例（Input/Output Pair）：</p>
<ol>
<li><strong>[ ] 设置闹钟 (Timeout)</strong><ul>
<li><strong>动作</strong>：在运行每个测试点前，设置 <code>signal.alarm(timeout)</code>。</li>
<li><strong>目的</strong>：如果代码死循环或者跑太慢，闹钟一响直接强行终止，判为超时。</li>
</ul>
</li>
<li><strong>[ ] 运行代码 (Execution)</strong><ul>
<li><strong>Type A (函数模式)</strong>：<ul>
<li>直接执行 <code>output = method(*inputs)</code>，拿到返回值。</li>
</ul>
</li>
<li><strong>Type B (输入流模式)</strong>：<ul>
<li>使用 <code>Capturing</code> 上下文管理器截获 <code>sys.stdout</code>（屏幕输出）。</li>
<li>使用 <code>mock</code> 技术把 <code>sys.stdin</code>（键盘输入）替换成测试数据。</li>
<li>执行代码，把打印到屏幕的内容作为 <code>output</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>[ ] 捕捉异常 (Error Handling)</strong><ul>
<li><strong>动作</strong>：如果在运行过程中代码崩了（Runtime Error），记录错误，打分 <code>-1</code>。</li>
</ul>
</li>
</ol>
<h4>Phase 4: 答案比对 (Validation / Grading)</h4>
<p>这是代码中最复杂的部分，因为生成的答案可能有各种格式，判卷老师会尝试多种姿势来核对答案：</p>
<ol>
<li><strong>[ ] 尝试 1：严格匹配</strong><ul>
<li><strong>动作</strong>：直接看 <code>output == expected</code> 是否为 True。</li>
</ul>
</li>
<li><strong>[ ] 尝试 2：去空格/换行匹配</strong><ul>
<li><strong>动作</strong>：如果直接匹配失败，尝试去掉字符串首尾的空格、换行符再比对。</li>
</ul>
</li>
<li><strong>[ ] 尝试 3：列表/元组兼容</strong><ul>
<li><strong>动作</strong>：有时候答案是 <code>(1, 2)</code> 但代码返回 <code>[1, 2]</code>，判卷老师会尝试转换类型后再比。</li>
</ul>
</li>
<li><strong>[ ] 尝试 4：浮点数匹配</strong><ul>
<li><strong>动作</strong>：如果答案是数字，用 <code>np.allclose</code> 检查。比如答案是 <code>3.333333</code>，你算出来 <code>3.333334</code>，也算你对。</li>
</ul>
</li>
<li><strong>[ ] 尝试 5：集合匹配 (无序匹配)</strong><ul>
<li><strong>动作</strong>：如果顺序不重要（比如题目问“有哪些元素”），把输出转成 <code>set</code> 集合再比对。</li>
</ul>
</li>
</ol>
<h4>Phase 5: 登记成绩 (Reporting)</h4>
<ol>
<li><strong>[ ] 输出结果</strong><ul>
<li><strong>动作</strong>：返回一个列表 <code>results</code>（比如 <code>[True, True, False]</code>）和一个包含错误详情的字典（如果有错的话）。</li>
</ul>
</li>
</ol>
<hr />
<h3>总结文中的几个关键技术点</h3>
<p>如果你是开发者，这几个点值得注意：</p>
<ol>
<li><strong>沙盒机制 (<code>reliability_guard</code>)</strong>：虽然代码里写了这不是完全安全的沙盒，但它通过置空 <code>os</code> 和 <code>subprocess</code> 下的危险函数，做了一个基础的防护。</li>
<li><strong>IO 劫持 (<code>Capturing</code> &amp; <code>call_method</code>)</strong>：为了测试那些写了 <code>print()</code> 和 <code>input()</code> 的脚本，它使用了 <code>unittest.mock</code> 和 <code>io.StringIO</code> 把程序的输入输出管道接管了。代码以为自己在读键盘，其实是在读内存里的字符串。</li>
<li><strong>AST 魔法</strong>：对于脚本式的代码，它利用 Python 的抽象语法树（AST）库，动态地把脚本改写成了函数。这是一个非常高阶的技巧，避免了使用 <code>subprocess</code> 启动新进程带来的开销。</li>
<li><strong>容错比较</strong>：代码花了很大篇幅处理 <code>custom_compare_</code>，就是为了应对 Python 输出格式的多样性（比如列表里有没有换行，最后有没有空格），提高判题的准确率。</li>
</ol>
<p>希望这个 Todo List 能帮你理解这份代码在干什么！</p>