<h1>verl/utils/reward_score/prime_math/<strong>init</strong>.py</h1>
<p>这份代码确实看起来有点“绕”，因为它处理的是一个非常琐碎但重要的问题：<strong>如何判断AI做的数学题对不对？</strong></p>
<p>在数学里，$0.5$、$\frac{1}{2}$、$\frac{2}{4}$ 甚至 $5 \times 10^{-1}$ 都是同一个数，但在计算机看来，它们是完全不同的字符串。这个文件的核心任务就是<strong>“去伪存真”</strong>，把各种花哨的数学写法统一起来，判断AI的答案和标准答案是否在数学上相等。</p>
<p>你可以把这个程序想象成一个<strong>“极其严格但也极其聪明的小学数学阅卷老师”</strong>。</p>
<p>下面我为你列一个 <strong>Task Todo List</strong>，按照代码执行的逻辑顺序，一步步拆解它在干什么：</p>
<hr />
<h3>📝 阅卷老师的 Task Todo List (代码执行流程)</h3>
<h4>✅ Task 1: 从试卷中找到答案 (提取 Extract)</h4>
<p><strong>代码对应：</strong> <code>match_answer</code>, <code>_last_boxed_only_string</code>
*   <strong>情景：</strong> AI 回答问题时往往废话很多，比如：“经过复杂的计算，我认为最后的答案应该是 \boxed{42}。”
*   <strong>动作：</strong>
    *   程序会先找 <code>\boxed{...}</code> 里的内容（这是数学竞赛常用的格式）。
    *   如果找不到，就去搜索关键词，比如 "answer is", "answers are", "Final Answer:" 等等。
    *   <strong>目的：</strong> 把一大段话变成一个干净的字符串，比如把上面那句话变成 <code>"42"</code>。</p>
<h4>✅ Task 2: 给答案“卸妆” (标准化 Normalize)</h4>
<p><strong>代码对应：</strong> <code>_normalize</code>, <code>_parse_latex</code>, <code>_strip_properly_formatted_commas</code>
*   <strong>情景：</strong> 标准答案是 <code>1000</code>，AI 写的是 <code>1,000</code> 或者 <code>1000 meters</code> 或者 <code>\text{1000}</code>。
*   <strong>动作：</strong>
    *   <strong>去单位：</strong> 删掉 "cm", "kg", "degrees" 等单位。
    *   <strong>去格式：</strong> 删掉 LaTeX 的修饰符（如 <code>\text{}</code>, <code>$</code>）。
    *   <strong>去逗号：</strong> 把 <code>1,000</code> 变成 <code>1000</code>。
    *   <strong>翻译符号：</strong> 把 <code>π</code> 变成 <code>pi</code>，把 <code>∞</code> 变成 <code>inf</code>，把 <code>×</code> 变成 <code>*</code>。
    *   <strong>处理带分数：</strong> 把 <code>7 3/4</code> (七又四分之三) 变成 <code>7+3/4</code>，方便电脑计算。
    *   <strong>目的：</strong> 把AI的答案和标准答案都变成最原始、最纯粹的数学表达式格式。</p>
<h4>✅ Task 3: 尝试“一眼定真假” (字符串比对)</h4>
<p><strong>代码对应：</strong> <code>grade_answer</code> 中的 <code>if ground_truth_normalized == given_normalized:</code>
*   <strong>动作：</strong> 直接对比两个字符串。
*   <strong>逻辑：</strong> 如果卸妆后的标准答案是 "42"，AI 的也是 "42"，那直接满分，不用往后算了。</p>
<h4>✅ Task 4: 动用“数学魔法”进行比对 (SymPy 符号计算)</h4>
<p><strong>代码对应：</strong> <code>are_equal_under_sympy</code>, <code>_sympy_parse</code>
*   <strong>情景：</strong> 标准答案是 <code>1/2</code>，AI 写的是 <code>0.5</code>；或者答案是 <code>x + y</code>，AI 写的是 <code>y + x</code>。字符串完全不同，但数学上是对的。
*   <strong>动作：</strong>
    *   这里用到了一个强大的库叫 <code>sympy</code>（符号计算库）。
    *   核心逻辑是：<strong>如果 (标准答案 - AI答案) = 0，那么它们就是相等的。</strong>
    *   程序会构建一个表达式：<code>simplify(标准答案 - AI答案)</code>。
    *   如果计算结果是 0，判定为正确。
*   <strong>特殊处理：</strong> 代码里有一些逻辑（<code>_is_frac</code>, <code>_is_int</code>）规定，如果标准答案是整数或最简分数，有时候不允许 AI 写成小数，必须严格匹配。</p>
<h4>✅ Task 5: 安全检查与防卡死 (Safety)</h4>
<p><strong>代码对应：</strong> <code>should_allow_eval</code>, <code>timeout_limit</code>
*   <strong>动作：</strong>
    *   如果 AI 写了一个超级复杂的恶意代码或者死循环公式，程序可能会卡死。
    *   代码里限制了：如果有太多未知的字母（超过2个变量），或者有奇怪的符号，就拒绝计算，直接判错。
    *   设置了 10秒超时 (<code>timeout_limit</code>)，算不出来就放弃。</p>
<h4>✅ Task 6: 最终打分 (Scoring)</h4>
<p><strong>代码对应：</strong> <code>compute_score</code>
*   <strong>动作：</strong>
    *   这是对外的总接口。它把上面所有步骤串起来。
    *   它返回三个东西：
        1.  <code>is_correct</code>: 到底对不对（True/False）。
        2.  <code>format_correctness</code>: 格式是否规范（比如有没有用 <code>\boxed</code>）。
        3.  <code>extracted_model_output</code>: 提取出来的具体答案是什么。</p>
<hr />
<h3>💡 核心观点总结</h3>
<p>这个文件的核心观点可以总结为：</p>
<ol>
<li><strong>文本相等 $\neq$ 数学相等</strong>：不能只靠字符串匹配来判分，必须引入数学解析工具（SymPy）。</li>
<li><strong>鲁棒性（Robustness）优先</strong>：AI 的输出千奇百怪（有逗号、有单位、有LaTeX、有废话），必须经过层层清洗（Normalize）才能拿去计算。</li>
<li><strong>计算验证法</strong>：判断两个数学表达式相等的最好办法，是看它们的<strong>差是否为零</strong>。</li>
<li><strong>安全兜底</strong>：不能盲目运行 AI 生成的数学表达式，必须有超时机制和字符过滤，防止程序崩溃。</li>
</ol>
<p>希望这个 List 和讲解能帮你读懂这个代码！它其实就是一个<strong>“清洗数据 -&gt; 提取核心 -&gt; 数学验证”</strong>的流水线。</p>